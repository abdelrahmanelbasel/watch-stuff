"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@stencil+core@2.5.2";
exports.ids = ["vendor-chunks/@stencil+core@2.5.2"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@stencil+core@2.5.2/node_modules/@stencil/core/internal/client/index.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@stencil+core@2.5.2/node_modules/@stencil/core/internal/client/index.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BUILD: () => (/* reexport safe */ _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD),\n/* harmony export */   Build: () => (/* binding */ Build),\n/* harmony export */   CSS: () => (/* binding */ CSS),\n/* harmony export */   Context: () => (/* binding */ Context),\n/* harmony export */   Env: () => (/* reexport safe */ _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.Env),\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   H: () => (/* binding */ H),\n/* harmony export */   HTMLElement: () => (/* binding */ H),\n/* harmony export */   Host: () => (/* binding */ Host),\n/* harmony export */   NAMESPACE: () => (/* reexport safe */ _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.NAMESPACE),\n/* harmony export */   STENCIL_DEV_MODE: () => (/* binding */ STENCIL_DEV_MODE),\n/* harmony export */   addHostEventListeners: () => (/* binding */ addHostEventListeners),\n/* harmony export */   attachShadow: () => (/* binding */ attachShadow),\n/* harmony export */   bootstrapLazy: () => (/* binding */ bootstrapLazy),\n/* harmony export */   cmpModules: () => (/* binding */ cmpModules),\n/* harmony export */   connectedCallback: () => (/* binding */ connectedCallback),\n/* harmony export */   consoleDevError: () => (/* binding */ consoleDevError),\n/* harmony export */   consoleDevInfo: () => (/* binding */ consoleDevInfo),\n/* harmony export */   consoleDevWarn: () => (/* binding */ consoleDevWarn),\n/* harmony export */   consoleError: () => (/* binding */ consoleError),\n/* harmony export */   createEvent: () => (/* binding */ createEvent),\n/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement),\n/* harmony export */   disconnectedCallback: () => (/* binding */ disconnectedCallback),\n/* harmony export */   doc: () => (/* binding */ doc),\n/* harmony export */   forceModeUpdate: () => (/* binding */ forceModeUpdate),\n/* harmony export */   forceUpdate: () => (/* binding */ forceUpdate),\n/* harmony export */   getAssetPath: () => (/* binding */ getAssetPath),\n/* harmony export */   getConnect: () => (/* binding */ getConnect),\n/* harmony export */   getContext: () => (/* binding */ getContext),\n/* harmony export */   getElement: () => (/* binding */ getElement),\n/* harmony export */   getHostRef: () => (/* binding */ getHostRef),\n/* harmony export */   getMode: () => (/* binding */ getMode),\n/* harmony export */   getRenderingRef: () => (/* binding */ getRenderingRef),\n/* harmony export */   getValue: () => (/* binding */ getValue),\n/* harmony export */   h: () => (/* binding */ h),\n/* harmony export */   insertVdomAnnotations: () => (/* binding */ insertVdomAnnotations),\n/* harmony export */   isMemberInElement: () => (/* binding */ isMemberInElement),\n/* harmony export */   loadModule: () => (/* binding */ loadModule),\n/* harmony export */   modeResolutionChain: () => (/* binding */ modeResolutionChain),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   parsePropertyValue: () => (/* binding */ parsePropertyValue),\n/* harmony export */   plt: () => (/* binding */ plt),\n/* harmony export */   postUpdateComponent: () => (/* binding */ postUpdateComponent),\n/* harmony export */   promiseResolve: () => (/* binding */ promiseResolve),\n/* harmony export */   proxyComponent: () => (/* binding */ proxyComponent),\n/* harmony export */   proxyCustomElement: () => (/* binding */ proxyCustomElement),\n/* harmony export */   readTask: () => (/* binding */ readTask),\n/* harmony export */   registerHost: () => (/* binding */ registerHost),\n/* harmony export */   registerInstance: () => (/* binding */ registerInstance),\n/* harmony export */   renderVdom: () => (/* binding */ renderVdom),\n/* harmony export */   setAssetPath: () => (/* binding */ setAssetPath),\n/* harmony export */   setErrorHandler: () => (/* binding */ setErrorHandler),\n/* harmony export */   setMode: () => (/* binding */ setMode),\n/* harmony export */   setPlatformOptions: () => (/* binding */ setPlatformOptions),\n/* harmony export */   setValue: () => (/* binding */ setValue),\n/* harmony export */   styles: () => (/* binding */ styles),\n/* harmony export */   supportsConstructibleStylesheets: () => (/* binding */ supportsConstructibleStylesheets),\n/* harmony export */   supportsListenerOptions: () => (/* binding */ supportsListenerOptions),\n/* harmony export */   supportsShadow: () => (/* binding */ supportsShadow),\n/* harmony export */   win: () => (/* binding */ win),\n/* harmony export */   writeTask: () => (/* binding */ writeTask)\n/* harmony export */ });\n/* harmony import */ var _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @stencil/core/internal/app-data */ \"(ssr)/./node_modules/.pnpm/@stencil+core@2.5.2/node_modules/@stencil/core/internal/app-data/index.js\");\nlet scopeId;\nlet contentRef;\nlet hostTagName;\nlet customError;\nlet i = 0;\nlet useNativeShadowDom = false;\nlet checkSlotFallbackVisibility = false;\nlet checkSlotRelocate = false;\nlet isSvgMode = false;\nlet renderingRef = null;\nlet queueCongestion = 0;\nlet queuePending = false;\n/*\n Stencil Client Platform v2.5.2 | MIT Licensed | https://stenciljs.com\n */ \nconst win =  false ? 0 : {};\nconst CSS = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssVarShim ? win.CSS : null;\nconst doc = win.document || {\n    head: {}\n};\nconst H = win.HTMLElement || class {\n};\nconst plt = {\n    $flags$: 0,\n    $resourcesUrl$: \"\",\n    jmp: (h)=>h(),\n    raf: (h)=>requestAnimationFrame(h),\n    ael: (el, eventName, listener, opts)=>el.addEventListener(eventName, listener, opts),\n    rel: (el, eventName, listener, opts)=>el.removeEventListener(eventName, listener, opts),\n    ce: (eventName, opts)=>new CustomEvent(eventName, opts)\n};\nconst supportsShadow = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDomShim && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom ? /*@__PURE__*/ (()=>(doc.head.attachShadow + \"\").indexOf(\"[native\") > -1)() : true;\nconst supportsListenerOptions = /*@__PURE__*/ (()=>{\n    let supportsListenerOptions = false;\n    try {\n        doc.addEventListener(\"e\", null, Object.defineProperty({}, \"passive\", {\n            get () {\n                supportsListenerOptions = true;\n            }\n        }));\n    } catch (e) {}\n    return supportsListenerOptions;\n})();\nconst promiseResolve = (v)=>Promise.resolve(v);\nconst supportsConstructibleStylesheets = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.constructableCSS ? /*@__PURE__*/ (()=>{\n    try {\n        new CSSStyleSheet();\n        return typeof new CSSStyleSheet().replace === \"function\";\n    } catch (e) {}\n    return false;\n})() : false;\nconst Context = {};\nconst addHostEventListeners = (elm, hostRef, listeners, attachParentListeners)=>{\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener && listeners) {\n        // this is called immediately within the element's constructor\n        // initialize our event listeners on the host element\n        // we do this now so that we can listen to events that may\n        // have fired even before the instance is ready\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetParent) {\n            // this component may have event listeners that should be attached to the parent\n            if (attachParentListeners) {\n                // this is being ran from within the connectedCallback\n                // which is important so that we know the host element actually has a parent element\n                // filter out the listeners to only have the ones that ARE being attached to the parent\n                listeners = listeners.filter(([flags])=>flags & 32 /* TargetParent */ );\n            } else {\n                // this is being ran from within the component constructor\n                // everything BUT the parent element listeners should be attached at this time\n                // filter out the listeners that are NOT being attached to the parent\n                listeners = listeners.filter(([flags])=>!(flags & 32 /* TargetParent */ ));\n            }\n        }\n        listeners.map(([flags, name, method])=>{\n            const target = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTarget ? getHostListenerTarget(elm, flags) : elm;\n            const handler = hostListenerProxy(hostRef, method);\n            const opts = hostListenerOpts(flags);\n            plt.ael(target, name, handler, opts);\n            (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(()=>plt.rel(target, name, handler, opts));\n        });\n    }\n};\nconst hostListenerProxy = (hostRef, methodName)=>(ev)=>{\n        try {\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad) {\n                if (hostRef.$flags$ & 256 /* isListenReady */ ) {\n                    // instance is ready, let's call it's member method for this event\n                    hostRef.$lazyInstance$[methodName](ev);\n                } else {\n                    (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([\n                        methodName,\n                        ev\n                    ]);\n                }\n            } else {\n                hostRef.$hostElement$[methodName](ev);\n            }\n        } catch (e) {\n            consoleError(e);\n        }\n    };\nconst getHostListenerTarget = (elm, flags)=>{\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetDocument && flags & 4 /* TargetDocument */ ) return doc;\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetWindow && flags & 8 /* TargetWindow */ ) return win;\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetBody && flags & 16 /* TargetBody */ ) return doc.body;\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetParent && flags & 32 /* TargetParent */ ) return elm.parentElement;\n    return elm;\n};\n// prettier-ignore\nconst hostListenerOpts = (flags)=>supportsListenerOptions ? {\n        passive: (flags & 1 /* Passive */ ) !== 0,\n        capture: (flags & 2 /* Capture */ ) !== 0\n    } : (flags & 2 /* Capture */ ) !== 0;\nconst CONTENT_REF_ID = \"r\";\nconst ORG_LOCATION_ID = \"o\";\nconst SLOT_NODE_ID = \"s\";\nconst TEXT_NODE_ID = \"t\";\nconst HYDRATE_ID = \"s-id\";\nconst HYDRATED_STYLE_ID = \"sty-id\";\nconst HYDRATE_CHILD_ID = \"c-id\";\nconst HYDRATED_CSS = \"{visibility:hidden}.hydrated{visibility:inherit}\";\nconst XLINK_NS = \"http://www.w3.org/1999/xlink\";\nconst createTime = (fnName, tagName = \"\")=>{\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile && performance.mark) {\n        const key = `st:${fnName}:${tagName}:${i++}`;\n        // Start\n        performance.mark(key);\n        // End\n        return ()=>performance.measure(`[Stencil] ${fnName}() <${tagName}>`, key);\n    } else {\n        return ()=>{\n            return;\n        };\n    }\n};\nconst uniqueTime = (key, measureText)=>{\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile && performance.mark) {\n        if (performance.getEntriesByName(key).length === 0) {\n            performance.mark(key);\n        }\n        return ()=>{\n            if (performance.getEntriesByName(measureText).length === 0) {\n                performance.measure(measureText, key);\n            }\n        };\n    } else {\n        return ()=>{\n            return;\n        };\n    }\n};\nconst inspect = (ref)=>{\n    const hostRef = getHostRef(ref);\n    if (!hostRef) {\n        return undefined;\n    }\n    const flags = hostRef.$flags$;\n    const hostElement = hostRef.$hostElement$;\n    return {\n        renderCount: hostRef.$renderCount$,\n        flags: {\n            hasRendered: !!(flags & 2 /* hasRendered */ ),\n            hasConnected: !!(flags & 1 /* hasConnected */ ),\n            isWaitingForChildren: !!(flags & 4 /* isWaitingForChildren */ ),\n            isConstructingInstance: !!(flags & 8 /* isConstructingInstance */ ),\n            isQueuedForUpdate: !!(flags & 16 /* isQueuedForUpdate */ ),\n            hasInitializedComponent: !!(flags & 32 /* hasInitializedComponent */ ),\n            hasLoadedComponent: !!(flags & 64 /* hasLoadedComponent */ ),\n            isWatchReady: !!(flags & 128 /* isWatchReady */ ),\n            isListenReady: !!(flags & 256 /* isListenReady */ ),\n            needsRerender: !!(flags & 512 /* needsRerender */ )\n        },\n        instanceValues: hostRef.$instanceValues$,\n        ancestorComponent: hostRef.$ancestorComponent$,\n        hostElement,\n        lazyInstance: hostRef.$lazyInstance$,\n        vnode: hostRef.$vnode$,\n        modeName: hostRef.$modeName$,\n        onReadyPromise: hostRef.$onReadyPromise$,\n        onReadyResolve: hostRef.$onReadyResolve$,\n        onInstancePromise: hostRef.$onInstancePromise$,\n        onInstanceResolve: hostRef.$onInstanceResolve$,\n        onRenderResolve: hostRef.$onRenderResolve$,\n        queuedListeners: hostRef.$queuedListeners$,\n        rmListeners: hostRef.$rmListeners$,\n        [\"s-id\"]: hostElement[\"s-id\"],\n        [\"s-cr\"]: hostElement[\"s-cr\"],\n        [\"s-lr\"]: hostElement[\"s-lr\"],\n        [\"s-p\"]: hostElement[\"s-p\"],\n        [\"s-rc\"]: hostElement[\"s-rc\"],\n        [\"s-sc\"]: hostElement[\"s-sc\"]\n    };\n};\nconst installDevTools = ()=>{\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.devTools) {\n        const stencil = win.stencil = win.stencil || {};\n        const originalInspect = stencil.inspect;\n        stencil.inspect = (ref)=>{\n            let result = inspect(ref);\n            if (!result && typeof originalInspect === \"function\") {\n                result = originalInspect(ref);\n            }\n            return result;\n        };\n    }\n};\nconst rootAppliedStyles = new WeakMap();\nconst registerStyle = (scopeId, cssText, allowCS)=>{\n    let style = styles.get(scopeId);\n    if (supportsConstructibleStylesheets && allowCS) {\n        style = style || new CSSStyleSheet();\n        style.replace(cssText);\n    } else {\n        style = cssText;\n    }\n    styles.set(scopeId, style);\n};\nconst addStyle = (styleContainerNode, cmpMeta, mode, hostElm)=>{\n    let scopeId = getScopeId(cmpMeta, mode);\n    let style = styles.get(scopeId);\n    if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.attachStyles) {\n        return scopeId;\n    }\n    // if an element is NOT connected then getRootNode() will return the wrong root node\n    // so the fallback is to always use the document for the root node in those cases\n    styleContainerNode = styleContainerNode.nodeType === 11 /* DocumentFragment */  ? styleContainerNode : doc;\n    if (style) {\n        if (typeof style === \"string\") {\n            styleContainerNode = styleContainerNode.head || styleContainerNode;\n            let appliedStyles = rootAppliedStyles.get(styleContainerNode);\n            let styleElm;\n            if (!appliedStyles) {\n                rootAppliedStyles.set(styleContainerNode, appliedStyles = new Set());\n            }\n            if (!appliedStyles.has(scopeId)) {\n                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide && styleContainerNode.host && (styleElm = styleContainerNode.querySelector(`[${HYDRATED_STYLE_ID}=\"${scopeId}\"]`))) {\n                    // This is only happening on native shadow-dom, do not needs CSS var shim\n                    styleElm.innerHTML = style;\n                } else {\n                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssVarShim && plt.$cssShim$) {\n                        styleElm = plt.$cssShim$.createHostStyle(hostElm, scopeId, style, !!(cmpMeta.$flags$ & 10 /* needsScopedEncapsulation */ ));\n                        const newScopeId = styleElm[\"s-sc\"];\n                        if (newScopeId) {\n                            scopeId = newScopeId;\n                            // we don't want to add this styleID to the appliedStyles Set\n                            // since the cssVarShim might need to apply several different\n                            // stylesheets for the same component\n                            appliedStyles = null;\n                        }\n                    } else {\n                        styleElm = doc.createElement(\"style\");\n                        styleElm.innerHTML = style;\n                    }\n                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement) {\n                        styleElm.setAttribute(HYDRATED_STYLE_ID, scopeId);\n                    }\n                    styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector(\"link\"));\n                }\n                if (appliedStyles) {\n                    appliedStyles.add(scopeId);\n                }\n            }\n        } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.constructableCSS && !styleContainerNode.adoptedStyleSheets.includes(style)) {\n            styleContainerNode.adoptedStyleSheets = [\n                ...styleContainerNode.adoptedStyleSheets,\n                style\n            ];\n        }\n    }\n    return scopeId;\n};\nconst attachStyles = (hostRef)=>{\n    const cmpMeta = hostRef.$cmpMeta$;\n    const elm = hostRef.$hostElement$;\n    const flags = cmpMeta.$flags$;\n    const endAttachStyles = createTime(\"attachStyles\", cmpMeta.$tagName$);\n    const scopeId = addStyle(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && supportsShadow && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$, elm);\n    if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped) && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssAnnotations && flags & 10 /* needsScopedEncapsulation */ ) {\n        // only required when we're NOT using native shadow dom (slot)\n        // or this browser doesn't support native shadow dom\n        // and this host element was NOT created with SSR\n        // let's pick out the inner content for slot projection\n        // create a node to represent where the original\n        // content was first placed, which is useful later on\n        // DOM WRITE!!\n        elm[\"s-sc\"] = scopeId;\n        elm.classList.add(scopeId + \"-h\");\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped && flags & 2 /* scopedCssEncapsulation */ ) {\n            elm.classList.add(scopeId + \"-s\");\n        }\n    }\n    endAttachStyles();\n};\nconst getScopeId = (cmp, mode)=>\"sc-\" + (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.mode && mode && cmp.$flags$ & 32 /* hasMode */  ? cmp.$tagName$ + \"-\" + mode : cmp.$tagName$);\nconst convertScopedToShadow = (css)=>css.replace(/\\/\\*!@([^\\/]+)\\*\\/[^\\{]+\\{/g, \"$1{\");\n// Private\nconst computeMode = (elm)=>modeResolutionChain.map((h)=>h(elm)).find((m)=>!!m);\n// Public\nconst setMode = (handler)=>modeResolutionChain.push(handler);\nconst getMode = (ref)=>getHostRef(ref).$modeName$;\n/**\n * Default style mode id\n */ /**\n * Reusable empty obj/array\n * Don't add values to these!!\n */ const EMPTY_OBJ = {};\n/**\n * Namespaces\n */ const SVG_NS = \"http://www.w3.org/2000/svg\";\nconst HTML_NS = \"http://www.w3.org/1999/xhtml\";\nconst isDef = (v)=>v != null;\nconst isComplexType = (o)=>{\n    // https://jsperf.com/typeof-fn-object/5\n    o = typeof o;\n    return o === \"object\" || o === \"function\";\n};\n/**\n * Production h() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */ // const stack: any[] = [];\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;\nconst h = (nodeName, vnodeData, ...children)=>{\n    let child = null;\n    let key = null;\n    let slotName = null;\n    let simple = false;\n    let lastSimple = false;\n    let vNodeChildren = [];\n    const walk = (c)=>{\n        for(let i = 0; i < c.length; i++){\n            child = c[i];\n            if (Array.isArray(child)) {\n                walk(child);\n            } else if (child != null && typeof child !== \"boolean\") {\n                if (simple = typeof nodeName !== \"function\" && !isComplexType(child)) {\n                    child = String(child);\n                } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && typeof nodeName !== \"function\" && child.$flags$ === undefined) {\n                    consoleDevError(`vNode passed as children has unexpected type.\nMake sure it's using the correct h() function.\nEmpty objects can also be the cause, look for JSX comments that became objects.`);\n                }\n                if (simple && lastSimple) {\n                    // If the previous child was simple (string), we merge both\n                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;\n                } else {\n                    // Append a new vNode, if it's text, we create a text vNode\n                    vNodeChildren.push(simple ? newVNode(null, child) : child);\n                }\n                lastSimple = simple;\n            }\n        }\n    };\n    walk(children);\n    if (vnodeData) {\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && nodeName === \"input\") {\n            validateInputProperties(vnodeData);\n        }\n        // normalize class / classname attributes\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey && vnodeData.key) {\n            key = vnodeData.key;\n        }\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && vnodeData.name) {\n            slotName = vnodeData.name;\n        }\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomClass) {\n            const classData = vnodeData.className || vnodeData.class;\n            if (classData) {\n                vnodeData.class = typeof classData !== \"object\" ? classData : Object.keys(classData).filter((k)=>classData[k]).join(\" \");\n            }\n        }\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && vNodeChildren.some(isHost)) {\n        consoleDevError(`The <Host> must be the single root component. Make sure:\n- You are NOT using hostData() and <Host> in the same component.\n- <Host> is used once, and it's the single root component of the render() function.`);\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomFunctional && typeof nodeName === \"function\") {\n        // nodeName is a functional component\n        return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);\n    }\n    const vnode = newVNode(nodeName, null);\n    vnode.$attrs$ = vnodeData;\n    if (vNodeChildren.length > 0) {\n        vnode.$children$ = vNodeChildren;\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey) {\n        vnode.$key$ = key;\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {\n        vnode.$name$ = slotName;\n    }\n    return vnode;\n};\nconst newVNode = (tag, text)=>{\n    const vnode = {\n        $flags$: 0,\n        $tag$: tag,\n        $text$: text,\n        $elm$: null,\n        $children$: null\n    };\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomAttribute) {\n        vnode.$attrs$ = null;\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey) {\n        vnode.$key$ = null;\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {\n        vnode.$name$ = null;\n    }\n    return vnode;\n};\nconst Host = {};\nconst isHost = (node)=>node && node.$tag$ === Host;\nconst vdomFnUtils = {\n    forEach: (children, cb)=>children.map(convertToPublic).forEach(cb),\n    map: (children, cb)=>children.map(convertToPublic).map(cb).map(convertToPrivate)\n};\nconst convertToPublic = (node)=>({\n        vattrs: node.$attrs$,\n        vchildren: node.$children$,\n        vkey: node.$key$,\n        vname: node.$name$,\n        vtag: node.$tag$,\n        vtext: node.$text$\n    });\nconst convertToPrivate = (node)=>{\n    if (typeof node.vtag === \"function\") {\n        const vnodeData = Object.assign({}, node.vattrs);\n        if (node.vkey) {\n            vnodeData.key = node.vkey;\n        }\n        if (node.vname) {\n            vnodeData.name = node.vname;\n        }\n        return h(node.vtag, vnodeData, ...node.vchildren || []);\n    }\n    const vnode = newVNode(node.vtag, node.vtext);\n    vnode.$attrs$ = node.vattrs;\n    vnode.$children$ = node.vchildren;\n    vnode.$key$ = node.vkey;\n    vnode.$name$ = node.vname;\n    return vnode;\n};\nconst validateInputProperties = (vnodeData)=>{\n    const props = Object.keys(vnodeData);\n    const typeIndex = props.indexOf(\"type\");\n    const minIndex = props.indexOf(\"min\");\n    const maxIndex = props.indexOf(\"max\");\n    const stepIndex = props.indexOf(\"min\");\n    const value = props.indexOf(\"value\");\n    if (value === -1) {\n        return;\n    }\n    if (value < typeIndex || value < minIndex || value < maxIndex || value < stepIndex) {\n        consoleDevWarn(`The \"value\" prop of <input> should be set after \"min\", \"max\", \"type\" and \"step\"`);\n    }\n};\n/**\n * Production setAccessor() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */ const setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags)=>{\n    if (oldValue !== newValue) {\n        let isProp = isMemberInElement(elm, memberName);\n        let ln = memberName.toLowerCase();\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomClass && memberName === \"class\") {\n            const classList = elm.classList;\n            const oldClasses = parseClassList(oldValue);\n            const newClasses = parseClassList(newValue);\n            classList.remove(...oldClasses.filter((c)=>c && !newClasses.includes(c)));\n            classList.add(...newClasses.filter((c)=>c && !oldClasses.includes(c)));\n        } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomStyle && memberName === \"style\") {\n            // update style attribute, css properties and values\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable) {\n                for(const prop in oldValue){\n                    if (!newValue || newValue[prop] == null) {\n                        if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide && prop.includes(\"-\")) {\n                            elm.style.removeProperty(prop);\n                        } else {\n                            elm.style[prop] = \"\";\n                        }\n                    }\n                }\n            }\n            for(const prop in newValue){\n                if (!oldValue || newValue[prop] !== oldValue[prop]) {\n                    if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide && prop.includes(\"-\")) {\n                        elm.style.setProperty(prop, newValue[prop]);\n                    } else {\n                        elm.style[prop] = newValue[prop];\n                    }\n                }\n            }\n        } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey && memberName === \"key\") ;\n        else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomRef && memberName === \"ref\") {\n            // minifier will clean this up\n            if (newValue) {\n                newValue(elm);\n            }\n        } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomListener && (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? !isProp : !elm.__lookupSetter__(memberName)) && memberName[0] === \"o\" && memberName[1] === \"n\") {\n            // Event Handlers\n            // so if the member name starts with \"on\" and the 3rd characters is\n            // a capital letter, and it's not already a member on the element,\n            // then we're assuming it's an event listener\n            if (memberName[2] === \"-\") {\n                // on- prefixed events\n                // allows to be explicit about the dom event to listen without any magic\n                // under the hood:\n                // <my-cmp on-click> // listens for \"click\"\n                // <my-cmp on-Click> // listens for \"Click\"\n                // <my-cmp on-ionChange> // listens for \"ionChange\"\n                // <my-cmp on-EVENTS> // listens for \"EVENTS\"\n                memberName = memberName.slice(3);\n            } else if (isMemberInElement(win, ln)) {\n                // standard event\n                // the JSX attribute could have been \"onMouseOver\" and the\n                // member name \"onmouseover\" is on the window's prototype\n                // so let's add the listener \"mouseover\", which is all lowercased\n                memberName = ln.slice(2);\n            } else {\n                // custom event\n                // the JSX attribute could have been \"onMyCustomEvent\"\n                // so let's trim off the \"on\" prefix and lowercase the first character\n                // and add the listener \"myCustomEvent\"\n                // except for the first character, we keep the event name case\n                memberName = ln[2] + memberName.slice(3);\n            }\n            if (oldValue) {\n                plt.rel(elm, memberName, oldValue, false);\n            }\n            if (newValue) {\n                plt.ael(elm, memberName, newValue, false);\n            }\n        } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomPropOrAttr) {\n            // Set property if it exists and it's not a SVG\n            const isComplex = isComplexType(newValue);\n            if ((isProp || isComplex && newValue !== null) && !isSvg) {\n                try {\n                    if (!elm.tagName.includes(\"-\")) {\n                        let n = newValue == null ? \"\" : newValue;\n                        // Workaround for Safari, moving the <input> caret when re-assigning the same valued\n                        if (memberName === \"list\") {\n                            isProp = false;\n                        // tslint:disable-next-line: triple-equals\n                        } else if (oldValue == null || elm[memberName] != n) {\n                            elm[memberName] = n;\n                        }\n                    } else {\n                        elm[memberName] = newValue;\n                    }\n                } catch (e) {}\n            }\n            /**\n             * Need to manually update attribute if:\n             * - memberName is not an attribute\n             * - if we are rendering the host element in order to reflect attribute\n             * - if it's a SVG, since properties might not work in <svg>\n             * - if the newValue is null/undefined or 'false'.\n             */ let xlink = false;\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomXlink) {\n                if (ln !== (ln = ln.replace(/^xlink\\:?/, \"\"))) {\n                    memberName = ln;\n                    xlink = true;\n                }\n            }\n            if (newValue == null || newValue === false) {\n                if (newValue !== false || elm.getAttribute(memberName) === \"\") {\n                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomXlink && xlink) {\n                        elm.removeAttributeNS(XLINK_NS, memberName);\n                    } else {\n                        elm.removeAttribute(memberName);\n                    }\n                }\n            } else if ((!isProp || flags & 4 /* isHost */  || isSvg) && !isComplex) {\n                newValue = newValue === true ? \"\" : newValue;\n                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomXlink && xlink) {\n                    elm.setAttributeNS(XLINK_NS, memberName, newValue);\n                } else {\n                    elm.setAttribute(memberName, newValue);\n                }\n            }\n        }\n    }\n};\nconst parseClassListRegex = /\\s/;\nconst parseClassList = (value)=>!value ? [] : value.split(parseClassListRegex);\nconst updateElement = (oldVnode, newVnode, isSvgMode, memberName)=>{\n    // if the element passed in is a shadow root, which is a document fragment\n    // then we want to be adding attrs/props to the shadow root's \"host\" element\n    // if it's not a shadow root, then we add attrs/props to the same element\n    const elm = newVnode.$elm$.nodeType === 11 /* DocumentFragment */  && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;\n    const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;\n    const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable) {\n        // remove attributes no longer present on the vnode by setting them to undefined\n        for(memberName in oldVnodeAttrs){\n            if (!(memberName in newVnodeAttrs)) {\n                setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);\n            }\n        }\n    }\n    // add new & update changed attributes\n    for(memberName in newVnodeAttrs){\n        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);\n    }\n};\nconst createElm = (oldParentVNode, newParentVNode, childIndex, parentElm)=>{\n    // tslint:disable-next-line: prefer-const\n    let newVNode = newParentVNode.$children$[childIndex];\n    let i = 0;\n    let elm;\n    let childNode;\n    let oldVNode;\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && !useNativeShadowDom) {\n        // remember for later we need to check to relocate nodes\n        checkSlotRelocate = true;\n        if (newVNode.$tag$ === \"slot\") {\n            if (scopeId) {\n                // scoped css needs to add its scoped id to the parent element\n                parentElm.classList.add(scopeId + \"-s\");\n            }\n            newVNode.$flags$ |= newVNode.$children$ ? 2 /* isSlotFallback */  : 1 /* isSlotReference */ ;\n        }\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && newVNode.$elm$) {\n        consoleDevError(`The JSX ${newVNode.$text$ !== null ? `\"${newVNode.$text$}\" text` : `\"${newVNode.$tag$}\" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`);\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText && newVNode.$text$ !== null) {\n        // create text node\n        elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);\n    } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && newVNode.$flags$ & 1 /* isSlotReference */ ) {\n        // create a slot reference node\n        elm = newVNode.$elm$ = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDebug || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide ? slotReferenceDebugNode(newVNode) : doc.createTextNode(\"\");\n    } else {\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg && !isSvgMode) {\n            isSvgMode = newVNode.$tag$ === \"svg\";\n        }\n        // create element\n        elm = newVNode.$elm$ = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg ? doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && newVNode.$flags$ & 2 /* isSlotFallback */  ? \"slot-fb\" : newVNode.$tag$) : doc.createElement(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && newVNode.$flags$ & 2 /* isSlotFallback */  ? \"slot-fb\" : newVNode.$tag$);\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg && isSvgMode && newVNode.$tag$ === \"foreignObject\") {\n            isSvgMode = false;\n        }\n        // add css classes, attrs, props, listeners, etc.\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomAttribute) {\n            updateElement(null, newVNode, isSvgMode);\n        }\n        if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped) && isDef(scopeId) && elm[\"s-si\"] !== scopeId) {\n            // if there is a scopeId and this is the initial render\n            // then let's add the scopeId as a css class\n            elm.classList.add(elm[\"s-si\"] = scopeId);\n        }\n        if (newVNode.$children$) {\n            for(i = 0; i < newVNode.$children$.length; ++i){\n                // create the node\n                childNode = createElm(oldParentVNode, newVNode, i, elm);\n                // return node could have been null\n                if (childNode) {\n                    // append our new node\n                    elm.appendChild(childNode);\n                }\n            }\n        }\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg) {\n            if (newVNode.$tag$ === \"svg\") {\n                // Only reset the SVG context when we're exiting <svg> element\n                isSvgMode = false;\n            } else if (elm.tagName === \"foreignObject\") {\n                // Reenter SVG context when we're exiting <foreignObject> element\n                isSvgMode = true;\n            }\n        }\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {\n        elm[\"s-hn\"] = hostTagName;\n        if (newVNode.$flags$ & (2 /* isSlotFallback */  | 1 /* isSlotReference */ )) {\n            // remember the content reference comment\n            elm[\"s-sr\"] = true;\n            // remember the content reference comment\n            elm[\"s-cr\"] = contentRef;\n            // remember the slot name, or empty string for default slot\n            elm[\"s-sn\"] = newVNode.$name$ || \"\";\n            // check if we've got an old vnode for this slot\n            oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];\n            if (oldVNode && oldVNode.$tag$ === newVNode.$tag$ && oldParentVNode.$elm$) {\n                // we've got an old slot vnode and the wrapper is being replaced\n                // so let's move the old slot content back to it's original location\n                putBackInOriginalLocation(oldParentVNode.$elm$, false);\n            }\n        }\n    }\n    return elm;\n};\nconst putBackInOriginalLocation = (parentElm, recursive)=>{\n    plt.$flags$ |= 1 /* isTmpDisconnected */ ;\n    const oldSlotChildNodes = parentElm.childNodes;\n    for(let i = oldSlotChildNodes.length - 1; i >= 0; i--){\n        const childNode = oldSlotChildNodes[i];\n        if (childNode[\"s-hn\"] !== hostTagName && childNode[\"s-ol\"]) {\n            // // this child node in the old element is from another component\n            // // remove this node from the old slot's parent\n            // childNode.remove();\n            // and relocate it back to it's original location\n            parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));\n            // remove the old original location comment entirely\n            // later on the patch function will know what to do\n            // and move this to the correct spot in need be\n            childNode[\"s-ol\"].remove();\n            childNode[\"s-ol\"] = undefined;\n            checkSlotRelocate = true;\n        }\n        if (recursive) {\n            putBackInOriginalLocation(childNode, recursive);\n        }\n    }\n    plt.$flags$ &= ~1 /* isTmpDisconnected */ ;\n};\nconst addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx)=>{\n    let containerElm = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && parentElm[\"s-cr\"] && parentElm[\"s-cr\"].parentNode || parentElm;\n    let childNode;\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && containerElm.shadowRoot && containerElm.tagName === hostTagName) {\n        containerElm = containerElm.shadowRoot;\n    }\n    for(; startIdx <= endIdx; ++startIdx){\n        if (vnodes[startIdx]) {\n            childNode = createElm(null, parentVNode, startIdx, parentElm);\n            if (childNode) {\n                vnodes[startIdx].$elm$ = childNode;\n                containerElm.insertBefore(childNode, _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation ? referenceNode(before) : before);\n            }\n        }\n    }\n};\nconst removeVnodes = (vnodes, startIdx, endIdx, vnode, elm)=>{\n    for(; startIdx <= endIdx; ++startIdx){\n        if (vnode = vnodes[startIdx]) {\n            elm = vnode.$elm$;\n            callNodeRefs(vnode);\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {\n                // we're removing this element\n                // so it's possible we need to show slot fallback content now\n                checkSlotFallbackVisibility = true;\n                if (elm[\"s-ol\"]) {\n                    // remove the original location comment\n                    elm[\"s-ol\"].remove();\n                } else {\n                    // it's possible that child nodes of the node\n                    // that's being removed are slot nodes\n                    putBackInOriginalLocation(elm, true);\n                }\n            }\n            // remove the vnode's element from the dom\n            elm.remove();\n        }\n    }\n};\nconst updateChildren = (parentElm, oldCh, newVNode, newCh)=>{\n    let oldStartIdx = 0;\n    let newStartIdx = 0;\n    let idxInOld = 0;\n    let i = 0;\n    let oldEndIdx = oldCh.length - 1;\n    let oldStartVnode = oldCh[0];\n    let oldEndVnode = oldCh[oldEndIdx];\n    let newEndIdx = newCh.length - 1;\n    let newStartVnode = newCh[0];\n    let newEndVnode = newCh[newEndIdx];\n    let node;\n    let elmToMove;\n    while(oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx){\n        if (oldStartVnode == null) {\n            // Vnode might have been moved left\n            oldStartVnode = oldCh[++oldStartIdx];\n        } else if (oldEndVnode == null) {\n            oldEndVnode = oldCh[--oldEndIdx];\n        } else if (newStartVnode == null) {\n            newStartVnode = newCh[++newStartIdx];\n        } else if (newEndVnode == null) {\n            newEndVnode = newCh[--newEndIdx];\n        } else if (isSameVnode(oldStartVnode, newStartVnode)) {\n            patch(oldStartVnode, newStartVnode);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newStartVnode = newCh[++newStartIdx];\n        } else if (isSameVnode(oldEndVnode, newEndVnode)) {\n            patch(oldEndVnode, newEndVnode);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newEndVnode = newCh[--newEndIdx];\n        } else if (isSameVnode(oldStartVnode, newEndVnode)) {\n            // Vnode moved right\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && (oldStartVnode.$tag$ === \"slot\" || newEndVnode.$tag$ === \"slot\")) {\n                putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);\n            }\n            patch(oldStartVnode, newEndVnode);\n            parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newEndVnode = newCh[--newEndIdx];\n        } else if (isSameVnode(oldEndVnode, newStartVnode)) {\n            // Vnode moved left\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && (oldStartVnode.$tag$ === \"slot\" || newEndVnode.$tag$ === \"slot\")) {\n                putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);\n            }\n            patch(oldEndVnode, newStartVnode);\n            parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newStartVnode = newCh[++newStartIdx];\n        } else {\n            // createKeyToOldIdx\n            idxInOld = -1;\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey) {\n                for(i = oldStartIdx; i <= oldEndIdx; ++i){\n                    if (oldCh[i] && oldCh[i].$key$ !== null && oldCh[i].$key$ === newStartVnode.$key$) {\n                        idxInOld = i;\n                        break;\n                    }\n                }\n            }\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey && idxInOld >= 0) {\n                elmToMove = oldCh[idxInOld];\n                if (elmToMove.$tag$ !== newStartVnode.$tag$) {\n                    node = createElm(oldCh && oldCh[newStartIdx], newVNode, idxInOld, parentElm);\n                } else {\n                    patch(elmToMove, newStartVnode);\n                    oldCh[idxInOld] = undefined;\n                    node = elmToMove.$elm$;\n                }\n                newStartVnode = newCh[++newStartIdx];\n            } else {\n                // new element\n                node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx, parentElm);\n                newStartVnode = newCh[++newStartIdx];\n            }\n            if (node) {\n                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {\n                    parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));\n                } else {\n                    oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);\n                }\n            }\n        }\n    }\n    if (oldStartIdx > oldEndIdx) {\n        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);\n    } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable && newStartIdx > newEndIdx) {\n        removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n    }\n};\nconst isSameVnode = (vnode1, vnode2)=>{\n    // compare if two vnode to see if they're \"technically\" the same\n    // need to have the same element tag, and same key to be the same\n    if (vnode1.$tag$ === vnode2.$tag$) {\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && vnode1.$tag$ === \"slot\") {\n            return vnode1.$name$ === vnode2.$name$;\n        }\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey) {\n            return vnode1.$key$ === vnode2.$key$;\n        }\n        return true;\n    }\n    return false;\n};\nconst referenceNode = (node)=>{\n    // this node was relocated to a new location in the dom\n    // because of some other component's slot\n    // but we still have an html comment in place of where\n    // it's original location was according to it's original vdom\n    return node && node[\"s-ol\"] || node;\n};\nconst parentReferenceNode = (node)=>(node[\"s-ol\"] ? node[\"s-ol\"] : node).parentNode;\nconst patch = (oldVNode, newVNode)=>{\n    const elm = newVNode.$elm$ = oldVNode.$elm$;\n    const oldChildren = oldVNode.$children$;\n    const newChildren = newVNode.$children$;\n    const tag = newVNode.$tag$;\n    const text = newVNode.$text$;\n    let defaultHolder;\n    if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText || text === null) {\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg) {\n            // test if we're rendering an svg element, or still rendering nodes inside of one\n            // only add this to the when the compiler sees we're using an svg somewhere\n            isSvgMode = tag === \"svg\" ? true : tag === \"foreignObject\" ? false : isSvgMode;\n        }\n        // element node\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomAttribute || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect) {\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slot && tag === \"slot\") ;\n            else {\n                // either this is the first render of an element OR it's an update\n                // AND we already know it's possible it could have changed\n                // this updates the element's css classes, attrs, props, listeners, etc.\n                updateElement(oldVNode, newVNode, isSvgMode);\n            }\n        }\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable && oldChildren !== null && newChildren !== null) {\n            // looks like there's child vnodes for both the old and new vnodes\n            updateChildren(elm, oldChildren, newVNode, newChildren);\n        } else if (newChildren !== null) {\n            // no old child vnodes, but there are new child vnodes to add\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText && oldVNode.$text$ !== null) {\n                // the old vnode was text, so be sure to clear it out\n                elm.textContent = \"\";\n            }\n            // add the new vnode children\n            addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);\n        } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable && oldChildren !== null) {\n            // no new child vnodes, but there are old child vnodes to remove\n            removeVnodes(oldChildren, 0, oldChildren.length - 1);\n        }\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg && isSvgMode && tag === \"svg\") {\n            isSvgMode = false;\n        }\n    } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && (defaultHolder = elm[\"s-cr\"])) {\n        // this element has slotted content\n        defaultHolder.parentNode.textContent = text;\n    } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText && oldVNode.$text$ !== text) {\n        // update the text content for the text only vnode\n        // and also only if the text is different than before\n        elm.data = text;\n    }\n};\nconst updateFallbackSlotVisibility = (elm)=>{\n    // tslint:disable-next-line: prefer-const\n    let childNodes = elm.childNodes;\n    let childNode;\n    let i;\n    let ilen;\n    let j;\n    let slotNameAttr;\n    let nodeType;\n    for(i = 0, ilen = childNodes.length; i < ilen; i++){\n        childNode = childNodes[i];\n        if (childNode.nodeType === 1 /* ElementNode */ ) {\n            if (childNode[\"s-sr\"]) {\n                // this is a slot fallback node\n                // get the slot name for this slot reference node\n                slotNameAttr = childNode[\"s-sn\"];\n                // by default always show a fallback slot node\n                // then hide it if there are other slots in the light dom\n                childNode.hidden = false;\n                for(j = 0; j < ilen; j++){\n                    nodeType = childNodes[j].nodeType;\n                    if (childNodes[j][\"s-hn\"] !== childNode[\"s-hn\"] || slotNameAttr !== \"\") {\n                        // this sibling node is from a different component OR is a named fallback slot node\n                        if (nodeType === 1 /* ElementNode */  && slotNameAttr === childNodes[j].getAttribute(\"slot\")) {\n                            childNode.hidden = true;\n                            break;\n                        }\n                    } else {\n                        // this is a default fallback slot node\n                        // any element or text node (with content)\n                        // should hide the default fallback slot node\n                        if (nodeType === 1 /* ElementNode */  || nodeType === 3 /* TextNode */  && childNodes[j].textContent.trim() !== \"\") {\n                            childNode.hidden = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            // keep drilling down\n            updateFallbackSlotVisibility(childNode);\n        }\n    }\n};\nconst relocateNodes = [];\nconst relocateSlotContent = (elm)=>{\n    // tslint:disable-next-line: prefer-const\n    let childNode;\n    let node;\n    let hostContentNodes;\n    let slotNameAttr;\n    let relocateNodeData;\n    let j;\n    let i = 0;\n    let childNodes = elm.childNodes;\n    let ilen = childNodes.length;\n    for(; i < ilen; i++){\n        childNode = childNodes[i];\n        if (childNode[\"s-sr\"] && (node = childNode[\"s-cr\"]) && node.parentNode) {\n            // first got the content reference comment node\n            // then we got it's parent, which is where all the host content is in now\n            hostContentNodes = node.parentNode.childNodes;\n            slotNameAttr = childNode[\"s-sn\"];\n            for(j = hostContentNodes.length - 1; j >= 0; j--){\n                node = hostContentNodes[j];\n                if (!node[\"s-cn\"] && !node[\"s-nr\"] && node[\"s-hn\"] !== childNode[\"s-hn\"]) {\n                    // let's do some relocating to its new home\n                    // but never relocate a content reference node\n                    // that is suppose to always represent the original content location\n                    if (isNodeLocatedInSlot(node, slotNameAttr)) {\n                        // it's possible we've already decided to relocate this node\n                        relocateNodeData = relocateNodes.find((r)=>r.$nodeToRelocate$ === node);\n                        // made some changes to slots\n                        // let's make sure we also double check\n                        // fallbacks are correctly hidden or shown\n                        checkSlotFallbackVisibility = true;\n                        node[\"s-sn\"] = node[\"s-sn\"] || slotNameAttr;\n                        if (relocateNodeData) {\n                            // previously we never found a slot home for this node\n                            // but turns out we did, so let's remember it now\n                            relocateNodeData.$slotRefNode$ = childNode;\n                        } else {\n                            // add to our list of nodes to relocate\n                            relocateNodes.push({\n                                $slotRefNode$: childNode,\n                                $nodeToRelocate$: node\n                            });\n                        }\n                        if (node[\"s-sr\"]) {\n                            relocateNodes.map((relocateNode)=>{\n                                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node[\"s-sn\"])) {\n                                    relocateNodeData = relocateNodes.find((r)=>r.$nodeToRelocate$ === node);\n                                    if (relocateNodeData && !relocateNode.$slotRefNode$) {\n                                        relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;\n                                    }\n                                }\n                            });\n                        }\n                    } else if (!relocateNodes.some((r)=>r.$nodeToRelocate$ === node)) {\n                        // so far this element does not have a slot home, not setting slotRefNode on purpose\n                        // if we never find a home for this element then we'll need to hide it\n                        relocateNodes.push({\n                            $nodeToRelocate$: node\n                        });\n                    }\n                }\n            }\n        }\n        if (childNode.nodeType === 1 /* ElementNode */ ) {\n            relocateSlotContent(childNode);\n        }\n    }\n};\nconst isNodeLocatedInSlot = (nodeToRelocate, slotNameAttr)=>{\n    if (nodeToRelocate.nodeType === 1 /* ElementNode */ ) {\n        if (nodeToRelocate.getAttribute(\"slot\") === null && slotNameAttr === \"\") {\n            return true;\n        }\n        if (nodeToRelocate.getAttribute(\"slot\") === slotNameAttr) {\n            return true;\n        }\n        return false;\n    }\n    if (nodeToRelocate[\"s-sn\"] === slotNameAttr) {\n        return true;\n    }\n    return slotNameAttr === \"\";\n};\nconst callNodeRefs = (vNode)=>{\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomRef) {\n        vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);\n        vNode.$children$ && vNode.$children$.map(callNodeRefs);\n    }\n};\nconst renderVdom = (hostRef, renderFnResults)=>{\n    const hostElm = hostRef.$hostElement$;\n    const cmpMeta = hostRef.$cmpMeta$;\n    const oldVNode = hostRef.$vnode$ || newVNode(null, null);\n    const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);\n    hostTagName = hostElm.tagName;\n    // <Host> runtime check\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && Array.isArray(renderFnResults) && renderFnResults.some(isHost)) {\n        throw new Error(`The <Host> must be the single root component.\nLooks like the render() function of \"${hostTagName.toLowerCase()}\" is returning an array that contains the <Host>.\n\nThe render() function should look like this instead:\n\nrender() {\n  // Do not return an array\n  return (\n    <Host>{content}</Host>\n  );\n}\n  `);\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect && cmpMeta.$attrsToReflect$) {\n        rootVnode.$attrs$ = rootVnode.$attrs$ || {};\n        cmpMeta.$attrsToReflect$.map(([propName, attribute])=>rootVnode.$attrs$[attribute] = hostElm[propName]);\n    }\n    rootVnode.$tag$ = null;\n    rootVnode.$flags$ |= 4 /* isHost */ ;\n    hostRef.$vnode$ = rootVnode;\n    rootVnode.$elm$ = oldVNode.$elm$ = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom ? hostElm.shadowRoot || hostElm : hostElm;\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom) {\n        scopeId = hostElm[\"s-sc\"];\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {\n        contentRef = hostElm[\"s-cr\"];\n        useNativeShadowDom = supportsShadow && (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */ ) !== 0;\n        // always reset\n        checkSlotFallbackVisibility = false;\n    }\n    // synchronous patch\n    patch(oldVNode, rootVnode);\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {\n        // while we're moving nodes around existing nodes, temporarily disable\n        // the disconnectCallback from working\n        plt.$flags$ |= 1 /* isTmpDisconnected */ ;\n        if (checkSlotRelocate) {\n            relocateSlotContent(rootVnode.$elm$);\n            let relocateData;\n            let nodeToRelocate;\n            let orgLocationNode;\n            let parentNodeRef;\n            let insertBeforeNode;\n            let refNode;\n            let i = 0;\n            for(; i < relocateNodes.length; i++){\n                relocateData = relocateNodes[i];\n                nodeToRelocate = relocateData.$nodeToRelocate$;\n                if (!nodeToRelocate[\"s-ol\"]) {\n                    // add a reference node marking this node's original location\n                    // keep a reference to this node for later lookups\n                    orgLocationNode = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDebug || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide ? originalLocationDebugNode(nodeToRelocate) : doc.createTextNode(\"\");\n                    orgLocationNode[\"s-nr\"] = nodeToRelocate;\n                    nodeToRelocate.parentNode.insertBefore(nodeToRelocate[\"s-ol\"] = orgLocationNode, nodeToRelocate);\n                }\n            }\n            for(i = 0; i < relocateNodes.length; i++){\n                relocateData = relocateNodes[i];\n                nodeToRelocate = relocateData.$nodeToRelocate$;\n                if (relocateData.$slotRefNode$) {\n                    // by default we're just going to insert it directly\n                    // after the slot reference node\n                    parentNodeRef = relocateData.$slotRefNode$.parentNode;\n                    insertBeforeNode = relocateData.$slotRefNode$.nextSibling;\n                    orgLocationNode = nodeToRelocate[\"s-ol\"];\n                    while(orgLocationNode = orgLocationNode.previousSibling){\n                        refNode = orgLocationNode[\"s-nr\"];\n                        if (refNode && refNode[\"s-sn\"] === nodeToRelocate[\"s-sn\"] && parentNodeRef === refNode.parentNode) {\n                            refNode = refNode.nextSibling;\n                            if (!refNode || !refNode[\"s-nr\"]) {\n                                insertBeforeNode = refNode;\n                                break;\n                            }\n                        }\n                    }\n                    if (!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode || nodeToRelocate.nextSibling !== insertBeforeNode) {\n                        // we've checked that it's worth while to relocate\n                        // since that the node to relocate\n                        // has a different next sibling or parent relocated\n                        if (nodeToRelocate !== insertBeforeNode) {\n                            if (!nodeToRelocate[\"s-hn\"] && nodeToRelocate[\"s-ol\"]) {\n                                // probably a component in the index.html that doesn't have it's hostname set\n                                nodeToRelocate[\"s-hn\"] = nodeToRelocate[\"s-ol\"].parentNode.nodeName;\n                            }\n                            // add it back to the dom but in its new home\n                            parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);\n                        }\n                    }\n                } else {\n                    // this node doesn't have a slot home to go to, so let's hide it\n                    if (nodeToRelocate.nodeType === 1 /* ElementNode */ ) {\n                        nodeToRelocate.hidden = true;\n                    }\n                }\n            }\n        }\n        if (checkSlotFallbackVisibility) {\n            updateFallbackSlotVisibility(rootVnode.$elm$);\n        }\n        // done moving nodes around\n        // allow the disconnect callback to work again\n        plt.$flags$ &= ~1 /* isTmpDisconnected */ ;\n        // always reset\n        relocateNodes.length = 0;\n    }\n};\n// slot comment debug nodes only created with the `--debug` flag\n// otherwise these nodes are text nodes w/out content\nconst slotReferenceDebugNode = (slotVNode)=>doc.createComment(`<slot${slotVNode.$name$ ? ' name=\"' + slotVNode.$name$ + '\"' : \"\"}> (host=${hostTagName.toLowerCase()})`);\nconst originalLocationDebugNode = (nodeToRelocate)=>doc.createComment(`org-location for ` + (nodeToRelocate.localName ? `<${nodeToRelocate.localName}> (host=${nodeToRelocate[\"s-hn\"]})` : `[${nodeToRelocate.textContent}]`));\nconst getElement = (ref)=>_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? getHostRef(ref).$hostElement$ : ref;\nconst createEvent = (ref, name, flags)=>{\n    const elm = getElement(ref);\n    return {\n        emit: (detail)=>{\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && !elm.isConnected) {\n                consoleDevWarn(`The \"${name}\" event was emitted, but the dispatcher node is no longer connected to the dom.`);\n            }\n            return emitEvent(elm, name, {\n                bubbles: !!(flags & 4 /* Bubbles */ ),\n                composed: !!(flags & 2 /* Composed */ ),\n                cancelable: !!(flags & 1 /* Cancellable */ ),\n                detail\n            });\n        }\n    };\n};\nconst emitEvent = (elm, name, opts)=>{\n    const ev = plt.ce(name, opts);\n    elm.dispatchEvent(ev);\n    return ev;\n};\nconst attachToAncestor = (hostRef, ancestorComponent)=>{\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading && ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent[\"s-p\"]) {\n        ancestorComponent[\"s-p\"].push(new Promise((r)=>hostRef.$onRenderResolve$ = r));\n    }\n};\nconst scheduleUpdate = (hostRef, isInitialLoad)=>{\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.taskQueue && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable) {\n        hostRef.$flags$ |= 16 /* isQueuedForUpdate */ ;\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading && hostRef.$flags$ & 4 /* isWaitingForChildren */ ) {\n        hostRef.$flags$ |= 512 /* needsRerender */ ;\n        return;\n    }\n    attachToAncestor(hostRef, hostRef.$ancestorComponent$);\n    // there is no ancestor component or the ancestor component\n    // has already fired off its lifecycle update then\n    // fire off the initial update\n    const dispatch = ()=>dispatchHooks(hostRef, isInitialLoad);\n    return _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.taskQueue ? writeTask(dispatch) : dispatch();\n};\nconst dispatchHooks = (hostRef, isInitialLoad)=>{\n    const elm = hostRef.$hostElement$;\n    const endSchedule = createTime(\"scheduleUpdate\", hostRef.$cmpMeta$.$tagName$);\n    const instance = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    let promise;\n    if (isInitialLoad) {\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener) {\n            hostRef.$flags$ |= 256 /* isListenReady */ ;\n            if (hostRef.$queuedListeners$) {\n                hostRef.$queuedListeners$.map(([methodName, event])=>safeCall(instance, methodName, event));\n                hostRef.$queuedListeners$ = null;\n            }\n        }\n        emitLifecycleEvent(elm, \"componentWillLoad\");\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpWillLoad) {\n            promise = safeCall(instance, \"componentWillLoad\");\n        }\n    } else {\n        emitLifecycleEvent(elm, \"componentWillUpdate\");\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpWillUpdate) {\n            promise = safeCall(instance, \"componentWillUpdate\");\n        }\n    }\n    emitLifecycleEvent(elm, \"componentWillRender\");\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpWillRender) {\n        promise = then(promise, ()=>safeCall(instance, \"componentWillRender\"));\n    }\n    endSchedule();\n    return then(promise, ()=>updateComponent(hostRef, instance, isInitialLoad));\n};\nconst updateComponent = async (hostRef, instance, isInitialLoad)=>{\n    // updateComponent\n    const elm = hostRef.$hostElement$;\n    const endUpdate = createTime(\"update\", hostRef.$cmpMeta$.$tagName$);\n    const rc = elm[\"s-rc\"];\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.style && isInitialLoad) {\n        // DOM WRITE!\n        attachStyles(hostRef);\n    }\n    const endRender = createTime(\"render\", hostRef.$cmpMeta$.$tagName$);\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {\n        hostRef.$flags$ |= 1024 /* devOnRender */ ;\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide) {\n        await callRender(hostRef, instance, elm);\n    } else {\n        callRender(hostRef, instance, elm);\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssVarShim && plt.$cssShim$) {\n        plt.$cssShim$.updateHost(elm);\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {\n        hostRef.$renderCount$++;\n        hostRef.$flags$ &= ~1024 /* devOnRender */ ;\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide) {\n        try {\n            // manually connected child components during server-side hydrate\n            serverSideConnected(elm);\n            if (isInitialLoad) {\n                // using only during server-side hydrate\n                if (hostRef.$cmpMeta$.$flags$ & 1 /* shadowDomEncapsulation */ ) {\n                    elm[\"s-en\"] = \"\";\n                } else if (hostRef.$cmpMeta$.$flags$ & 2 /* scopedCssEncapsulation */ ) {\n                    elm[\"s-en\"] = \"c\";\n                }\n            }\n        } catch (e) {\n            consoleError(e, elm);\n        }\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading && rc) {\n        // ok, so turns out there are some child host elements\n        // waiting on this parent element to load\n        // let's fire off all update callbacks waiting\n        rc.map((cb)=>cb());\n        elm[\"s-rc\"] = undefined;\n    }\n    endRender();\n    endUpdate();\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading) {\n        const childrenPromises = elm[\"s-p\"];\n        const postUpdate = ()=>postUpdateComponent(hostRef);\n        if (childrenPromises.length === 0) {\n            postUpdate();\n        } else {\n            Promise.all(childrenPromises).then(postUpdate);\n            hostRef.$flags$ |= 4 /* isWaitingForChildren */ ;\n            childrenPromises.length = 0;\n        }\n    } else {\n        postUpdateComponent(hostRef);\n    }\n};\nconst callRender = (hostRef, instance, elm)=>{\n    // in order for bundlers to correctly treeshake the BUILD object\n    // we need to ensure BUILD is not deoptimized within a try/catch\n    // https://rollupjs.org/guide/en/#treeshake tryCatchDeoptimization\n    const allRenderFn = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.allRenderFn ? true : false;\n    const lazyLoad = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? true : false;\n    const taskQueue = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.taskQueue ? true : false;\n    const updatable = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable ? true : false;\n    try {\n        renderingRef = instance;\n        instance = allRenderFn ? instance.render() : instance.render && instance.render();\n        if (updatable && taskQueue) {\n            hostRef.$flags$ &= ~16 /* isQueuedForUpdate */ ;\n        }\n        if (updatable || lazyLoad) {\n            hostRef.$flags$ |= 2 /* hasRendered */ ;\n        }\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hasRenderFn || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect) {\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomRender || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect) {\n                // looks like we've got child nodes to render into this host element\n                // or we need to update the css class/attrs on the host element\n                // DOM WRITE!\n                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide) {\n                    return Promise.resolve(instance).then((value)=>renderVdom(hostRef, value));\n                } else {\n                    renderVdom(hostRef, instance);\n                }\n            } else {\n                elm.textContent = instance;\n            }\n        }\n    } catch (e) {\n        consoleError(e, hostRef.$hostElement$);\n    }\n    renderingRef = null;\n    return null;\n};\nconst getRenderingRef = ()=>renderingRef;\nconst postUpdateComponent = (hostRef)=>{\n    const tagName = hostRef.$cmpMeta$.$tagName$;\n    const elm = hostRef.$hostElement$;\n    const endPostUpdate = createTime(\"postUpdate\", tagName);\n    const instance = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    const ancestorComponent = hostRef.$ancestorComponent$;\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpDidRender) {\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {\n            hostRef.$flags$ |= 1024 /* devOnRender */ ;\n        }\n        safeCall(instance, \"componentDidRender\");\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {\n            hostRef.$flags$ &= ~1024 /* devOnRender */ ;\n        }\n    }\n    emitLifecycleEvent(elm, \"componentDidRender\");\n    if (!(hostRef.$flags$ & 64 /* hasLoadedComponent */ )) {\n        hostRef.$flags$ |= 64 /* hasLoadedComponent */ ;\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssAnnotations) {\n            // DOM WRITE!\n            addHydratedFlag(elm);\n        }\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpDidLoad) {\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {\n                hostRef.$flags$ |= 2048 /* devOnDidLoad */ ;\n            }\n            safeCall(instance, \"componentDidLoad\");\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {\n                hostRef.$flags$ &= ~2048 /* devOnDidLoad */ ;\n            }\n        }\n        emitLifecycleEvent(elm, \"componentDidLoad\");\n        endPostUpdate();\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading) {\n            hostRef.$onReadyResolve$(elm);\n            if (!ancestorComponent) {\n                appDidLoad(tagName);\n            }\n        }\n    } else {\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpDidUpdate) {\n            // we've already loaded this component\n            // fire off the user's componentDidUpdate method (if one was provided)\n            // componentDidUpdate runs AFTER render() has been called\n            // and all child components have finished updating\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {\n                hostRef.$flags$ |= 1024 /* devOnRender */ ;\n            }\n            safeCall(instance, \"componentDidUpdate\");\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {\n                hostRef.$flags$ &= ~1024 /* devOnRender */ ;\n            }\n        }\n        emitLifecycleEvent(elm, \"componentDidUpdate\");\n        endPostUpdate();\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement) {\n        elm[\"s-hmr-load\"] && elm[\"s-hmr-load\"]();\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.method && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad) {\n        hostRef.$onInstanceResolve$(elm);\n    }\n    // load events fire from bottom to top\n    // the deepest elements load first then bubbles up\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading) {\n        if (hostRef.$onRenderResolve$) {\n            hostRef.$onRenderResolve$();\n            hostRef.$onRenderResolve$ = undefined;\n        }\n        if (hostRef.$flags$ & 512 /* needsRerender */ ) {\n            nextTick(()=>scheduleUpdate(hostRef, false));\n        }\n        hostRef.$flags$ &= ~(4 /* isWaitingForChildren */  | 512 /* needsRerender */ );\n    }\n// ( •_•)\n// ( •_•)>⌐■-■\n// (⌐■_■)\n};\nconst forceUpdate = (ref)=>{\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable) {\n        const hostRef = getHostRef(ref);\n        const isConnected = hostRef.$hostElement$.isConnected;\n        if (isConnected && (hostRef.$flags$ & (2 /* hasRendered */  | 16 /* isQueuedForUpdate */ )) === 2 /* hasRendered */ ) {\n            scheduleUpdate(hostRef, false);\n        }\n        // Returns \"true\" when the forced update was successfully scheduled\n        return isConnected;\n    }\n    return false;\n};\nconst appDidLoad = (who)=>{\n    // on appload\n    // we have finish the first big initial render\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssAnnotations) {\n        addHydratedFlag(doc.documentElement);\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncQueue) {\n        plt.$flags$ |= 2 /* appLoaded */ ;\n    }\n    nextTick(()=>emitEvent(win, \"appload\", {\n            detail: {\n                namespace: _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.NAMESPACE\n            }\n        }));\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile && performance.measure) {\n        performance.measure(`[Stencil] ${_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.NAMESPACE} initial load (by ${who})`, \"st:app:start\");\n    }\n};\nconst safeCall = (instance, method, arg)=>{\n    if (instance && instance[method]) {\n        try {\n            return instance[method](arg);\n        } catch (e) {\n            consoleError(e);\n        }\n    }\n    return undefined;\n};\nconst then = (promise, thenFn)=>{\n    return promise && promise.then ? promise.then(thenFn) : thenFn();\n};\nconst emitLifecycleEvent = (elm, lifecycleName)=>{\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lifecycleDOMEvents) {\n        emitEvent(elm, \"stencil_\" + lifecycleName, {\n            bubbles: true,\n            composed: true,\n            detail: {\n                namespace: _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.NAMESPACE\n            }\n        });\n    }\n};\nconst addHydratedFlag = (elm)=>_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydratedClass ? elm.classList.add(\"hydrated\") : _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydratedAttribute ? elm.setAttribute(\"hydrated\", \"\") : undefined;\nconst serverSideConnected = (elm)=>{\n    const children = elm.children;\n    if (children != null) {\n        for(let i = 0, ii = children.length; i < ii; i++){\n            const childElm = children[i];\n            if (typeof childElm.connectedCallback === \"function\") {\n                childElm.connectedCallback();\n            }\n            serverSideConnected(childElm);\n        }\n    }\n};\nconst initializeClientHydrate = (hostElm, tagName, hostId, hostRef)=>{\n    const endHydrate = createTime(\"hydrateClient\", tagName);\n    const shadowRoot = hostElm.shadowRoot;\n    const childRenderNodes = [];\n    const slotNodes = [];\n    const shadowRootNodes = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && shadowRoot ? [] : null;\n    const vnode = hostRef.$vnode$ = newVNode(tagName, null);\n    if (!plt.$orgLocNodes$) {\n        initializeDocumentHydrate(doc.body, plt.$orgLocNodes$ = new Map());\n    }\n    hostElm[HYDRATE_ID] = hostId;\n    hostElm.removeAttribute(HYDRATE_ID);\n    clientHydrate(vnode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, hostElm, hostId);\n    childRenderNodes.map((c)=>{\n        const orgLocationId = c.$hostId$ + \".\" + c.$nodeId$;\n        const orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);\n        const node = c.$elm$;\n        if (orgLocationNode && supportsShadow && orgLocationNode[\"s-en\"] === \"\") {\n            orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);\n        }\n        if (!shadowRoot) {\n            node[\"s-hn\"] = tagName;\n            if (orgLocationNode) {\n                node[\"s-ol\"] = orgLocationNode;\n                node[\"s-ol\"][\"s-nr\"] = node;\n            }\n        }\n        plt.$orgLocNodes$.delete(orgLocationId);\n    });\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && shadowRoot) {\n        shadowRootNodes.map((shadowRootNode)=>{\n            if (shadowRootNode) {\n                shadowRoot.appendChild(shadowRootNode);\n            }\n        });\n    }\n    endHydrate();\n};\nconst clientHydrate = (parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node, hostId)=>{\n    let childNodeType;\n    let childIdSplt;\n    let childVNode;\n    let i;\n    if (node.nodeType === 1 /* ElementNode */ ) {\n        childNodeType = node.getAttribute(HYDRATE_CHILD_ID);\n        if (childNodeType) {\n            // got the node data from the element's attribute\n            // `${hostId}.${nodeId}.${depth}.${index}`\n            childIdSplt = childNodeType.split(\".\");\n            if (childIdSplt[0] === hostId || childIdSplt[0] === \"0\") {\n                childVNode = {\n                    $flags$: 0,\n                    $hostId$: childIdSplt[0],\n                    $nodeId$: childIdSplt[1],\n                    $depth$: childIdSplt[2],\n                    $index$: childIdSplt[3],\n                    $tag$: node.tagName.toLowerCase(),\n                    $elm$: node,\n                    $attrs$: null,\n                    $children$: null,\n                    $key$: null,\n                    $name$: null,\n                    $text$: null\n                };\n                childRenderNodes.push(childVNode);\n                node.removeAttribute(HYDRATE_CHILD_ID);\n                // this is a new child vnode\n                // so ensure its parent vnode has the vchildren array\n                if (!parentVNode.$children$) {\n                    parentVNode.$children$ = [];\n                }\n                // add our child vnode to a specific index of the vnode's children\n                parentVNode.$children$[childVNode.$index$] = childVNode;\n                // this is now the new parent vnode for all the next child checks\n                parentVNode = childVNode;\n                if (shadowRootNodes && childVNode.$depth$ === \"0\") {\n                    shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                }\n            }\n        }\n        // recursively drill down, end to start so we can remove nodes\n        for(i = node.childNodes.length - 1; i >= 0; i--){\n            clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.childNodes[i], hostId);\n        }\n        if (node.shadowRoot) {\n            // keep drilling down through the shadow root nodes\n            for(i = node.shadowRoot.childNodes.length - 1; i >= 0; i--){\n                clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.shadowRoot.childNodes[i], hostId);\n            }\n        }\n    } else if (node.nodeType === 8 /* CommentNode */ ) {\n        // `${COMMENT_TYPE}.${hostId}.${nodeId}.${depth}.${index}`\n        childIdSplt = node.nodeValue.split(\".\");\n        if (childIdSplt[1] === hostId || childIdSplt[1] === \"0\") {\n            // comment node for either the host id or a 0 host id\n            childNodeType = childIdSplt[0];\n            childVNode = {\n                $flags$: 0,\n                $hostId$: childIdSplt[1],\n                $nodeId$: childIdSplt[2],\n                $depth$: childIdSplt[3],\n                $index$: childIdSplt[4],\n                $elm$: node,\n                $attrs$: null,\n                $children$: null,\n                $key$: null,\n                $name$: null,\n                $tag$: null,\n                $text$: null\n            };\n            if (childNodeType === TEXT_NODE_ID) {\n                childVNode.$elm$ = node.nextSibling;\n                if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3 /* TextNode */ ) {\n                    childVNode.$text$ = childVNode.$elm$.textContent;\n                    childRenderNodes.push(childVNode);\n                    // remove the text comment since it's no longer needed\n                    node.remove();\n                    if (!parentVNode.$children$) {\n                        parentVNode.$children$ = [];\n                    }\n                    parentVNode.$children$[childVNode.$index$] = childVNode;\n                    if (shadowRootNodes && childVNode.$depth$ === \"0\") {\n                        shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                    }\n                }\n            } else if (childVNode.$hostId$ === hostId) {\n                // this comment node is specifcally for this host id\n                if (childNodeType === SLOT_NODE_ID) {\n                    // `${SLOT_NODE_ID}.${hostId}.${nodeId}.${depth}.${index}.${slotName}`;\n                    childVNode.$tag$ = \"slot\";\n                    if (childIdSplt[5]) {\n                        node[\"s-sn\"] = childVNode.$name$ = childIdSplt[5];\n                    } else {\n                        node[\"s-sn\"] = \"\";\n                    }\n                    node[\"s-sr\"] = true;\n                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && shadowRootNodes) {\n                        // browser support shadowRoot and this is a shadow dom component\n                        // create an actual slot element\n                        childVNode.$elm$ = doc.createElement(childVNode.$tag$);\n                        if (childVNode.$name$) {\n                            // add the slot name attribute\n                            childVNode.$elm$.setAttribute(\"name\", childVNode.$name$);\n                        }\n                        // insert the new slot element before the slot comment\n                        node.parentNode.insertBefore(childVNode.$elm$, node);\n                        // remove the slot comment since it's not needed for shadow\n                        node.remove();\n                        if (childVNode.$depth$ === \"0\") {\n                            shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                        }\n                    }\n                    slotNodes.push(childVNode);\n                    if (!parentVNode.$children$) {\n                        parentVNode.$children$ = [];\n                    }\n                    parentVNode.$children$[childVNode.$index$] = childVNode;\n                } else if (childNodeType === CONTENT_REF_ID) {\n                    // `${CONTENT_REF_ID}.${hostId}`;\n                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && shadowRootNodes) {\n                        // remove the content ref comment since it's not needed for shadow\n                        node.remove();\n                    } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {\n                        hostElm[\"s-cr\"] = node;\n                        node[\"s-cn\"] = true;\n                    }\n                }\n            }\n        }\n    } else if (parentVNode && parentVNode.$tag$ === \"style\") {\n        const vnode = newVNode(null, node.textContent);\n        vnode.$elm$ = node;\n        vnode.$index$ = \"0\";\n        parentVNode.$children$ = [\n            vnode\n        ];\n    }\n};\nconst initializeDocumentHydrate = (node, orgLocNodes)=>{\n    if (node.nodeType === 1 /* ElementNode */ ) {\n        let i = 0;\n        for(; i < node.childNodes.length; i++){\n            initializeDocumentHydrate(node.childNodes[i], orgLocNodes);\n        }\n        if (node.shadowRoot) {\n            for(i = 0; i < node.shadowRoot.childNodes.length; i++){\n                initializeDocumentHydrate(node.shadowRoot.childNodes[i], orgLocNodes);\n            }\n        }\n    } else if (node.nodeType === 8 /* CommentNode */ ) {\n        const childIdSplt = node.nodeValue.split(\".\");\n        if (childIdSplt[0] === ORG_LOCATION_ID) {\n            orgLocNodes.set(childIdSplt[1] + \".\" + childIdSplt[2], node);\n            node.nodeValue = \"\";\n            // useful to know if the original location is\n            // the root light-dom of a shadow dom component\n            node[\"s-en\"] = childIdSplt[3];\n        }\n    }\n};\nconst parsePropertyValue = (propValue, propType)=>{\n    // ensure this value is of the correct prop type\n    if (propValue != null && !isComplexType(propValue)) {\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.propBoolean && propType & 4 /* Boolean */ ) {\n            // per the HTML spec, any string value means it is a boolean true value\n            // but we'll cheat here and say that the string \"false\" is the boolean false\n            return propValue === \"false\" ? false : propValue === \"\" || !!propValue;\n        }\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.propNumber && propType & 2 /* Number */ ) {\n            // force it to be a number\n            return parseFloat(propValue);\n        }\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.propString && propType & 1 /* String */ ) {\n            // could have been passed as a number or boolean\n            // but we still want it as a string\n            return String(propValue);\n        }\n        // redundant return here for better minification\n        return propValue;\n    }\n    // not sure exactly what type we want\n    // so no need to change to a different type\n    return propValue;\n};\nconst getValue = (ref, propName)=>getHostRef(ref).$instanceValues$.get(propName);\nconst setValue = (ref, propName, newVal, cmpMeta)=>{\n    // check our new property value against our internal value\n    const hostRef = getHostRef(ref);\n    const elm = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? hostRef.$hostElement$ : ref;\n    const oldVal = hostRef.$instanceValues$.get(propName);\n    const flags = hostRef.$flags$;\n    const instance = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);\n    if ((!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad || !(flags & 8 /* isConstructingInstance */ ) || oldVal === undefined) && newVal !== oldVal) {\n        // gadzooks! the property's value has changed!!\n        // set our new value!\n        hostRef.$instanceValues$.set(propName, newVal);\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {\n            if (hostRef.$flags$ & 1024 /* devOnRender */ ) {\n                consoleDevWarn(`The state/prop \"${propName}\" changed during rendering. This can potentially lead to infinite-loops and other bugs.`, \"\\nElement\", elm, \"\\nNew value\", newVal, \"\\nOld value\", oldVal);\n            } else if (hostRef.$flags$ & 2048 /* devOnDidLoad */ ) {\n                consoleDevWarn(`The state/prop \"${propName}\" changed during \"componentDidLoad()\", this triggers extra re-renders, try to setup on \"componentWillLoad()\"`, \"\\nElement\", elm, \"\\nNew value\", newVal, \"\\nOld value\", oldVal);\n            }\n        }\n        if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad || instance) {\n            // get an array of method names of watch functions to call\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback && cmpMeta.$watchers$ && flags & 128 /* isWatchReady */ ) {\n                const watchMethods = cmpMeta.$watchers$[propName];\n                if (watchMethods) {\n                    // this instance is watching for when this property changed\n                    watchMethods.map((watchMethodName)=>{\n                        try {\n                            // fire off each of the watch methods that are watching this property\n                            instance[watchMethodName](newVal, oldVal, propName);\n                        } catch (e) {\n                            consoleError(e, elm);\n                        }\n                    });\n                }\n            }\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable && (flags & (2 /* hasRendered */  | 16 /* isQueuedForUpdate */ )) === 2 /* hasRendered */ ) {\n                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpShouldUpdate && instance.componentShouldUpdate) {\n                    if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {\n                        return;\n                    }\n                }\n                // looks like this value actually changed, so we've got work to do!\n                // but only if we've already rendered, otherwise just chill out\n                // queue that we need to do an update, but don't worry about queuing\n                // up millions cuz this function ensures it only runs once\n                scheduleUpdate(hostRef, false);\n            }\n        }\n    }\n};\nconst proxyComponent = (Cstr, cmpMeta, flags)=>{\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member && cmpMeta.$members$) {\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback && Cstr.watchers) {\n            cmpMeta.$watchers$ = Cstr.watchers;\n        }\n        // It's better to have a const than two Object.entries()\n        const members = Object.entries(cmpMeta.$members$);\n        const prototype = Cstr.prototype;\n        members.map(([memberName, [memberFlags]])=>{\n            if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.prop || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.state) && (memberFlags & 31 /* Prop */  || (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad || flags & 2 /* proxyState */ ) && memberFlags & 32 /* State */ )) {\n                // proxyComponent - prop\n                Object.defineProperty(prototype, memberName, {\n                    get () {\n                        // proxyComponent, get value\n                        return getValue(this, memberName);\n                    },\n                    set (newValue) {\n                        // only during dev time\n                        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {\n                            const ref = getHostRef(this);\n                            if (// we are proxying the instance (not element)\n                            (flags & 1 /* isElementConstructor */ ) === 0 && // the element is not constructing\n                            (ref.$flags$ & 8 /* isConstructingInstance */ ) === 0 && // the member is a prop\n                            (memberFlags & 31 /* Prop */ ) !== 0 && // the member is not mutable\n                            (memberFlags & 1024 /* Mutable */ ) === 0) {\n                                consoleDevWarn(`@Prop() \"${memberName}\" on <${cmpMeta.$tagName$}> is immutable but was modified from within the component.\\nMore information: https://stenciljs.com/docs/properties#prop-mutability`);\n                            }\n                        }\n                        // proxyComponent, set value\n                        setValue(this, memberName, newValue, cmpMeta);\n                    },\n                    configurable: true,\n                    enumerable: true\n                });\n            } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.method && flags & 1 /* isElementConstructor */  && memberFlags & 64 /* Method */ ) {\n                // proxyComponent - method\n                Object.defineProperty(prototype, memberName, {\n                    value (...args) {\n                        const ref = getHostRef(this);\n                        return ref.$onInstancePromise$.then(()=>ref.$lazyInstance$[memberName](...args));\n                    }\n                });\n            }\n        });\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.observeAttribute && (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad || flags & 1 /* isElementConstructor */ )) {\n            const attrNameToPropName = new Map();\n            prototype.attributeChangedCallback = function(attrName, _oldValue, newValue) {\n                plt.jmp(()=>{\n                    const propName = attrNameToPropName.get(attrName);\n                    this[propName] = newValue === null && typeof this[propName] === \"boolean\" ? false : newValue;\n                });\n            };\n            // create an array of attributes to observe\n            // and also create a map of html attribute name to js property name\n            Cstr.observedAttributes = members.filter(([_, m])=>m[0] & 15 /* HasAttribute */ ) // filter to only keep props that should match attributes\n            .map(([propName, m])=>{\n                const attrName = m[1] || propName;\n                attrNameToPropName.set(attrName, propName);\n                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect && m[0] & 512 /* ReflectAttr */ ) {\n                    cmpMeta.$attrsToReflect$.push([\n                        propName,\n                        attrName\n                    ]);\n                }\n                return attrName;\n            });\n        }\n    }\n    return Cstr;\n};\nconst initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr)=>{\n    // initializeComponent\n    if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.style) && (hostRef.$flags$ & 32 /* hasInitializedComponent */ ) === 0) {\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide) {\n            // we haven't initialized this element yet\n            hostRef.$flags$ |= 32 /* hasInitializedComponent */ ;\n            // lazy loaded components\n            // request the component's implementation to be\n            // wired up with the host element\n            Cstr = loadModule(cmpMeta, hostRef, hmrVersionId);\n            if (Cstr.then) {\n                // Await creates a micro-task avoid if possible\n                const endLoad = uniqueTime(`st:load:${cmpMeta.$tagName$}:${hostRef.$modeName$}`, `[Stencil] Load module for <${cmpMeta.$tagName$}>`);\n                Cstr = await Cstr;\n                endLoad();\n            }\n            if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDebug) && !Cstr) {\n                throw new Error(`Constructor for \"${cmpMeta.$tagName$}#${hostRef.$modeName$}\" was not found`);\n            }\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member && !Cstr.isProxied) {\n                // we'eve never proxied this Constructor before\n                // let's add the getters/setters to its prototype before\n                // the first time we create an instance of the implementation\n                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback) {\n                    cmpMeta.$watchers$ = Cstr.watchers;\n                }\n                proxyComponent(Cstr, cmpMeta, 2 /* proxyState */ );\n                Cstr.isProxied = true;\n            }\n            const endNewInstance = createTime(\"createInstance\", cmpMeta.$tagName$);\n            // ok, time to construct the instance\n            // but let's keep track of when we start and stop\n            // so that the getters/setters don't incorrectly step on data\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member) {\n                hostRef.$flags$ |= 8 /* isConstructingInstance */ ;\n            }\n            // construct the lazy-loaded component implementation\n            // passing the hostRef is very important during\n            // construction in order to directly wire together the\n            // host element and the lazy-loaded instance\n            try {\n                new Cstr(hostRef);\n            } catch (e) {\n                consoleError(e);\n            }\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member) {\n                hostRef.$flags$ &= ~8 /* isConstructingInstance */ ;\n            }\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback) {\n                hostRef.$flags$ |= 128 /* isWatchReady */ ;\n            }\n            endNewInstance();\n            fireConnectedCallback(hostRef.$lazyInstance$);\n        } else {\n            // sync constructor component\n            Cstr = elm.constructor;\n            hostRef.$flags$ |= 128 /* isWatchReady */  | 32 /* hasInitializedComponent */ ;\n        }\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.style && Cstr.style) {\n            // this component has styles but we haven't registered them yet\n            let style = Cstr.style;\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.mode && typeof style !== \"string\") {\n                style = style[hostRef.$modeName$ = computeMode(elm)];\n                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide && hostRef.$modeName$) {\n                    elm.setAttribute(\"s-mode\", hostRef.$modeName$);\n                }\n            }\n            const scopeId = getScopeId(cmpMeta, hostRef.$modeName$);\n            if (!styles.has(scopeId)) {\n                const endRegisterStyles = createTime(\"registerStyles\", cmpMeta.$tagName$);\n                if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDomShim && cmpMeta.$flags$ & 8 /* needsShadowDomShim */ ) {\n                    style = await __webpack_require__.e(/*! import() */ \"vendor-chunks/@stencil+core@2.5.2\").then(__webpack_require__.bind(__webpack_require__, /*! ./shadow-css.js */ \"(ssr)/./node_modules/.pnpm/@stencil+core@2.5.2/node_modules/@stencil/core/internal/client/shadow-css.js\")).then((m)=>m.scopeCss(style, scopeId, false));\n                }\n                registerStyle(scopeId, style, !!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */ ));\n                endRegisterStyles();\n            }\n        }\n    }\n    // we've successfully created a lazy instance\n    const ancestorComponent = hostRef.$ancestorComponent$;\n    const schedule = ()=>scheduleUpdate(hostRef, true);\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading && ancestorComponent && ancestorComponent[\"s-rc\"]) {\n        // this is the intial load and this component it has an ancestor component\n        // but the ancestor component has NOT fired its will update lifecycle yet\n        // so let's just cool our jets and wait for the ancestor to continue first\n        // this will get fired off when the ancestor component\n        // finally gets around to rendering its lazy self\n        // fire off the initial update\n        ancestorComponent[\"s-rc\"].push(schedule);\n    } else {\n        schedule();\n    }\n};\nconst fireConnectedCallback = (instance)=>{\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.connectedCallback) {\n        safeCall(instance, \"connectedCallback\");\n    }\n};\nconst connectedCallback = (elm)=>{\n    if ((plt.$flags$ & 1 /* isTmpDisconnected */ ) === 0) {\n        const hostRef = getHostRef(elm);\n        const cmpMeta = hostRef.$cmpMeta$;\n        const endConnected = createTime(\"connectedCallback\", cmpMeta.$tagName$);\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetParent) {\n            // only run if we have listeners being attached to a parent\n            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, true);\n        }\n        if (!(hostRef.$flags$ & 1 /* hasConnected */ )) {\n            // first time this component has connected\n            hostRef.$flags$ |= 1 /* hasConnected */ ;\n            let hostId;\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide) {\n                hostId = elm.getAttribute(HYDRATE_ID);\n                if (hostId) {\n                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */ ) {\n                        const scopeId = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.mode ? addStyle(elm.shadowRoot, cmpMeta, elm.getAttribute(\"s-mode\")) : addStyle(elm.shadowRoot, cmpMeta);\n                        elm.classList.remove(scopeId + \"-h\", scopeId + \"-s\");\n                    }\n                    initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);\n                }\n            }\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && !hostId) {\n                // initUpdate\n                // if the slot polyfill is required we'll need to put some nodes\n                // in here to act as original content anchors as we move nodes around\n                // host element has been connected to the DOM\n                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide || (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slot || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom) && cmpMeta.$flags$ & (4 /* hasSlotRelocation */  | 8 /* needsShadowDomShim */ )) {\n                    setContentReference(elm);\n                }\n            }\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading) {\n                // find the first ancestor component (if there is one) and register\n                // this component as one of the actively loading child components for its ancestor\n                let ancestorComponent = elm;\n                while(ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host){\n                    // climb up the ancestors looking for the first\n                    // component that hasn't finished its lifecycle update yet\n                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide && ancestorComponent.nodeType === 1 /* ElementNode */  && ancestorComponent.hasAttribute(\"s-id\") && ancestorComponent[\"s-p\"] || ancestorComponent[\"s-p\"]) {\n                        // we found this components first ancestor component\n                        // keep a reference to this component's ancestor component\n                        attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);\n                        break;\n                    }\n                }\n            }\n            // Lazy properties\n            // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.prop && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad && !_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide && cmpMeta.$members$) {\n                Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]])=>{\n                    if (memberFlags & 31 /* Prop */  && elm.hasOwnProperty(memberName)) {\n                        const value = elm[memberName];\n                        delete elm[memberName];\n                        elm[memberName] = value;\n                    }\n                });\n            }\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.initializeNextTick) {\n                // connectedCallback, taskQueue, initialLoad\n                // angular sets attribute AFTER connectCallback\n                // https://github.com/angular/angular/issues/18909\n                // https://github.com/angular/angular/issues/19940\n                nextTick(()=>initializeComponent(elm, hostRef, cmpMeta));\n            } else {\n                initializeComponent(elm, hostRef, cmpMeta);\n            }\n        } else {\n            // not the first time this has connected\n            // reattach any event listeners to the host\n            // since they would have been removed when disconnected\n            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);\n            // fire off connectedCallback() on component instance\n            fireConnectedCallback(hostRef.$lazyInstance$);\n        }\n        endConnected();\n    }\n};\nconst setContentReference = (elm)=>{\n    // only required when we're NOT using native shadow dom (slot)\n    // or this browser doesn't support native shadow dom\n    // and this host element was NOT created with SSR\n    // let's pick out the inner content for slot projection\n    // create a node to represent where the original\n    // content was first placed, which is useful later on\n    const contentRefElm = elm[\"s-cr\"] = doc.createComment(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDebug ? `content-ref (host=${elm.localName})` : \"\");\n    contentRefElm[\"s-cn\"] = true;\n    elm.insertBefore(contentRefElm, elm.firstChild);\n};\nconst disconnectedCallback = (elm)=>{\n    if ((plt.$flags$ & 1 /* isTmpDisconnected */ ) === 0) {\n        const hostRef = getHostRef(elm);\n        const instance = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener) {\n            if (hostRef.$rmListeners$) {\n                hostRef.$rmListeners$.map((rmListener)=>rmListener());\n                hostRef.$rmListeners$ = undefined;\n            }\n        }\n        // clear CSS var-shim tracking\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssVarShim && plt.$cssShim$) {\n            plt.$cssShim$.removeHost(elm);\n        }\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.disconnectedCallback) {\n            safeCall(instance, \"disconnectedCallback\");\n        }\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpDidUnload) {\n            safeCall(instance, \"componentDidUnload\");\n        }\n    }\n};\nconst defineCustomElement = (Cstr, compactMeta)=>{\n    customElements.define(compactMeta[1], proxyCustomElement(Cstr, compactMeta));\n};\nconst proxyCustomElement = (Cstr, compactMeta)=>{\n    const cmpMeta = {\n        $flags$: compactMeta[0],\n        $tagName$: compactMeta[1]\n    };\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member) {\n        cmpMeta.$members$ = compactMeta[2];\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener) {\n        cmpMeta.$listeners$ = compactMeta[3];\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback) {\n        cmpMeta.$watchers$ = Cstr.$watchers$;\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect) {\n        cmpMeta.$attrsToReflect$ = [];\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */ ) {\n        cmpMeta.$flags$ |= 8 /* needsShadowDomShim */ ;\n    }\n    const originalConnectedCallback = Cstr.prototype.connectedCallback;\n    const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;\n    Object.assign(Cstr.prototype, {\n        __registerHost () {\n            registerHost(this, cmpMeta);\n        },\n        connectedCallback () {\n            connectedCallback(this);\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.connectedCallback && originalConnectedCallback) {\n                originalConnectedCallback.call(this);\n            }\n        },\n        disconnectedCallback () {\n            disconnectedCallback(this);\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.disconnectedCallback && originalDisconnectedCallback) {\n                originalDisconnectedCallback.call(this);\n            }\n        }\n    });\n    Cstr.is = cmpMeta.$tagName$;\n    return proxyComponent(Cstr, cmpMeta, 1 /* isElementConstructor */  | 2 /* proxyState */ );\n};\nconst forceModeUpdate = (elm)=>{\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.style && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.mode && !_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad) {\n        const mode = computeMode(elm);\n        const hostRef = getHostRef(elm);\n        if (hostRef.$modeName$ !== mode) {\n            const cmpMeta = hostRef.$cmpMeta$;\n            const oldScopeId = elm[\"s-sc\"];\n            const scopeId = getScopeId(cmpMeta, mode);\n            const style = elm.constructor.style[mode];\n            const flags = cmpMeta.$flags$;\n            if (style) {\n                if (!styles.has(scopeId)) {\n                    registerStyle(scopeId, style, !!(flags & 1 /* shadowDomEncapsulation */ ));\n                }\n                hostRef.$modeName$ = mode;\n                elm.classList.remove(oldScopeId + \"-h\", oldScopeId + \"-s\");\n                attachStyles(hostRef);\n                forceUpdate(elm);\n            }\n        }\n    }\n};\nconst attachShadow = (el)=>{\n    if (supportsShadow) {\n        el.attachShadow({\n            mode: \"open\"\n        });\n    } else {\n        el.shadowRoot = el;\n    }\n};\nconst hmrStart = (elm, cmpMeta, hmrVersionId)=>{\n    // ¯\\_(ツ)_/¯\n    const hostRef = getHostRef(elm);\n    // reset state flags to only have been connected\n    hostRef.$flags$ = 1 /* hasConnected */ ;\n    // TODO\n    // detatch any event listeners that may have been added\n    // because we're not passing an exact event name it'll\n    // remove all of this element's event, which is good\n    // create a callback for when this component finishes hmr\n    elm[\"s-hmr-load\"] = ()=>{\n        // finished hmr for this element\n        delete elm[\"s-hmr-load\"];\n    };\n    // re-initialize the component\n    initializeComponent(elm, hostRef, cmpMeta, hmrVersionId);\n};\nconst patchCloneNode = (HostElementPrototype)=>{\n    const orgCloneNode = HostElementPrototype.cloneNode;\n    HostElementPrototype.cloneNode = function(deep) {\n        const srcNode = this;\n        const isShadowDom = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom ? srcNode.shadowRoot && supportsShadow : false;\n        const clonedNode = orgCloneNode.call(srcNode, isShadowDom ? deep : false);\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slot && !isShadowDom && deep) {\n            let i = 0;\n            let slotted, nonStencilNode;\n            let stencilPrivates = [\n                \"s-id\",\n                \"s-cr\",\n                \"s-lr\",\n                \"s-rc\",\n                \"s-sc\",\n                \"s-p\",\n                \"s-cn\",\n                \"s-sr\",\n                \"s-sn\",\n                \"s-hn\",\n                \"s-ol\",\n                \"s-nr\",\n                \"s-si\"\n            ];\n            for(; i < srcNode.childNodes.length; i++){\n                slotted = srcNode.childNodes[i][\"s-nr\"];\n                nonStencilNode = stencilPrivates.every((privateField)=>!srcNode.childNodes[i][privateField]);\n                if (slotted) {\n                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.appendChildSlotFix && clonedNode.__appendChild) {\n                        clonedNode.__appendChild(slotted.cloneNode(true));\n                    } else {\n                        clonedNode.appendChild(slotted.cloneNode(true));\n                    }\n                }\n                if (nonStencilNode) {\n                    clonedNode.appendChild(srcNode.childNodes[i].cloneNode(true));\n                }\n            }\n        }\n        return clonedNode;\n    };\n};\nconst patchSlotAppendChild = (HostElementPrototype)=>{\n    HostElementPrototype.__appendChild = HostElementPrototype.appendChild;\n    HostElementPrototype.appendChild = function(newChild) {\n        const slotName = newChild[\"s-sn\"] = getSlotName(newChild);\n        const slotNode = getHostSlotNode(this.childNodes, slotName);\n        if (slotNode) {\n            const slotChildNodes = getHostSlotChildNodes(slotNode, slotName);\n            const appendAfter = slotChildNodes[slotChildNodes.length - 1];\n            return appendAfter.parentNode.insertBefore(newChild, appendAfter.nextSibling);\n        }\n        return this.__appendChild(newChild);\n    };\n};\nconst patchChildSlotNodes = (elm, cmpMeta)=>{\n    class FakeNodeList extends Array {\n        item(n) {\n            return this[n];\n        }\n    }\n    if (cmpMeta.$flags$ & 8 /* needsShadowDomShim */ ) {\n        const childNodesFn = elm.__lookupGetter__(\"childNodes\");\n        Object.defineProperty(elm, \"children\", {\n            get () {\n                return this.childNodes.map((n)=>n.nodeType === 1);\n            }\n        });\n        Object.defineProperty(elm, \"childElementCount\", {\n            get () {\n                return elm.children.length;\n            }\n        });\n        Object.defineProperty(elm, \"childNodes\", {\n            get () {\n                const childNodes = childNodesFn.call(this);\n                if ((plt.$flags$ & 1 /* isTmpDisconnected */ ) === 0 && getHostRef(this).$flags$ & 2 /* hasRendered */ ) {\n                    const result = new FakeNodeList();\n                    for(let i = 0; i < childNodes.length; i++){\n                        const slot = childNodes[i][\"s-nr\"];\n                        if (slot) {\n                            result.push(slot);\n                        }\n                    }\n                    return result;\n                }\n                return FakeNodeList.from(childNodes);\n            }\n        });\n    }\n};\nconst getSlotName = (node)=>node[\"s-sn\"] || node.nodeType === 1 && node.getAttribute(\"slot\") || \"\";\nconst getHostSlotNode = (childNodes, slotName)=>{\n    let i = 0;\n    let childNode;\n    for(; i < childNodes.length; i++){\n        childNode = childNodes[i];\n        if (childNode[\"s-sr\"] && childNode[\"s-sn\"] === slotName) {\n            return childNode;\n        }\n        childNode = getHostSlotNode(childNode.childNodes, slotName);\n        if (childNode) {\n            return childNode;\n        }\n    }\n    return null;\n};\nconst getHostSlotChildNodes = (n, slotName)=>{\n    const childNodes = [\n        n\n    ];\n    while((n = n.nextSibling) && n[\"s-sn\"] === slotName){\n        childNodes.push(n);\n    }\n    return childNodes;\n};\nconst bootstrapLazy = (lazyBundles, options = {})=>{\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile && performance.mark) {\n        performance.mark(\"st:app:start\");\n    }\n    installDevTools();\n    const endBootstrap = createTime(\"bootstrapLazy\");\n    const cmpTags = [];\n    const exclude = options.exclude || [];\n    const customElements1 = win.customElements;\n    const head = doc.head;\n    const metaCharset = /*@__PURE__*/ head.querySelector(\"meta[charset]\");\n    const visibilityStyle = /*@__PURE__*/ doc.createElement(\"style\");\n    const deferredConnectedCallbacks = [];\n    const styles = /*@__PURE__*/ doc.querySelectorAll(`[${HYDRATED_STYLE_ID}]`);\n    let appLoadFallback;\n    let isBootstrapping = true;\n    let i = 0;\n    Object.assign(plt, options);\n    plt.$resourcesUrl$ = new URL(options.resourcesUrl || \"./\", doc.baseURI).href;\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncQueue) {\n        if (options.syncQueue) {\n            plt.$flags$ |= 4 /* queueSync */ ;\n        }\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide) {\n        // If the app is already hydrated there is not point to disable the\n        // async queue. This will improve the first input delay\n        plt.$flags$ |= 2 /* appLoaded */ ;\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom) {\n        for(; i < styles.length; i++){\n            registerStyle(styles[i].getAttribute(HYDRATED_STYLE_ID), convertScopedToShadow(styles[i].innerHTML), true);\n        }\n    }\n    lazyBundles.map((lazyBundle)=>lazyBundle[1].map((compactMeta)=>{\n            const cmpMeta = {\n                $flags$: compactMeta[0],\n                $tagName$: compactMeta[1],\n                $members$: compactMeta[2],\n                $listeners$: compactMeta[3]\n            };\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member) {\n                cmpMeta.$members$ = compactMeta[2];\n            }\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener) {\n                cmpMeta.$listeners$ = compactMeta[3];\n            }\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect) {\n                cmpMeta.$attrsToReflect$ = [];\n            }\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback) {\n                cmpMeta.$watchers$ = {};\n            }\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */ ) {\n                cmpMeta.$flags$ |= 8 /* needsShadowDomShim */ ;\n            }\n            const tagName = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.transformTagName && options.transformTagName ? options.transformTagName(cmpMeta.$tagName$) : cmpMeta.$tagName$;\n            const HostElement = class extends HTMLElement {\n                // StencilLazyHost\n                constructor(self){\n                    // @ts-ignore\n                    super(self);\n                    self = this;\n                    registerHost(self, cmpMeta);\n                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */ ) {\n                        // this component is using shadow dom\n                        // and this browser supports shadow dom\n                        // add the read-only property \"shadowRoot\" to the host element\n                        // adding the shadow root build conditionals to minimize runtime\n                        if (supportsShadow) {\n                            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDelegatesFocus) {\n                                self.attachShadow({\n                                    mode: \"open\",\n                                    delegatesFocus: !!(cmpMeta.$flags$ & 16 /* shadowDelegatesFocus */ )\n                                });\n                            } else {\n                                self.attachShadow({\n                                    mode: \"open\"\n                                });\n                            }\n                        } else if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide && !(\"shadowRoot\" in self)) {\n                            self.shadowRoot = self;\n                        }\n                    }\n                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotChildNodesFix) {\n                        patchChildSlotNodes(self, cmpMeta);\n                    }\n                }\n                connectedCallback() {\n                    if (appLoadFallback) {\n                        clearTimeout(appLoadFallback);\n                        appLoadFallback = null;\n                    }\n                    if (isBootstrapping) {\n                        // connectedCallback will be processed once all components have been registered\n                        deferredConnectedCallbacks.push(this);\n                    } else {\n                        plt.jmp(()=>connectedCallback(this));\n                    }\n                }\n                disconnectedCallback() {\n                    plt.jmp(()=>disconnectedCallback(this));\n                }\n                componentOnReady() {\n                    return getHostRef(this).$onReadyPromise$;\n                }\n            };\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cloneNodeFix) {\n                patchCloneNode(HostElement.prototype);\n            }\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.appendChildSlotFix) {\n                patchSlotAppendChild(HostElement.prototype);\n            }\n            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement) {\n                HostElement.prototype[\"s-hmr\"] = function(hmrVersionId) {\n                    hmrStart(this, cmpMeta, hmrVersionId);\n                };\n            }\n            cmpMeta.$lazyBundleId$ = lazyBundle[0];\n            if (!exclude.includes(tagName) && !customElements1.get(tagName)) {\n                cmpTags.push(tagName);\n                customElements1.define(tagName, proxyComponent(HostElement, cmpMeta, 1 /* isElementConstructor */ ));\n            }\n        }));\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydratedClass || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydratedAttribute) {\n        visibilityStyle.innerHTML = cmpTags + HYDRATED_CSS;\n        visibilityStyle.setAttribute(\"data-styles\", \"\");\n        head.insertBefore(visibilityStyle, metaCharset ? metaCharset.nextSibling : head.firstChild);\n    }\n    // Process deferred connectedCallbacks now all components have been registered\n    isBootstrapping = false;\n    if (deferredConnectedCallbacks.length) {\n        deferredConnectedCallbacks.map((host)=>host.connectedCallback());\n    } else {\n        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile) {\n            plt.jmp(()=>appLoadFallback = setTimeout(appDidLoad, 30, \"timeout\"));\n        } else {\n            plt.jmp(()=>appLoadFallback = setTimeout(appDidLoad, 30));\n        }\n    }\n    // Fallback appLoad event\n    endBootstrap();\n};\nconst getAssetPath = (path)=>{\n    const assetUrl = new URL(path, plt.$resourcesUrl$);\n    return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;\n};\nconst setAssetPath = (path)=>plt.$resourcesUrl$ = path;\nconst getConnect = (_ref, tagName)=>{\n    const componentOnReady = ()=>{\n        let elm = doc.querySelector(tagName);\n        if (!elm) {\n            elm = doc.createElement(tagName);\n            doc.body.appendChild(elm);\n        }\n        return typeof elm.componentOnReady === \"function\" ? elm.componentOnReady() : Promise.resolve(elm);\n    };\n    const create = (...args)=>{\n        return componentOnReady().then((el)=>el.create(...args));\n    };\n    return {\n        create,\n        componentOnReady\n    };\n};\nconst getContext = (_elm, context)=>{\n    if (context in Context) {\n        return Context[context];\n    } else if (context === \"window\") {\n        return win;\n    } else if (context === \"document\") {\n        return doc;\n    } else if (context === \"isServer\" || context === \"isPrerender\") {\n        return _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide ? true : false;\n    } else if (context === \"isClient\") {\n        return _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide ? false : true;\n    } else if (context === \"resourcesUrl\" || context === \"publicPath\") {\n        return getAssetPath(\".\");\n    } else if (context === \"queue\") {\n        return {\n            write: writeTask,\n            read: readTask,\n            tick: {\n                then (cb) {\n                    return nextTick(cb);\n                }\n            }\n        };\n    }\n    return undefined;\n};\nconst insertVdomAnnotations = (doc, staticComponents)=>{\n    if (doc != null) {\n        const docData = {\n            hostIds: 0,\n            rootLevelIds: 0,\n            staticComponents: new Set(staticComponents)\n        };\n        const orgLocationNodes = [];\n        parseVNodeAnnotations(doc, doc.body, docData, orgLocationNodes);\n        orgLocationNodes.forEach((orgLocationNode)=>{\n            if (orgLocationNode != null) {\n                const nodeRef = orgLocationNode[\"s-nr\"];\n                let hostId = nodeRef[\"s-host-id\"];\n                let nodeId = nodeRef[\"s-node-id\"];\n                let childId = `${hostId}.${nodeId}`;\n                if (hostId == null) {\n                    hostId = 0;\n                    docData.rootLevelIds++;\n                    nodeId = docData.rootLevelIds;\n                    childId = `${hostId}.${nodeId}`;\n                    if (nodeRef.nodeType === 1 /* ElementNode */ ) {\n                        nodeRef.setAttribute(HYDRATE_CHILD_ID, childId);\n                    } else if (nodeRef.nodeType === 3 /* TextNode */ ) {\n                        if (hostId === 0) {\n                            const textContent = nodeRef.nodeValue.trim();\n                            if (textContent === \"\") {\n                                // useless whitespace node at the document root\n                                orgLocationNode.remove();\n                                return;\n                            }\n                        }\n                        const commentBeforeTextNode = doc.createComment(childId);\n                        commentBeforeTextNode.nodeValue = `${TEXT_NODE_ID}.${childId}`;\n                        nodeRef.parentNode.insertBefore(commentBeforeTextNode, nodeRef);\n                    }\n                }\n                let orgLocationNodeId = `${ORG_LOCATION_ID}.${childId}`;\n                const orgLocationParentNode = orgLocationNode.parentElement;\n                if (orgLocationParentNode) {\n                    if (orgLocationParentNode[\"s-en\"] === \"\") {\n                        // ending with a \".\" means that the parent element\n                        // of this node's original location is a SHADOW dom element\n                        // and this node is apart of the root level light dom\n                        orgLocationNodeId += `.`;\n                    } else if (orgLocationParentNode[\"s-en\"] === \"c\") {\n                        // ending with a \".c\" means that the parent element\n                        // of this node's original location is a SCOPED element\n                        // and this node is apart of the root level light dom\n                        orgLocationNodeId += `.c`;\n                    }\n                }\n                orgLocationNode.nodeValue = orgLocationNodeId;\n            }\n        });\n    }\n};\nconst parseVNodeAnnotations = (doc, node, docData, orgLocationNodes)=>{\n    if (node == null) {\n        return;\n    }\n    if (node[\"s-nr\"] != null) {\n        orgLocationNodes.push(node);\n    }\n    if (node.nodeType === 1 /* ElementNode */ ) {\n        node.childNodes.forEach((childNode)=>{\n            const hostRef = getHostRef(childNode);\n            if (hostRef != null && !docData.staticComponents.has(childNode.nodeName.toLowerCase())) {\n                const cmpData = {\n                    nodeIds: 0\n                };\n                insertVNodeAnnotations(doc, childNode, hostRef.$vnode$, docData, cmpData);\n            }\n            parseVNodeAnnotations(doc, childNode, docData, orgLocationNodes);\n        });\n    }\n};\nconst insertVNodeAnnotations = (doc, hostElm, vnode, docData, cmpData)=>{\n    if (vnode != null) {\n        const hostId = ++docData.hostIds;\n        hostElm.setAttribute(HYDRATE_ID, hostId);\n        if (hostElm[\"s-cr\"] != null) {\n            hostElm[\"s-cr\"].nodeValue = `${CONTENT_REF_ID}.${hostId}`;\n        }\n        if (vnode.$children$ != null) {\n            const depth = 0;\n            vnode.$children$.forEach((vnodeChild, index)=>{\n                insertChildVNodeAnnotations(doc, vnodeChild, cmpData, hostId, depth, index);\n            });\n        }\n        if (hostElm && vnode && vnode.$elm$ && !hostElm.hasAttribute(\"c-id\")) {\n            const parent = hostElm.parentElement;\n            if (parent && parent.childNodes) {\n                const parentChildNodes = Array.from(parent.childNodes);\n                const comment = parentChildNodes.find((node)=>node.nodeType === 8 /* CommentNode */  && node[\"s-sr\"]);\n                if (comment) {\n                    const index = parentChildNodes.indexOf(hostElm) - 1;\n                    vnode.$elm$.setAttribute(HYDRATE_CHILD_ID, `${comment[\"s-host-id\"]}.${comment[\"s-node-id\"]}.0.${index}`);\n                }\n            }\n        }\n    }\n};\nconst insertChildVNodeAnnotations = (doc, vnodeChild, cmpData, hostId, depth, index)=>{\n    const childElm = vnodeChild.$elm$;\n    if (childElm == null) {\n        return;\n    }\n    const nodeId = cmpData.nodeIds++;\n    const childId = `${hostId}.${nodeId}.${depth}.${index}`;\n    childElm[\"s-host-id\"] = hostId;\n    childElm[\"s-node-id\"] = nodeId;\n    if (childElm.nodeType === 1 /* ElementNode */ ) {\n        childElm.setAttribute(HYDRATE_CHILD_ID, childId);\n    } else if (childElm.nodeType === 3 /* TextNode */ ) {\n        const parentNode = childElm.parentNode;\n        const nodeName = parentNode.nodeName;\n        if (nodeName !== \"STYLE\" && nodeName !== \"SCRIPT\") {\n            const textNodeId = `${TEXT_NODE_ID}.${childId}`;\n            const commentBeforeTextNode = doc.createComment(textNodeId);\n            parentNode.insertBefore(commentBeforeTextNode, childElm);\n        }\n    } else if (childElm.nodeType === 8 /* CommentNode */ ) {\n        if (childElm[\"s-sr\"]) {\n            const slotName = childElm[\"s-sn\"] || \"\";\n            const slotNodeId = `${SLOT_NODE_ID}.${childId}.${slotName}`;\n            childElm.nodeValue = slotNodeId;\n        }\n    }\n    if (vnodeChild.$children$ != null) {\n        const childDepth = depth + 1;\n        vnodeChild.$children$.forEach((vnode, index)=>{\n            insertChildVNodeAnnotations(doc, vnode, cmpData, hostId, childDepth, index);\n        });\n    }\n};\nconst setPlatformOptions = (opts)=>Object.assign(plt, opts);\nconst Fragment = (_, children)=>children;\nconst hostRefs = new WeakMap();\nconst getHostRef = (ref)=>hostRefs.get(ref);\nconst registerInstance = (lazyInstance, hostRef)=>hostRefs.set(hostRef.$lazyInstance$ = lazyInstance, hostRef);\nconst registerHost = (elm, cmpMeta)=>{\n    const hostRef = {\n        $flags$: 0,\n        $hostElement$: elm,\n        $cmpMeta$: cmpMeta,\n        $instanceValues$: new Map()\n    };\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {\n        hostRef.$renderCount$ = 0;\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.method && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad) {\n        hostRef.$onInstancePromise$ = new Promise((r)=>hostRef.$onInstanceResolve$ = r);\n    }\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading) {\n        hostRef.$onReadyPromise$ = new Promise((r)=>hostRef.$onReadyResolve$ = r);\n        elm[\"s-p\"] = [];\n        elm[\"s-rc\"] = [];\n    }\n    addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);\n    return hostRefs.set(elm, hostRef);\n};\nconst isMemberInElement = (elm, memberName)=>memberName in elm;\nconst consoleError = (e, el)=>(customError || console.error)(e, el);\nconst STENCIL_DEV_MODE = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isTesting ? [\n    \"STENCIL:\"\n] // E2E testing\n : [\n    \"%cstencil\",\n    \"color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px\"\n];\nconst consoleDevError = (...m)=>console.error(...STENCIL_DEV_MODE, ...m);\nconst consoleDevWarn = (...m)=>console.warn(...STENCIL_DEV_MODE, ...m);\nconst consoleDevInfo = (...m)=>console.info(...STENCIL_DEV_MODE, ...m);\nconst setErrorHandler = (handler)=>customError = handler;\nconst cmpModules = /*@__PURE__*/ new Map();\nconst loadModule = (cmpMeta, hostRef, hmrVersionId)=>{\n    // loadModuleImport\n    const exportName = cmpMeta.$tagName$.replace(/-/g, \"_\");\n    const bundleId = cmpMeta.$lazyBundleId$;\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && typeof bundleId !== \"string\") {\n        consoleDevError(`Trying to lazily load component <${cmpMeta.$tagName$}> with style mode \"${hostRef.$modeName$}\", but it does not exist.`);\n        return undefined;\n    }\n    const module = !_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement ? cmpModules.get(bundleId) : false;\n    if (module) {\n        return module[exportName];\n    }\n    return __webpack_require__(\"(rsc)/./node_modules/.pnpm/@stencil+core@2.5.2/node_modules/@stencil/core/internal/client lazy recursive ^\\\\.\\\\/.*\\\\.entry\\\\.js.*$ include: \\\\.entry\\\\.js$ exclude: \\\\.system\\\\.entry\\\\.js$\")(`./${bundleId}.entry.js${_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement && hmrVersionId ? \"?s-hmr=\" + hmrVersionId : \"\"}`).then((importedModule)=>{\n        if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement) {\n            cmpModules.set(bundleId, importedModule);\n        }\n        return importedModule[exportName];\n    }, consoleError);\n};\nconst styles = new Map();\nconst modeResolutionChain = [];\nconst queueDomReads = [];\nconst queueDomWrites = [];\nconst queueDomWritesLow = [];\nconst queueTask = (queue, write)=>(cb)=>{\n        queue.push(cb);\n        if (!queuePending) {\n            queuePending = true;\n            if (write && plt.$flags$ & 4 /* queueSync */ ) {\n                nextTick(flush);\n            } else {\n                plt.raf(flush);\n            }\n        }\n    };\nconst consume = (queue)=>{\n    for(let i = 0; i < queue.length; i++){\n        try {\n            queue[i](performance.now());\n        } catch (e) {\n            consoleError(e);\n        }\n    }\n    queue.length = 0;\n};\nconst consumeTimeout = (queue, timeout)=>{\n    let i = 0;\n    let ts = 0;\n    while(i < queue.length && (ts = performance.now()) < timeout){\n        try {\n            queue[i++](ts);\n        } catch (e) {\n            consoleError(e);\n        }\n    }\n    if (i === queue.length) {\n        queue.length = 0;\n    } else if (i !== 0) {\n        queue.splice(0, i);\n    }\n};\nconst flush = ()=>{\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncQueue) {\n        queueCongestion++;\n    }\n    // always force a bunch of medium callbacks to run, but still have\n    // a throttle on how many can run in a certain time\n    // DOM READS!!!\n    consume(queueDomReads);\n    // DOM WRITES!!!\n    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncQueue) {\n        const timeout = (plt.$flags$ & 6 /* queueMask */ ) === 2 /* appLoaded */  ? performance.now() + 14 * Math.ceil(queueCongestion * (1.0 / 10.0)) : Infinity;\n        consumeTimeout(queueDomWrites, timeout);\n        consumeTimeout(queueDomWritesLow, timeout);\n        if (queueDomWrites.length > 0) {\n            queueDomWritesLow.push(...queueDomWrites);\n            queueDomWrites.length = 0;\n        }\n        if (queuePending = queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length > 0) {\n            // still more to do yet, but we've run out of time\n            // let's let this thing cool off and try again in the next tick\n            plt.raf(flush);\n        } else {\n            queueCongestion = 0;\n        }\n    } else {\n        consume(queueDomWrites);\n        if (queuePending = queueDomReads.length > 0) {\n            // still more to do yet, but we've run out of time\n            // let's let this thing cool off and try again in the next tick\n            plt.raf(flush);\n        }\n    }\n};\nconst nextTick = /*@__PURE__*/ (cb)=>promiseResolve().then(cb);\nconst readTask = /*@__PURE__*/ queueTask(queueDomReads, false);\nconst writeTask = /*@__PURE__*/ queueTask(queueDomWrites, true);\nconst Build = {\n    isDev: _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev ? true : false,\n    isBrowser: true,\n    isServer: false,\n    isTesting: _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isTesting ? true : false\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHN0ZW5jaWwrY29yZUAyLjUuMi9ub2RlX21vZHVsZXMvQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQTtBQUNKLElBQUlDO0FBQ0osSUFBSUM7QUFDSixJQUFJQztBQUNKLElBQUlDLElBQUk7QUFDUixJQUFJQyxxQkFBcUI7QUFDekIsSUFBSUMsOEJBQThCO0FBQ2xDLElBQUlDLG9CQUFvQjtBQUN4QixJQUFJQyxZQUFZO0FBQ2hCLElBQUlDLGVBQWU7QUFDbkIsSUFBSUMsa0JBQWtCO0FBQ3RCLElBQUlDLGVBQWU7QUFDbkI7O0NBRUMsR0FDa0U7QUFDbkUsTUFBTUcsTUFBTSxNQUFrQixHQUFjQyxDQUFNQSxHQUFHLENBQUM7QUFDdEQsTUFBTUMsTUFBTUosa0VBQUtBLENBQUNLLFVBQVUsR0FBR0gsSUFBSUUsR0FBRyxHQUFHO0FBQ3pDLE1BQU1FLE1BQU1KLElBQUlLLFFBQVEsSUFBSTtJQUFFQyxNQUFNLENBQUM7QUFBRTtBQUN2QyxNQUFNQyxJQUFLUCxJQUFJUSxXQUFXLElBQUk7QUFDOUI7QUFDQSxNQUFNQyxNQUFNO0lBQ1JDLFNBQVM7SUFDVEMsZ0JBQWdCO0lBQ2hCQyxLQUFLQyxDQUFBQSxJQUFLQTtJQUNWQyxLQUFLRCxDQUFBQSxJQUFLRSxzQkFBc0JGO0lBQ2hDRyxLQUFLLENBQUNDLElBQUlDLFdBQVdDLFVBQVVDLE9BQVNILEdBQUdJLGdCQUFnQixDQUFDSCxXQUFXQyxVQUFVQztJQUNqRkUsS0FBSyxDQUFDTCxJQUFJQyxXQUFXQyxVQUFVQyxPQUFTSCxHQUFHTSxtQkFBbUIsQ0FBQ0wsV0FBV0MsVUFBVUM7SUFDcEZJLElBQUksQ0FBQ04sV0FBV0UsT0FBUyxJQUFJSyxZQUFZUCxXQUFXRTtBQUN4RDtBQUNB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TSxHQUFHLEdBQUk7WUFDOUYsa0RBQWtEO1lBQ2xELCtEQUErRDtZQUMvRDFGLElBQUlLLEdBQUcsQ0FBQ2twQjtRQUNaLE9BQ0s7WUFDRHBxQixrQkFBa0I7UUFDdEI7SUFDSixPQUNLO1FBQ0RxcUIsUUFBUUw7UUFDUixJQUFLL3BCLGVBQWU4cEIsY0FBY3hqQixNQUFNLEdBQUcsR0FBSTtZQUMzQyxrREFBa0Q7WUFDbEQsK0RBQStEO1lBQy9EMUYsSUFBSUssR0FBRyxDQUFDa3BCO1FBQ1o7SUFDSjtBQUNKO0FBQ0EsTUFBTTFPLFdBQVcsV0FBVyxHQUFHLENBQUNsTSxLQUFPaE4saUJBQWlCMlgsSUFBSSxDQUFDM0s7QUFDN0QsTUFBTTBYLFdBQVcsV0FBVyxHQUFHZ0QsVUFBVUgsZUFBZTtBQUN4RCxNQUFNdFEsWUFBWSxXQUFXLEdBQUd5USxVQUFVRixnQkFBZ0I7QUFDMUQsTUFBTWMsUUFBUTtJQUNWcGQsT0FBT3hOLGtFQUFLQSxDQUFDd04sS0FBSyxHQUFHLE9BQU87SUFDNUJxZCxXQUFXO0lBQ1hDLFVBQVU7SUFDVjNCLFdBQVducEIsa0VBQUtBLENBQUNtcEIsU0FBUyxHQUFHLE9BQU87QUFDeEM7QUFDd0U7QUFDc3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2hhdGV2ZXIvLi9ub2RlX21vZHVsZXMvLnBucG0vQHN0ZW5jaWwrY29yZUAyLjUuMi9ub2RlX21vZHVsZXMvQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQvaW5kZXguanM/OWE5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgc2NvcGVJZDtcbmxldCBjb250ZW50UmVmO1xubGV0IGhvc3RUYWdOYW1lO1xubGV0IGN1c3RvbUVycm9yO1xubGV0IGkgPSAwO1xubGV0IHVzZU5hdGl2ZVNoYWRvd0RvbSA9IGZhbHNlO1xubGV0IGNoZWNrU2xvdEZhbGxiYWNrVmlzaWJpbGl0eSA9IGZhbHNlO1xubGV0IGNoZWNrU2xvdFJlbG9jYXRlID0gZmFsc2U7XG5sZXQgaXNTdmdNb2RlID0gZmFsc2U7XG5sZXQgcmVuZGVyaW5nUmVmID0gbnVsbDtcbmxldCBxdWV1ZUNvbmdlc3Rpb24gPSAwO1xubGV0IHF1ZXVlUGVuZGluZyA9IGZhbHNlO1xuLypcbiBTdGVuY2lsIENsaWVudCBQbGF0Zm9ybSB2Mi41LjIgfCBNSVQgTGljZW5zZWQgfCBodHRwczovL3N0ZW5jaWxqcy5jb21cbiAqL1xuaW1wb3J0IHsgQlVJTEQsIE5BTUVTUEFDRSB9IGZyb20gJ0BzdGVuY2lsL2NvcmUvaW50ZXJuYWwvYXBwLWRhdGEnO1xuY29uc3Qgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB7fTtcbmNvbnN0IENTUyA9IEJVSUxELmNzc1ZhclNoaW0gPyB3aW4uQ1NTIDogbnVsbDtcbmNvbnN0IGRvYyA9IHdpbi5kb2N1bWVudCB8fCB7IGhlYWQ6IHt9IH07XG5jb25zdCBIID0gKHdpbi5IVE1MRWxlbWVudCB8fCBjbGFzcyB7XG59KTtcbmNvbnN0IHBsdCA9IHtcbiAgICAkZmxhZ3MkOiAwLFxuICAgICRyZXNvdXJjZXNVcmwkOiAnJyxcbiAgICBqbXA6IGggPT4gaCgpLFxuICAgIHJhZjogaCA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaCksXG4gICAgYWVsOiAoZWwsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdHMpID0+IGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0cyksXG4gICAgcmVsOiAoZWwsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdHMpID0+IGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0cyksXG4gICAgY2U6IChldmVudE5hbWUsIG9wdHMpID0+IG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIG9wdHMpLFxufTtcbmNvbnN0IHN1cHBvcnRzU2hhZG93ID0gQlVJTEQuc2hhZG93RG9tU2hpbSAmJiBCVUlMRC5zaGFkb3dEb20gPyAvKkBfX1BVUkVfXyovICgoKSA9PiAoZG9jLmhlYWQuYXR0YWNoU2hhZG93ICsgJycpLmluZGV4T2YoJ1tuYXRpdmUnKSA+IC0xKSgpIDogdHJ1ZTtcbmNvbnN0IHN1cHBvcnRzTGlzdGVuZXJPcHRpb25zID0gLypAX19QVVJFX18qLyAoKCkgPT4ge1xuICAgIGxldCBzdXBwb3J0c0xpc3RlbmVyT3B0aW9ucyA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdlJywgbnVsbCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICBzdXBwb3J0c0xpc3RlbmVyT3B0aW9ucyA9IHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbiAgICByZXR1cm4gc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnM7XG59KSgpO1xuY29uc3QgcHJvbWlzZVJlc29sdmUgPSAodikgPT4gUHJvbWlzZS5yZXNvbHZlKHYpO1xuY29uc3Qgc3VwcG9ydHNDb25zdHJ1Y3RpYmxlU3R5bGVzaGVldHMgPSBCVUlMRC5jb25zdHJ1Y3RhYmxlQ1NTXG4gICAgPyAvKkBfX1BVUkVfXyovICgoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXcgQ1NTU3R5bGVTaGVldCgpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiAobmV3IENTU1N0eWxlU2hlZXQoKSkucmVwbGFjZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KSgpXG4gICAgOiBmYWxzZTtcbmNvbnN0IENvbnRleHQgPSB7fTtcbmNvbnN0IGFkZEhvc3RFdmVudExpc3RlbmVycyA9IChlbG0sIGhvc3RSZWYsIGxpc3RlbmVycywgYXR0YWNoUGFyZW50TGlzdGVuZXJzKSA9PiB7XG4gICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lciAmJiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgd2l0aGluIHRoZSBlbGVtZW50J3MgY29uc3RydWN0b3JcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBvdXIgZXZlbnQgbGlzdGVuZXJzIG9uIHRoZSBob3N0IGVsZW1lbnRcbiAgICAgICAgLy8gd2UgZG8gdGhpcyBub3cgc28gdGhhdCB3ZSBjYW4gbGlzdGVuIHRvIGV2ZW50cyB0aGF0IG1heVxuICAgICAgICAvLyBoYXZlIGZpcmVkIGV2ZW4gYmVmb3JlIHRoZSBpbnN0YW5jZSBpcyByZWFkeVxuICAgICAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyVGFyZ2V0UGFyZW50KSB7XG4gICAgICAgICAgICAvLyB0aGlzIGNvbXBvbmVudCBtYXkgaGF2ZSBldmVudCBsaXN0ZW5lcnMgdGhhdCBzaG91bGQgYmUgYXR0YWNoZWQgdG8gdGhlIHBhcmVudFxuICAgICAgICAgICAgaWYgKGF0dGFjaFBhcmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYmVpbmcgcmFuIGZyb20gd2l0aGluIHRoZSBjb25uZWN0ZWRDYWxsYmFja1xuICAgICAgICAgICAgICAgIC8vIHdoaWNoIGlzIGltcG9ydGFudCBzbyB0aGF0IHdlIGtub3cgdGhlIGhvc3QgZWxlbWVudCBhY3R1YWxseSBoYXMgYSBwYXJlbnQgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgdGhlIGxpc3RlbmVycyB0byBvbmx5IGhhdmUgdGhlIG9uZXMgdGhhdCBBUkUgYmVpbmcgYXR0YWNoZWQgdG8gdGhlIHBhcmVudFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoKFtmbGFnc10pID0+IGZsYWdzICYgMzIgLyogVGFyZ2V0UGFyZW50ICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYmVpbmcgcmFuIGZyb20gd2l0aGluIHRoZSBjb21wb25lbnQgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAvLyBldmVyeXRoaW5nIEJVVCB0aGUgcGFyZW50IGVsZW1lbnQgbGlzdGVuZXJzIHNob3VsZCBiZSBhdHRhY2hlZCBhdCB0aGlzIHRpbWVcbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IHRoZSBsaXN0ZW5lcnMgdGhhdCBhcmUgTk9UIGJlaW5nIGF0dGFjaGVkIHRvIHRoZSBwYXJlbnRcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKChbZmxhZ3NdKSA9PiAhKGZsYWdzICYgMzIgLyogVGFyZ2V0UGFyZW50ICovKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGlzdGVuZXJzLm1hcCgoW2ZsYWdzLCBuYW1lLCBtZXRob2RdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBCVUlMRC5ob3N0TGlzdGVuZXJUYXJnZXQgPyBnZXRIb3N0TGlzdGVuZXJUYXJnZXQoZWxtLCBmbGFncykgOiBlbG07XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gaG9zdExpc3RlbmVyUHJveHkoaG9zdFJlZiwgbWV0aG9kKTtcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBob3N0TGlzdGVuZXJPcHRzKGZsYWdzKTtcbiAgICAgICAgICAgIHBsdC5hZWwodGFyZ2V0LCBuYW1lLCBoYW5kbGVyLCBvcHRzKTtcbiAgICAgICAgICAgIChob3N0UmVmLiRybUxpc3RlbmVycyQgPSBob3N0UmVmLiRybUxpc3RlbmVycyQgfHwgW10pLnB1c2goKCkgPT4gcGx0LnJlbCh0YXJnZXQsIG5hbWUsIGhhbmRsZXIsIG9wdHMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IGhvc3RMaXN0ZW5lclByb3h5ID0gKGhvc3RSZWYsIG1ldGhvZE5hbWUpID0+IChldikgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChCVUlMRC5sYXp5TG9hZCkge1xuICAgICAgICAgICAgaWYgKGhvc3RSZWYuJGZsYWdzJCAmIDI1NiAvKiBpc0xpc3RlblJlYWR5ICovKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5zdGFuY2UgaXMgcmVhZHksIGxldCdzIGNhbGwgaXQncyBtZW1iZXIgbWV0aG9kIGZvciB0aGlzIGV2ZW50XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kbGF6eUluc3RhbmNlJFttZXRob2ROYW1lXShldik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAoaG9zdFJlZi4kcXVldWVkTGlzdGVuZXJzJCA9IGhvc3RSZWYuJHF1ZXVlZExpc3RlbmVycyQgfHwgW10pLnB1c2goW21ldGhvZE5hbWUsIGV2XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBob3N0UmVmLiRob3N0RWxlbWVudCRbbWV0aG9kTmFtZV0oZXYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGVFcnJvcihlKTtcbiAgICB9XG59O1xuY29uc3QgZ2V0SG9zdExpc3RlbmVyVGFyZ2V0ID0gKGVsbSwgZmxhZ3MpID0+IHtcbiAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyVGFyZ2V0RG9jdW1lbnQgJiYgZmxhZ3MgJiA0IC8qIFRhcmdldERvY3VtZW50ICovKVxuICAgICAgICByZXR1cm4gZG9jO1xuICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXJUYXJnZXRXaW5kb3cgJiYgZmxhZ3MgJiA4IC8qIFRhcmdldFdpbmRvdyAqLylcbiAgICAgICAgcmV0dXJuIHdpbjtcbiAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyVGFyZ2V0Qm9keSAmJiBmbGFncyAmIDE2IC8qIFRhcmdldEJvZHkgKi8pXG4gICAgICAgIHJldHVybiBkb2MuYm9keTtcbiAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyVGFyZ2V0UGFyZW50ICYmIGZsYWdzICYgMzIgLyogVGFyZ2V0UGFyZW50ICovKVxuICAgICAgICByZXR1cm4gZWxtLnBhcmVudEVsZW1lbnQ7XG4gICAgcmV0dXJuIGVsbTtcbn07XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IGhvc3RMaXN0ZW5lck9wdHMgPSAoZmxhZ3MpID0+IHN1cHBvcnRzTGlzdGVuZXJPcHRpb25zXG4gICAgPyAoe1xuICAgICAgICBwYXNzaXZlOiAoZmxhZ3MgJiAxIC8qIFBhc3NpdmUgKi8pICE9PSAwLFxuICAgICAgICBjYXB0dXJlOiAoZmxhZ3MgJiAyIC8qIENhcHR1cmUgKi8pICE9PSAwLFxuICAgIH0pXG4gICAgOiAoZmxhZ3MgJiAyIC8qIENhcHR1cmUgKi8pICE9PSAwO1xuY29uc3QgQ09OVEVOVF9SRUZfSUQgPSAncic7XG5jb25zdCBPUkdfTE9DQVRJT05fSUQgPSAnbyc7XG5jb25zdCBTTE9UX05PREVfSUQgPSAncyc7XG5jb25zdCBURVhUX05PREVfSUQgPSAndCc7XG5jb25zdCBIWURSQVRFX0lEID0gJ3MtaWQnO1xuY29uc3QgSFlEUkFURURfU1RZTEVfSUQgPSAnc3R5LWlkJztcbmNvbnN0IEhZRFJBVEVfQ0hJTERfSUQgPSAnYy1pZCc7XG5jb25zdCBIWURSQVRFRF9DU1MgPSAne3Zpc2liaWxpdHk6aGlkZGVufS5oeWRyYXRlZHt2aXNpYmlsaXR5OmluaGVyaXR9JztcbmNvbnN0IFhMSU5LX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuY29uc3QgY3JlYXRlVGltZSA9IChmbk5hbWUsIHRhZ05hbWUgPSAnJykgPT4ge1xuICAgIGlmIChCVUlMRC5wcm9maWxlICYmIHBlcmZvcm1hbmNlLm1hcmspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYHN0OiR7Zm5OYW1lfToke3RhZ05hbWV9OiR7aSsrfWA7XG4gICAgICAgIC8vIFN0YXJ0XG4gICAgICAgIHBlcmZvcm1hbmNlLm1hcmsoa2V5KTtcbiAgICAgICAgLy8gRW5kXG4gICAgICAgIHJldHVybiAoKSA9PiBwZXJmb3JtYW5jZS5tZWFzdXJlKGBbU3RlbmNpbF0gJHtmbk5hbWV9KCkgPCR7dGFnTmFtZX0+YCwga2V5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgfVxufTtcbmNvbnN0IHVuaXF1ZVRpbWUgPSAoa2V5LCBtZWFzdXJlVGV4dCkgPT4ge1xuICAgIGlmIChCVUlMRC5wcm9maWxlICYmIHBlcmZvcm1hbmNlLm1hcmspIHtcbiAgICAgICAgaWYgKHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUoa2V5KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlLm1hcmsoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUobWVhc3VyZVRleHQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUobWVhc3VyZVRleHQsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgIH1cbn07XG5jb25zdCBpbnNwZWN0ID0gKHJlZikgPT4ge1xuICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKHJlZik7XG4gICAgaWYgKCFob3N0UmVmKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGZsYWdzID0gaG9zdFJlZi4kZmxhZ3MkO1xuICAgIGNvbnN0IGhvc3RFbGVtZW50ID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlbmRlckNvdW50OiBob3N0UmVmLiRyZW5kZXJDb3VudCQsXG4gICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgICBoYXNSZW5kZXJlZDogISEoZmxhZ3MgJiAyIC8qIGhhc1JlbmRlcmVkICovKSxcbiAgICAgICAgICAgIGhhc0Nvbm5lY3RlZDogISEoZmxhZ3MgJiAxIC8qIGhhc0Nvbm5lY3RlZCAqLyksXG4gICAgICAgICAgICBpc1dhaXRpbmdGb3JDaGlsZHJlbjogISEoZmxhZ3MgJiA0IC8qIGlzV2FpdGluZ0ZvckNoaWxkcmVuICovKSxcbiAgICAgICAgICAgIGlzQ29uc3RydWN0aW5nSW5zdGFuY2U6ICEhKGZsYWdzICYgOCAvKiBpc0NvbnN0cnVjdGluZ0luc3RhbmNlICovKSxcbiAgICAgICAgICAgIGlzUXVldWVkRm9yVXBkYXRlOiAhIShmbGFncyAmIDE2IC8qIGlzUXVldWVkRm9yVXBkYXRlICovKSxcbiAgICAgICAgICAgIGhhc0luaXRpYWxpemVkQ29tcG9uZW50OiAhIShmbGFncyAmIDMyIC8qIGhhc0luaXRpYWxpemVkQ29tcG9uZW50ICovKSxcbiAgICAgICAgICAgIGhhc0xvYWRlZENvbXBvbmVudDogISEoZmxhZ3MgJiA2NCAvKiBoYXNMb2FkZWRDb21wb25lbnQgKi8pLFxuICAgICAgICAgICAgaXNXYXRjaFJlYWR5OiAhIShmbGFncyAmIDEyOCAvKiBpc1dhdGNoUmVhZHkgKi8pLFxuICAgICAgICAgICAgaXNMaXN0ZW5SZWFkeTogISEoZmxhZ3MgJiAyNTYgLyogaXNMaXN0ZW5SZWFkeSAqLyksXG4gICAgICAgICAgICBuZWVkc1JlcmVuZGVyOiAhIShmbGFncyAmIDUxMiAvKiBuZWVkc1JlcmVuZGVyICovKSxcbiAgICAgICAgfSxcbiAgICAgICAgaW5zdGFuY2VWYWx1ZXM6IGhvc3RSZWYuJGluc3RhbmNlVmFsdWVzJCxcbiAgICAgICAgYW5jZXN0b3JDb21wb25lbnQ6IGhvc3RSZWYuJGFuY2VzdG9yQ29tcG9uZW50JCxcbiAgICAgICAgaG9zdEVsZW1lbnQsXG4gICAgICAgIGxhenlJbnN0YW5jZTogaG9zdFJlZi4kbGF6eUluc3RhbmNlJCxcbiAgICAgICAgdm5vZGU6IGhvc3RSZWYuJHZub2RlJCxcbiAgICAgICAgbW9kZU5hbWU6IGhvc3RSZWYuJG1vZGVOYW1lJCxcbiAgICAgICAgb25SZWFkeVByb21pc2U6IGhvc3RSZWYuJG9uUmVhZHlQcm9taXNlJCxcbiAgICAgICAgb25SZWFkeVJlc29sdmU6IGhvc3RSZWYuJG9uUmVhZHlSZXNvbHZlJCxcbiAgICAgICAgb25JbnN0YW5jZVByb21pc2U6IGhvc3RSZWYuJG9uSW5zdGFuY2VQcm9taXNlJCxcbiAgICAgICAgb25JbnN0YW5jZVJlc29sdmU6IGhvc3RSZWYuJG9uSW5zdGFuY2VSZXNvbHZlJCxcbiAgICAgICAgb25SZW5kZXJSZXNvbHZlOiBob3N0UmVmLiRvblJlbmRlclJlc29sdmUkLFxuICAgICAgICBxdWV1ZWRMaXN0ZW5lcnM6IGhvc3RSZWYuJHF1ZXVlZExpc3RlbmVycyQsXG4gICAgICAgIHJtTGlzdGVuZXJzOiBob3N0UmVmLiRybUxpc3RlbmVycyQsXG4gICAgICAgIFsncy1pZCddOiBob3N0RWxlbWVudFsncy1pZCddLFxuICAgICAgICBbJ3MtY3InXTogaG9zdEVsZW1lbnRbJ3MtY3InXSxcbiAgICAgICAgWydzLWxyJ106IGhvc3RFbGVtZW50WydzLWxyJ10sXG4gICAgICAgIFsncy1wJ106IGhvc3RFbGVtZW50WydzLXAnXSxcbiAgICAgICAgWydzLXJjJ106IGhvc3RFbGVtZW50WydzLXJjJ10sXG4gICAgICAgIFsncy1zYyddOiBob3N0RWxlbWVudFsncy1zYyddLFxuICAgIH07XG59O1xuY29uc3QgaW5zdGFsbERldlRvb2xzID0gKCkgPT4ge1xuICAgIGlmIChCVUlMRC5kZXZUb29scykge1xuICAgICAgICBjb25zdCBzdGVuY2lsID0gKHdpbi5zdGVuY2lsID0gd2luLnN0ZW5jaWwgfHwge30pO1xuICAgICAgICBjb25zdCBvcmlnaW5hbEluc3BlY3QgPSBzdGVuY2lsLmluc3BlY3Q7XG4gICAgICAgIHN0ZW5jaWwuaW5zcGVjdCA9IChyZWYpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBpbnNwZWN0KHJlZik7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCAmJiB0eXBlb2Ygb3JpZ2luYWxJbnNwZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gb3JpZ2luYWxJbnNwZWN0KHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbn07XG5jb25zdCByb290QXBwbGllZFN0eWxlcyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCByZWdpc3RlclN0eWxlID0gKHNjb3BlSWQsIGNzc1RleHQsIGFsbG93Q1MpID0+IHtcbiAgICBsZXQgc3R5bGUgPSBzdHlsZXMuZ2V0KHNjb3BlSWQpO1xuICAgIGlmIChzdXBwb3J0c0NvbnN0cnVjdGlibGVTdHlsZXNoZWV0cyAmJiBhbGxvd0NTKSB7XG4gICAgICAgIHN0eWxlID0gKHN0eWxlIHx8IG5ldyBDU1NTdHlsZVNoZWV0KCkpO1xuICAgICAgICBzdHlsZS5yZXBsYWNlKGNzc1RleHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3R5bGUgPSBjc3NUZXh0O1xuICAgIH1cbiAgICBzdHlsZXMuc2V0KHNjb3BlSWQsIHN0eWxlKTtcbn07XG5jb25zdCBhZGRTdHlsZSA9IChzdHlsZUNvbnRhaW5lck5vZGUsIGNtcE1ldGEsIG1vZGUsIGhvc3RFbG0pID0+IHtcbiAgICBsZXQgc2NvcGVJZCA9IGdldFNjb3BlSWQoY21wTWV0YSwgbW9kZSk7XG4gICAgbGV0IHN0eWxlID0gc3R5bGVzLmdldChzY29wZUlkKTtcbiAgICBpZiAoIUJVSUxELmF0dGFjaFN0eWxlcykge1xuICAgICAgICByZXR1cm4gc2NvcGVJZDtcbiAgICB9XG4gICAgLy8gaWYgYW4gZWxlbWVudCBpcyBOT1QgY29ubmVjdGVkIHRoZW4gZ2V0Um9vdE5vZGUoKSB3aWxsIHJldHVybiB0aGUgd3Jvbmcgcm9vdCBub2RlXG4gICAgLy8gc28gdGhlIGZhbGxiYWNrIGlzIHRvIGFsd2F5cyB1c2UgdGhlIGRvY3VtZW50IGZvciB0aGUgcm9vdCBub2RlIGluIHRob3NlIGNhc2VzXG4gICAgc3R5bGVDb250YWluZXJOb2RlID0gc3R5bGVDb250YWluZXJOb2RlLm5vZGVUeXBlID09PSAxMSAvKiBEb2N1bWVudEZyYWdtZW50ICovID8gc3R5bGVDb250YWluZXJOb2RlIDogZG9jO1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgICBpZiAodHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc3R5bGVDb250YWluZXJOb2RlID0gc3R5bGVDb250YWluZXJOb2RlLmhlYWQgfHwgc3R5bGVDb250YWluZXJOb2RlO1xuICAgICAgICAgICAgbGV0IGFwcGxpZWRTdHlsZXMgPSByb290QXBwbGllZFN0eWxlcy5nZXQoc3R5bGVDb250YWluZXJOb2RlKTtcbiAgICAgICAgICAgIGxldCBzdHlsZUVsbTtcbiAgICAgICAgICAgIGlmICghYXBwbGllZFN0eWxlcykge1xuICAgICAgICAgICAgICAgIHJvb3RBcHBsaWVkU3R5bGVzLnNldChzdHlsZUNvbnRhaW5lck5vZGUsIChhcHBsaWVkU3R5bGVzID0gbmV3IFNldCgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFwcGxpZWRTdHlsZXMuaGFzKHNjb3BlSWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELmh5ZHJhdGVDbGllbnRTaWRlICYmIHN0eWxlQ29udGFpbmVyTm9kZS5ob3N0ICYmIChzdHlsZUVsbSA9IHN0eWxlQ29udGFpbmVyTm9kZS5xdWVyeVNlbGVjdG9yKGBbJHtIWURSQVRFRF9TVFlMRV9JRH09XCIke3Njb3BlSWR9XCJdYCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgb25seSBoYXBwZW5pbmcgb24gbmF0aXZlIHNoYWRvdy1kb20sIGRvIG5vdCBuZWVkcyBDU1MgdmFyIHNoaW1cbiAgICAgICAgICAgICAgICAgICAgc3R5bGVFbG0uaW5uZXJIVE1MID0gc3R5bGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuY3NzVmFyU2hpbSAmJiBwbHQuJGNzc1NoaW0kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUVsbSA9IHBsdC4kY3NzU2hpbSQuY3JlYXRlSG9zdFN0eWxlKGhvc3RFbG0sIHNjb3BlSWQsIHN0eWxlLCAhIShjbXBNZXRhLiRmbGFncyQgJiAxMCAvKiBuZWVkc1Njb3BlZEVuY2Fwc3VsYXRpb24gKi8pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Njb3BlSWQgPSBzdHlsZUVsbVsncy1zYyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1Njb3BlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZUlkID0gbmV3U2NvcGVJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIGFkZCB0aGlzIHN0eWxlSUQgdG8gdGhlIGFwcGxpZWRTdHlsZXMgU2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgdGhlIGNzc1ZhclNoaW0gbWlnaHQgbmVlZCB0byBhcHBseSBzZXZlcmFsIGRpZmZlcmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0eWxlc2hlZXRzIGZvciB0aGUgc2FtZSBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBsaWVkU3R5bGVzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlRWxtID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUVsbS5pbm5lckhUTUwgPSBzdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgfHwgQlVJTEQuaG90TW9kdWxlUmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlRWxtLnNldEF0dHJpYnV0ZShIWURSQVRFRF9TVFlMRV9JRCwgc2NvcGVJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3R5bGVDb250YWluZXJOb2RlLmluc2VydEJlZm9yZShzdHlsZUVsbSwgc3R5bGVDb250YWluZXJOb2RlLnF1ZXJ5U2VsZWN0b3IoJ2xpbmsnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhcHBsaWVkU3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGxpZWRTdHlsZXMuYWRkKHNjb3BlSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCVUlMRC5jb25zdHJ1Y3RhYmxlQ1NTICYmICFzdHlsZUNvbnRhaW5lck5vZGUuYWRvcHRlZFN0eWxlU2hlZXRzLmluY2x1ZGVzKHN0eWxlKSkge1xuICAgICAgICAgICAgc3R5bGVDb250YWluZXJOb2RlLmFkb3B0ZWRTdHlsZVNoZWV0cyA9IFsuLi5zdHlsZUNvbnRhaW5lck5vZGUuYWRvcHRlZFN0eWxlU2hlZXRzLCBzdHlsZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlSWQ7XG59O1xuY29uc3QgYXR0YWNoU3R5bGVzID0gKGhvc3RSZWYpID0+IHtcbiAgICBjb25zdCBjbXBNZXRhID0gaG9zdFJlZi4kY21wTWV0YSQ7XG4gICAgY29uc3QgZWxtID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkO1xuICAgIGNvbnN0IGZsYWdzID0gY21wTWV0YS4kZmxhZ3MkO1xuICAgIGNvbnN0IGVuZEF0dGFjaFN0eWxlcyA9IGNyZWF0ZVRpbWUoJ2F0dGFjaFN0eWxlcycsIGNtcE1ldGEuJHRhZ05hbWUkKTtcbiAgICBjb25zdCBzY29wZUlkID0gYWRkU3R5bGUoQlVJTEQuc2hhZG93RG9tICYmIHN1cHBvcnRzU2hhZG93ICYmIGVsbS5zaGFkb3dSb290ID8gZWxtLnNoYWRvd1Jvb3QgOiBlbG0uZ2V0Um9vdE5vZGUoKSwgY21wTWV0YSwgaG9zdFJlZi4kbW9kZU5hbWUkLCBlbG0pO1xuICAgIGlmICgoQlVJTEQuc2hhZG93RG9tIHx8IEJVSUxELnNjb3BlZCkgJiYgQlVJTEQuY3NzQW5ub3RhdGlvbnMgJiYgZmxhZ3MgJiAxMCAvKiBuZWVkc1Njb3BlZEVuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgLy8gb25seSByZXF1aXJlZCB3aGVuIHdlJ3JlIE5PVCB1c2luZyBuYXRpdmUgc2hhZG93IGRvbSAoc2xvdClcbiAgICAgICAgLy8gb3IgdGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBuYXRpdmUgc2hhZG93IGRvbVxuICAgICAgICAvLyBhbmQgdGhpcyBob3N0IGVsZW1lbnQgd2FzIE5PVCBjcmVhdGVkIHdpdGggU1NSXG4gICAgICAgIC8vIGxldCdzIHBpY2sgb3V0IHRoZSBpbm5lciBjb250ZW50IGZvciBzbG90IHByb2plY3Rpb25cbiAgICAgICAgLy8gY3JlYXRlIGEgbm9kZSB0byByZXByZXNlbnQgd2hlcmUgdGhlIG9yaWdpbmFsXG4gICAgICAgIC8vIGNvbnRlbnQgd2FzIGZpcnN0IHBsYWNlZCwgd2hpY2ggaXMgdXNlZnVsIGxhdGVyIG9uXG4gICAgICAgIC8vIERPTSBXUklURSEhXG4gICAgICAgIGVsbVsncy1zYyddID0gc2NvcGVJZDtcbiAgICAgICAgZWxtLmNsYXNzTGlzdC5hZGQoc2NvcGVJZCArICctaCcpO1xuICAgICAgICBpZiAoQlVJTEQuc2NvcGVkICYmIGZsYWdzICYgMiAvKiBzY29wZWRDc3NFbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgICAgICBlbG0uY2xhc3NMaXN0LmFkZChzY29wZUlkICsgJy1zJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5kQXR0YWNoU3R5bGVzKCk7XG59O1xuY29uc3QgZ2V0U2NvcGVJZCA9IChjbXAsIG1vZGUpID0+ICdzYy0nICsgKEJVSUxELm1vZGUgJiYgbW9kZSAmJiBjbXAuJGZsYWdzJCAmIDMyIC8qIGhhc01vZGUgKi8gPyBjbXAuJHRhZ05hbWUkICsgJy0nICsgbW9kZSA6IGNtcC4kdGFnTmFtZSQpO1xuY29uc3QgY29udmVydFNjb3BlZFRvU2hhZG93ID0gKGNzcykgPT4gY3NzLnJlcGxhY2UoL1xcL1xcKiFAKFteXFwvXSspXFwqXFwvW15cXHtdK1xcey9nLCAnJDF7Jyk7XG4vLyBQcml2YXRlXG5jb25zdCBjb21wdXRlTW9kZSA9IChlbG0pID0+IG1vZGVSZXNvbHV0aW9uQ2hhaW4ubWFwKGggPT4gaChlbG0pKS5maW5kKG0gPT4gISFtKTtcbi8vIFB1YmxpY1xuY29uc3Qgc2V0TW9kZSA9IChoYW5kbGVyKSA9PiBtb2RlUmVzb2x1dGlvbkNoYWluLnB1c2goaGFuZGxlcik7XG5jb25zdCBnZXRNb2RlID0gKHJlZikgPT4gZ2V0SG9zdFJlZihyZWYpLiRtb2RlTmFtZSQ7XG4vKipcbiAqIERlZmF1bHQgc3R5bGUgbW9kZSBpZFxuICovXG4vKipcbiAqIFJldXNhYmxlIGVtcHR5IG9iai9hcnJheVxuICogRG9uJ3QgYWRkIHZhbHVlcyB0byB0aGVzZSEhXG4gKi9cbmNvbnN0IEVNUFRZX09CSiA9IHt9O1xuLyoqXG4gKiBOYW1lc3BhY2VzXG4gKi9cbmNvbnN0IFNWR19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5jb25zdCBIVE1MX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xuY29uc3QgaXNEZWYgPSAodikgPT4gdiAhPSBudWxsO1xuY29uc3QgaXNDb21wbGV4VHlwZSA9IChvKSA9PiB7XG4gICAgLy8gaHR0cHM6Ly9qc3BlcmYuY29tL3R5cGVvZi1mbi1vYmplY3QvNVxuICAgIG8gPSB0eXBlb2YgbztcbiAgICByZXR1cm4gbyA9PT0gJ29iamVjdCcgfHwgbyA9PT0gJ2Z1bmN0aW9uJztcbn07XG4vKipcbiAqIFByb2R1Y3Rpb24gaCgpIGZ1bmN0aW9uIGJhc2VkIG9uIFByZWFjdCBieVxuICogSmFzb24gTWlsbGVyIChAZGV2ZWxvcGl0KVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L3ByZWFjdC9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogTW9kaWZpZWQgZm9yIFN0ZW5jaWwncyBjb21waWxlciBhbmQgdmRvbVxuICovXG4vLyBjb25zdCBzdGFjazogYW55W10gPSBbXTtcbi8vIGV4cG9ydCBmdW5jdGlvbiBoKG5vZGVOYW1lOiBzdHJpbmcgfCBkLkZ1bmN0aW9uYWxDb21wb25lbnQsIHZub2RlRGF0YTogZC5Qcm9wc1R5cGUsIGNoaWxkPzogZC5DaGlsZFR5cGUpOiBkLlZOb2RlO1xuLy8gZXhwb3J0IGZ1bmN0aW9uIGgobm9kZU5hbWU6IHN0cmluZyB8IGQuRnVuY3Rpb25hbENvbXBvbmVudCwgdm5vZGVEYXRhOiBkLlByb3BzVHlwZSwgLi4uY2hpbGRyZW46IGQuQ2hpbGRUeXBlW10pOiBkLlZOb2RlO1xuY29uc3QgaCA9IChub2RlTmFtZSwgdm5vZGVEYXRhLCAuLi5jaGlsZHJlbikgPT4ge1xuICAgIGxldCBjaGlsZCA9IG51bGw7XG4gICAgbGV0IGtleSA9IG51bGw7XG4gICAgbGV0IHNsb3ROYW1lID0gbnVsbDtcbiAgICBsZXQgc2ltcGxlID0gZmFsc2U7XG4gICAgbGV0IGxhc3RTaW1wbGUgPSBmYWxzZTtcbiAgICBsZXQgdk5vZGVDaGlsZHJlbiA9IFtdO1xuICAgIGNvbnN0IHdhbGsgPSAoYykgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gY1tpXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkKSkge1xuICAgICAgICAgICAgICAgIHdhbGsoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQgIT0gbnVsbCAmJiB0eXBlb2YgY2hpbGQgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGlmICgoc2ltcGxlID0gdHlwZW9mIG5vZGVOYW1lICE9PSAnZnVuY3Rpb24nICYmICFpc0NvbXBsZXhUeXBlKGNoaWxkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBTdHJpbmcoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChCVUlMRC5pc0RldiAmJiB0eXBlb2Ygbm9kZU5hbWUgIT09ICdmdW5jdGlvbicgJiYgY2hpbGQuJGZsYWdzJCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGVEZXZFcnJvcihgdk5vZGUgcGFzc2VkIGFzIGNoaWxkcmVuIGhhcyB1bmV4cGVjdGVkIHR5cGUuXG5NYWtlIHN1cmUgaXQncyB1c2luZyB0aGUgY29ycmVjdCBoKCkgZnVuY3Rpb24uXG5FbXB0eSBvYmplY3RzIGNhbiBhbHNvIGJlIHRoZSBjYXVzZSwgbG9vayBmb3IgSlNYIGNvbW1lbnRzIHRoYXQgYmVjYW1lIG9iamVjdHMuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaW1wbGUgJiYgbGFzdFNpbXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgY2hpbGQgd2FzIHNpbXBsZSAoc3RyaW5nKSwgd2UgbWVyZ2UgYm90aFxuICAgICAgICAgICAgICAgICAgICB2Tm9kZUNoaWxkcmVuW3ZOb2RlQ2hpbGRyZW4ubGVuZ3RoIC0gMV0uJHRleHQkICs9IGNoaWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIGEgbmV3IHZOb2RlLCBpZiBpdCdzIHRleHQsIHdlIGNyZWF0ZSBhIHRleHQgdk5vZGVcbiAgICAgICAgICAgICAgICAgICAgdk5vZGVDaGlsZHJlbi5wdXNoKHNpbXBsZSA/IG5ld1ZOb2RlKG51bGwsIGNoaWxkKSA6IGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdFNpbXBsZSA9IHNpbXBsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgd2FsayhjaGlsZHJlbik7XG4gICAgaWYgKHZub2RlRGF0YSkge1xuICAgICAgICBpZiAoQlVJTEQuaXNEZXYgJiYgbm9kZU5hbWUgPT09ICdpbnB1dCcpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlSW5wdXRQcm9wZXJ0aWVzKHZub2RlRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm9ybWFsaXplIGNsYXNzIC8gY2xhc3NuYW1lIGF0dHJpYnV0ZXNcbiAgICAgICAgaWYgKEJVSUxELnZkb21LZXkgJiYgdm5vZGVEYXRhLmtleSkge1xuICAgICAgICAgICAga2V5ID0gdm5vZGVEYXRhLmtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgdm5vZGVEYXRhLm5hbWUpIHtcbiAgICAgICAgICAgIHNsb3ROYW1lID0gdm5vZGVEYXRhLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELnZkb21DbGFzcykge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NEYXRhID0gdm5vZGVEYXRhLmNsYXNzTmFtZSB8fCB2bm9kZURhdGEuY2xhc3M7XG4gICAgICAgICAgICBpZiAoY2xhc3NEYXRhKSB7XG4gICAgICAgICAgICAgICAgdm5vZGVEYXRhLmNsYXNzID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGNsYXNzRGF0YSAhPT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY2xhc3NEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE9iamVjdC5rZXlzKGNsYXNzRGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGsgPT4gY2xhc3NEYXRhW2tdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcgJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKEJVSUxELmlzRGV2ICYmIHZOb2RlQ2hpbGRyZW4uc29tZShpc0hvc3QpKSB7XG4gICAgICAgIGNvbnNvbGVEZXZFcnJvcihgVGhlIDxIb3N0PiBtdXN0IGJlIHRoZSBzaW5nbGUgcm9vdCBjb21wb25lbnQuIE1ha2Ugc3VyZTpcbi0gWW91IGFyZSBOT1QgdXNpbmcgaG9zdERhdGEoKSBhbmQgPEhvc3Q+IGluIHRoZSBzYW1lIGNvbXBvbmVudC5cbi0gPEhvc3Q+IGlzIHVzZWQgb25jZSwgYW5kIGl0J3MgdGhlIHNpbmdsZSByb290IGNvbXBvbmVudCBvZiB0aGUgcmVuZGVyKCkgZnVuY3Rpb24uYCk7XG4gICAgfVxuICAgIGlmIChCVUlMRC52ZG9tRnVuY3Rpb25hbCAmJiB0eXBlb2Ygbm9kZU5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm9kZU5hbWUgaXMgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICAgICAgICByZXR1cm4gbm9kZU5hbWUodm5vZGVEYXRhID09PSBudWxsID8ge30gOiB2bm9kZURhdGEsIHZOb2RlQ2hpbGRyZW4sIHZkb21GblV0aWxzKTtcbiAgICB9XG4gICAgY29uc3Qgdm5vZGUgPSBuZXdWTm9kZShub2RlTmFtZSwgbnVsbCk7XG4gICAgdm5vZGUuJGF0dHJzJCA9IHZub2RlRGF0YTtcbiAgICBpZiAodk5vZGVDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZub2RlLiRjaGlsZHJlbiQgPSB2Tm9kZUNoaWxkcmVuO1xuICAgIH1cbiAgICBpZiAoQlVJTEQudmRvbUtleSkge1xuICAgICAgICB2bm9kZS4ka2V5JCA9IGtleTtcbiAgICB9XG4gICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uKSB7XG4gICAgICAgIHZub2RlLiRuYW1lJCA9IHNsb3ROYW1lO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGU7XG59O1xuY29uc3QgbmV3Vk5vZGUgPSAodGFnLCB0ZXh0KSA9PiB7XG4gICAgY29uc3Qgdm5vZGUgPSB7XG4gICAgICAgICRmbGFncyQ6IDAsXG4gICAgICAgICR0YWckOiB0YWcsXG4gICAgICAgICR0ZXh0JDogdGV4dCxcbiAgICAgICAgJGVsbSQ6IG51bGwsXG4gICAgICAgICRjaGlsZHJlbiQ6IG51bGwsXG4gICAgfTtcbiAgICBpZiAoQlVJTEQudmRvbUF0dHJpYnV0ZSkge1xuICAgICAgICB2bm9kZS4kYXR0cnMkID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKEJVSUxELnZkb21LZXkpIHtcbiAgICAgICAgdm5vZGUuJGtleSQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24pIHtcbiAgICAgICAgdm5vZGUuJG5hbWUkID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlO1xufTtcbmNvbnN0IEhvc3QgPSB7fTtcbmNvbnN0IGlzSG9zdCA9IChub2RlKSA9PiBub2RlICYmIG5vZGUuJHRhZyQgPT09IEhvc3Q7XG5jb25zdCB2ZG9tRm5VdGlscyA9IHtcbiAgICBmb3JFYWNoOiAoY2hpbGRyZW4sIGNiKSA9PiBjaGlsZHJlbi5tYXAoY29udmVydFRvUHVibGljKS5mb3JFYWNoKGNiKSxcbiAgICBtYXA6IChjaGlsZHJlbiwgY2IpID0+IGNoaWxkcmVuLm1hcChjb252ZXJ0VG9QdWJsaWMpLm1hcChjYikubWFwKGNvbnZlcnRUb1ByaXZhdGUpLFxufTtcbmNvbnN0IGNvbnZlcnRUb1B1YmxpYyA9IChub2RlKSA9PiAoe1xuICAgIHZhdHRyczogbm9kZS4kYXR0cnMkLFxuICAgIHZjaGlsZHJlbjogbm9kZS4kY2hpbGRyZW4kLFxuICAgIHZrZXk6IG5vZGUuJGtleSQsXG4gICAgdm5hbWU6IG5vZGUuJG5hbWUkLFxuICAgIHZ0YWc6IG5vZGUuJHRhZyQsXG4gICAgdnRleHQ6IG5vZGUuJHRleHQkLFxufSk7XG5jb25zdCBjb252ZXJ0VG9Qcml2YXRlID0gKG5vZGUpID0+IHtcbiAgICBpZiAodHlwZW9mIG5vZGUudnRhZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCB2bm9kZURhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBub2RlLnZhdHRycyk7XG4gICAgICAgIGlmIChub2RlLnZrZXkpIHtcbiAgICAgICAgICAgIHZub2RlRGF0YS5rZXkgPSBub2RlLnZrZXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUudm5hbWUpIHtcbiAgICAgICAgICAgIHZub2RlRGF0YS5uYW1lID0gbm9kZS52bmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaChub2RlLnZ0YWcsIHZub2RlRGF0YSwgLi4uKG5vZGUudmNoaWxkcmVuIHx8IFtdKSk7XG4gICAgfVxuICAgIGNvbnN0IHZub2RlID0gbmV3Vk5vZGUobm9kZS52dGFnLCBub2RlLnZ0ZXh0KTtcbiAgICB2bm9kZS4kYXR0cnMkID0gbm9kZS52YXR0cnM7XG4gICAgdm5vZGUuJGNoaWxkcmVuJCA9IG5vZGUudmNoaWxkcmVuO1xuICAgIHZub2RlLiRrZXkkID0gbm9kZS52a2V5O1xuICAgIHZub2RlLiRuYW1lJCA9IG5vZGUudm5hbWU7XG4gICAgcmV0dXJuIHZub2RlO1xufTtcbmNvbnN0IHZhbGlkYXRlSW5wdXRQcm9wZXJ0aWVzID0gKHZub2RlRGF0YSkgPT4ge1xuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXModm5vZGVEYXRhKTtcbiAgICBjb25zdCB0eXBlSW5kZXggPSBwcm9wcy5pbmRleE9mKCd0eXBlJyk7XG4gICAgY29uc3QgbWluSW5kZXggPSBwcm9wcy5pbmRleE9mKCdtaW4nKTtcbiAgICBjb25zdCBtYXhJbmRleCA9IHByb3BzLmluZGV4T2YoJ21heCcpO1xuICAgIGNvbnN0IHN0ZXBJbmRleCA9IHByb3BzLmluZGV4T2YoJ21pbicpO1xuICAgIGNvbnN0IHZhbHVlID0gcHJvcHMuaW5kZXhPZigndmFsdWUnKTtcbiAgICBpZiAodmFsdWUgPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZhbHVlIDwgdHlwZUluZGV4IHx8IHZhbHVlIDwgbWluSW5kZXggfHwgdmFsdWUgPCBtYXhJbmRleCB8fCB2YWx1ZSA8IHN0ZXBJbmRleCkge1xuICAgICAgICBjb25zb2xlRGV2V2FybihgVGhlIFwidmFsdWVcIiBwcm9wIG9mIDxpbnB1dD4gc2hvdWxkIGJlIHNldCBhZnRlciBcIm1pblwiLCBcIm1heFwiLCBcInR5cGVcIiBhbmQgXCJzdGVwXCJgKTtcbiAgICB9XG59O1xuLyoqXG4gKiBQcm9kdWN0aW9uIHNldEFjY2Vzc29yKCkgZnVuY3Rpb24gYmFzZWQgb24gUHJlYWN0IGJ5XG4gKiBKYXNvbiBNaWxsZXIgKEBkZXZlbG9waXQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZlbG9waXQvcHJlYWN0L2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBNb2RpZmllZCBmb3IgU3RlbmNpbCdzIGNvbXBpbGVyIGFuZCB2ZG9tXG4gKi9cbmNvbnN0IHNldEFjY2Vzc29yID0gKGVsbSwgbWVtYmVyTmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlLCBpc1N2ZywgZmxhZ3MpID0+IHtcbiAgICBpZiAob2xkVmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgIGxldCBpc1Byb3AgPSBpc01lbWJlckluRWxlbWVudChlbG0sIG1lbWJlck5hbWUpO1xuICAgICAgICBsZXQgbG4gPSBtZW1iZXJOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChCVUlMRC52ZG9tQ2xhc3MgJiYgbWVtYmVyTmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NMaXN0ID0gZWxtLmNsYXNzTGlzdDtcbiAgICAgICAgICAgIGNvbnN0IG9sZENsYXNzZXMgPSBwYXJzZUNsYXNzTGlzdChvbGRWYWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBuZXdDbGFzc2VzID0gcGFyc2VDbGFzc0xpc3QobmV3VmFsdWUpO1xuICAgICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSguLi5vbGRDbGFzc2VzLmZpbHRlcihjID0+IGMgJiYgIW5ld0NsYXNzZXMuaW5jbHVkZXMoYykpKTtcbiAgICAgICAgICAgIGNsYXNzTGlzdC5hZGQoLi4ubmV3Q2xhc3Nlcy5maWx0ZXIoYyA9PiBjICYmICFvbGRDbGFzc2VzLmluY2x1ZGVzKGMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQlVJTEQudmRvbVN0eWxlICYmIG1lbWJlck5hbWUgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBzdHlsZSBhdHRyaWJ1dGUsIGNzcyBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcbiAgICAgICAgICAgIGlmIChCVUlMRC51cGRhdGFibGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdWYWx1ZSB8fCBuZXdWYWx1ZVtwcm9wXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlICYmIHByb3AuaW5jbHVkZXMoJy0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5zdHlsZVtwcm9wXSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvbGRWYWx1ZSB8fCBuZXdWYWx1ZVtwcm9wXSAhPT0gb2xkVmFsdWVbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSAmJiBwcm9wLmluY2x1ZGVzKCctJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCBuZXdWYWx1ZVtwcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbG0uc3R5bGVbcHJvcF0gPSBuZXdWYWx1ZVtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCVUlMRC52ZG9tS2V5ICYmIG1lbWJlck5hbWUgPT09ICdrZXknKVxuICAgICAgICAgICAgO1xuICAgICAgICBlbHNlIGlmIChCVUlMRC52ZG9tUmVmICYmIG1lbWJlck5hbWUgPT09ICdyZWYnKSB7XG4gICAgICAgICAgICAvLyBtaW5pZmllciB3aWxsIGNsZWFuIHRoaXMgdXBcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlKGVsbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQlVJTEQudmRvbUxpc3RlbmVyICYmIChCVUlMRC5sYXp5TG9hZCA/ICFpc1Byb3AgOiAhZWxtLl9fbG9va3VwU2V0dGVyX18obWVtYmVyTmFtZSkpICYmIG1lbWJlck5hbWVbMF0gPT09ICdvJyAmJiBtZW1iZXJOYW1lWzFdID09PSAnbicpIHtcbiAgICAgICAgICAgIC8vIEV2ZW50IEhhbmRsZXJzXG4gICAgICAgICAgICAvLyBzbyBpZiB0aGUgbWVtYmVyIG5hbWUgc3RhcnRzIHdpdGggXCJvblwiIGFuZCB0aGUgM3JkIGNoYXJhY3RlcnMgaXNcbiAgICAgICAgICAgIC8vIGEgY2FwaXRhbCBsZXR0ZXIsIGFuZCBpdCdzIG5vdCBhbHJlYWR5IGEgbWVtYmVyIG9uIHRoZSBlbGVtZW50LFxuICAgICAgICAgICAgLy8gdGhlbiB3ZSdyZSBhc3N1bWluZyBpdCdzIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgICAgICBpZiAobWVtYmVyTmFtZVsyXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgLy8gb24tIHByZWZpeGVkIGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIGFsbG93cyB0byBiZSBleHBsaWNpdCBhYm91dCB0aGUgZG9tIGV2ZW50IHRvIGxpc3RlbiB3aXRob3V0IGFueSBtYWdpY1xuICAgICAgICAgICAgICAgIC8vIHVuZGVyIHRoZSBob29kOlxuICAgICAgICAgICAgICAgIC8vIDxteS1jbXAgb24tY2xpY2s+IC8vIGxpc3RlbnMgZm9yIFwiY2xpY2tcIlxuICAgICAgICAgICAgICAgIC8vIDxteS1jbXAgb24tQ2xpY2s+IC8vIGxpc3RlbnMgZm9yIFwiQ2xpY2tcIlxuICAgICAgICAgICAgICAgIC8vIDxteS1jbXAgb24taW9uQ2hhbmdlPiAvLyBsaXN0ZW5zIGZvciBcImlvbkNoYW5nZVwiXG4gICAgICAgICAgICAgICAgLy8gPG15LWNtcCBvbi1FVkVOVFM+IC8vIGxpc3RlbnMgZm9yIFwiRVZFTlRTXCJcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lID0gbWVtYmVyTmFtZS5zbGljZSgzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTWVtYmVySW5FbGVtZW50KHdpbiwgbG4pKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhbmRhcmQgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyB0aGUgSlNYIGF0dHJpYnV0ZSBjb3VsZCBoYXZlIGJlZW4gXCJvbk1vdXNlT3ZlclwiIGFuZCB0aGVcbiAgICAgICAgICAgICAgICAvLyBtZW1iZXIgbmFtZSBcIm9ubW91c2VvdmVyXCIgaXMgb24gdGhlIHdpbmRvdydzIHByb3RvdHlwZVxuICAgICAgICAgICAgICAgIC8vIHNvIGxldCdzIGFkZCB0aGUgbGlzdGVuZXIgXCJtb3VzZW92ZXJcIiwgd2hpY2ggaXMgYWxsIGxvd2VyY2FzZWRcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lID0gbG4uc2xpY2UoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjdXN0b20gZXZlbnRcbiAgICAgICAgICAgICAgICAvLyB0aGUgSlNYIGF0dHJpYnV0ZSBjb3VsZCBoYXZlIGJlZW4gXCJvbk15Q3VzdG9tRXZlbnRcIlxuICAgICAgICAgICAgICAgIC8vIHNvIGxldCdzIHRyaW0gb2ZmIHRoZSBcIm9uXCIgcHJlZml4IGFuZCBsb3dlcmNhc2UgdGhlIGZpcnN0IGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIC8vIGFuZCBhZGQgdGhlIGxpc3RlbmVyIFwibXlDdXN0b21FdmVudFwiXG4gICAgICAgICAgICAgICAgLy8gZXhjZXB0IGZvciB0aGUgZmlyc3QgY2hhcmFjdGVyLCB3ZSBrZWVwIHRoZSBldmVudCBuYW1lIGNhc2VcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lID0gbG5bMl0gKyBtZW1iZXJOYW1lLnNsaWNlKDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcGx0LnJlbChlbG0sIG1lbWJlck5hbWUsIG9sZFZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwbHQuYWVsKGVsbSwgbWVtYmVyTmFtZSwgbmV3VmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCVUlMRC52ZG9tUHJvcE9yQXR0cikge1xuICAgICAgICAgICAgLy8gU2V0IHByb3BlcnR5IGlmIGl0IGV4aXN0cyBhbmQgaXQncyBub3QgYSBTVkdcbiAgICAgICAgICAgIGNvbnN0IGlzQ29tcGxleCA9IGlzQ29tcGxleFR5cGUobmV3VmFsdWUpO1xuICAgICAgICAgICAgaWYgKChpc1Byb3AgfHwgKGlzQ29tcGxleCAmJiBuZXdWYWx1ZSAhPT0gbnVsbCkpICYmICFpc1N2Zykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZWxtLnRhZ05hbWUuaW5jbHVkZXMoJy0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG4gPSBuZXdWYWx1ZSA9PSBudWxsID8gJycgOiBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIFNhZmFyaSwgbW92aW5nIHRoZSA8aW5wdXQ+IGNhcmV0IHdoZW4gcmUtYXNzaWduaW5nIHRoZSBzYW1lIHZhbHVlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlck5hbWUgPT09ICdsaXN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogdHJpcGxlLWVxdWFsc1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkVmFsdWUgPT0gbnVsbCB8fCBlbG1bbWVtYmVyTmFtZV0gIT0gbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbVttZW1iZXJOYW1lXSA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbG1bbWVtYmVyTmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5lZWQgdG8gbWFudWFsbHkgdXBkYXRlIGF0dHJpYnV0ZSBpZjpcbiAgICAgICAgICAgICAqIC0gbWVtYmVyTmFtZSBpcyBub3QgYW4gYXR0cmlidXRlXG4gICAgICAgICAgICAgKiAtIGlmIHdlIGFyZSByZW5kZXJpbmcgdGhlIGhvc3QgZWxlbWVudCBpbiBvcmRlciB0byByZWZsZWN0IGF0dHJpYnV0ZVxuICAgICAgICAgICAgICogLSBpZiBpdCdzIGEgU1ZHLCBzaW5jZSBwcm9wZXJ0aWVzIG1pZ2h0IG5vdCB3b3JrIGluIDxzdmc+XG4gICAgICAgICAgICAgKiAtIGlmIHRoZSBuZXdWYWx1ZSBpcyBudWxsL3VuZGVmaW5lZCBvciAnZmFsc2UnLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZXQgeGxpbmsgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChCVUlMRC52ZG9tWGxpbmspIHtcbiAgICAgICAgICAgICAgICBpZiAobG4gIT09IChsbiA9IGxuLnJlcGxhY2UoL154bGlua1xcOj8vLCAnJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbWJlck5hbWUgPSBsbjtcbiAgICAgICAgICAgICAgICAgICAgeGxpbmsgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PSBudWxsIHx8IG5ld1ZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gZmFsc2UgfHwgZWxtLmdldEF0dHJpYnV0ZShtZW1iZXJOYW1lKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnZkb21YbGluayAmJiB4bGluaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKFhMSU5LX05TLCBtZW1iZXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUobWVtYmVyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoIWlzUHJvcCB8fCBmbGFncyAmIDQgLyogaXNIb3N0ICovIHx8IGlzU3ZnKSAmJiAhaXNDb21wbGV4KSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZSA9PT0gdHJ1ZSA/ICcnIDogbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELnZkb21YbGluayAmJiB4bGluaykge1xuICAgICAgICAgICAgICAgICAgICBlbG0uc2V0QXR0cmlidXRlTlMoWExJTktfTlMsIG1lbWJlck5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUobWVtYmVyTmFtZSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBwYXJzZUNsYXNzTGlzdFJlZ2V4ID0gL1xccy87XG5jb25zdCBwYXJzZUNsYXNzTGlzdCA9ICh2YWx1ZSkgPT4gKCF2YWx1ZSA/IFtdIDogdmFsdWUuc3BsaXQocGFyc2VDbGFzc0xpc3RSZWdleCkpO1xuY29uc3QgdXBkYXRlRWxlbWVudCA9IChvbGRWbm9kZSwgbmV3Vm5vZGUsIGlzU3ZnTW9kZSwgbWVtYmVyTmFtZSkgPT4ge1xuICAgIC8vIGlmIHRoZSBlbGVtZW50IHBhc3NlZCBpbiBpcyBhIHNoYWRvdyByb290LCB3aGljaCBpcyBhIGRvY3VtZW50IGZyYWdtZW50XG4gICAgLy8gdGhlbiB3ZSB3YW50IHRvIGJlIGFkZGluZyBhdHRycy9wcm9wcyB0byB0aGUgc2hhZG93IHJvb3QncyBcImhvc3RcIiBlbGVtZW50XG4gICAgLy8gaWYgaXQncyBub3QgYSBzaGFkb3cgcm9vdCwgdGhlbiB3ZSBhZGQgYXR0cnMvcHJvcHMgdG8gdGhlIHNhbWUgZWxlbWVudFxuICAgIGNvbnN0IGVsbSA9IG5ld1Zub2RlLiRlbG0kLm5vZGVUeXBlID09PSAxMSAvKiBEb2N1bWVudEZyYWdtZW50ICovICYmIG5ld1Zub2RlLiRlbG0kLmhvc3QgPyBuZXdWbm9kZS4kZWxtJC5ob3N0IDogbmV3Vm5vZGUuJGVsbSQ7XG4gICAgY29uc3Qgb2xkVm5vZGVBdHRycyA9IChvbGRWbm9kZSAmJiBvbGRWbm9kZS4kYXR0cnMkKSB8fCBFTVBUWV9PQko7XG4gICAgY29uc3QgbmV3Vm5vZGVBdHRycyA9IG5ld1Zub2RlLiRhdHRycyQgfHwgRU1QVFlfT0JKO1xuICAgIGlmIChCVUlMRC51cGRhdGFibGUpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGF0dHJpYnV0ZXMgbm8gbG9uZ2VyIHByZXNlbnQgb24gdGhlIHZub2RlIGJ5IHNldHRpbmcgdGhlbSB0byB1bmRlZmluZWRcbiAgICAgICAgZm9yIChtZW1iZXJOYW1lIGluIG9sZFZub2RlQXR0cnMpIHtcbiAgICAgICAgICAgIGlmICghKG1lbWJlck5hbWUgaW4gbmV3Vm5vZGVBdHRycykpIHtcbiAgICAgICAgICAgICAgICBzZXRBY2Nlc3NvcihlbG0sIG1lbWJlck5hbWUsIG9sZFZub2RlQXR0cnNbbWVtYmVyTmFtZV0sIHVuZGVmaW5lZCwgaXNTdmdNb2RlLCBuZXdWbm9kZS4kZmxhZ3MkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgbmV3ICYgdXBkYXRlIGNoYW5nZWQgYXR0cmlidXRlc1xuICAgIGZvciAobWVtYmVyTmFtZSBpbiBuZXdWbm9kZUF0dHJzKSB7XG4gICAgICAgIHNldEFjY2Vzc29yKGVsbSwgbWVtYmVyTmFtZSwgb2xkVm5vZGVBdHRyc1ttZW1iZXJOYW1lXSwgbmV3Vm5vZGVBdHRyc1ttZW1iZXJOYW1lXSwgaXNTdmdNb2RlLCBuZXdWbm9kZS4kZmxhZ3MkKTtcbiAgICB9XG59O1xuY29uc3QgY3JlYXRlRWxtID0gKG9sZFBhcmVudFZOb2RlLCBuZXdQYXJlbnRWTm9kZSwgY2hpbGRJbmRleCwgcGFyZW50RWxtKSA9PiB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBwcmVmZXItY29uc3RcbiAgICBsZXQgbmV3Vk5vZGUgPSBuZXdQYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkSW5kZXhdO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgZWxtO1xuICAgIGxldCBjaGlsZE5vZGU7XG4gICAgbGV0IG9sZFZOb2RlO1xuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiAhdXNlTmF0aXZlU2hhZG93RG9tKSB7XG4gICAgICAgIC8vIHJlbWVtYmVyIGZvciBsYXRlciB3ZSBuZWVkIHRvIGNoZWNrIHRvIHJlbG9jYXRlIG5vZGVzXG4gICAgICAgIGNoZWNrU2xvdFJlbG9jYXRlID0gdHJ1ZTtcbiAgICAgICAgaWYgKG5ld1ZOb2RlLiR0YWckID09PSAnc2xvdCcpIHtcbiAgICAgICAgICAgIGlmIChzY29wZUlkKSB7XG4gICAgICAgICAgICAgICAgLy8gc2NvcGVkIGNzcyBuZWVkcyB0byBhZGQgaXRzIHNjb3BlZCBpZCB0byB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICBwYXJlbnRFbG0uY2xhc3NMaXN0LmFkZChzY29wZUlkICsgJy1zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdWTm9kZS4kZmxhZ3MkIHw9IG5ld1ZOb2RlLiRjaGlsZHJlbiRcbiAgICAgICAgICAgICAgICA/IC8vIHNsb3QgZWxlbWVudCBoYXMgZmFsbGJhY2sgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAyIC8qIGlzU2xvdEZhbGxiYWNrICovXG4gICAgICAgICAgICAgICAgOiAvLyBzbG90IGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBmYWxsYmFjayBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgIDEgLyogaXNTbG90UmVmZXJlbmNlICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChCVUlMRC5pc0RldiAmJiBuZXdWTm9kZS4kZWxtJCkge1xuICAgICAgICBjb25zb2xlRGV2RXJyb3IoYFRoZSBKU1ggJHtuZXdWTm9kZS4kdGV4dCQgIT09IG51bGwgPyBgXCIke25ld1ZOb2RlLiR0ZXh0JH1cIiB0ZXh0YCA6IGBcIiR7bmV3Vk5vZGUuJHRhZyR9XCIgZWxlbWVudGB9IG5vZGUgc2hvdWxkIG5vdCBiZSBzaGFyZWQgd2l0aGluIHRoZSBzYW1lIHJlbmRlcmVyLiBUaGUgcmVuZGVyZXIgY2FjaGVzIGVsZW1lbnQgbG9va3VwcyBpbiBvcmRlciB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLiBIb3dldmVyLCBhIHNpZGUgZWZmZWN0IGZyb20gdGhpcyBpcyB0aGF0IHRoZSBleGFjdCBzYW1lIEpTWCBub2RlIHNob3VsZCBub3QgYmUgcmV1c2VkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBwbGVhc2Ugc2VlIGh0dHBzOi8vc3RlbmNpbGpzLmNvbS9kb2NzL3RlbXBsYXRpbmctanN4I2F2b2lkLXNoYXJlZC1qc3gtbm9kZXNgKTtcbiAgICB9XG4gICAgaWYgKEJVSUxELnZkb21UZXh0ICYmIG5ld1ZOb2RlLiR0ZXh0JCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBjcmVhdGUgdGV4dCBub2RlXG4gICAgICAgIGVsbSA9IG5ld1ZOb2RlLiRlbG0kID0gZG9jLmNyZWF0ZVRleHROb2RlKG5ld1ZOb2RlLiR0ZXh0JCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIG5ld1ZOb2RlLiRmbGFncyQgJiAxIC8qIGlzU2xvdFJlZmVyZW5jZSAqLykge1xuICAgICAgICAvLyBjcmVhdGUgYSBzbG90IHJlZmVyZW5jZSBub2RlXG4gICAgICAgIGVsbSA9IG5ld1ZOb2RlLiRlbG0kID0gQlVJTEQuaXNEZWJ1ZyB8fCBCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSA/IHNsb3RSZWZlcmVuY2VEZWJ1Z05vZGUobmV3Vk5vZGUpIDogZG9jLmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChCVUlMRC5zdmcgJiYgIWlzU3ZnTW9kZSkge1xuICAgICAgICAgICAgaXNTdmdNb2RlID0gbmV3Vk5vZGUuJHRhZyQgPT09ICdzdmcnO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSBlbGVtZW50XG4gICAgICAgIGVsbSA9IG5ld1ZOb2RlLiRlbG0kID0gKEJVSUxELnN2Z1xuICAgICAgICAgICAgPyBkb2MuY3JlYXRlRWxlbWVudE5TKGlzU3ZnTW9kZSA/IFNWR19OUyA6IEhUTUxfTlMsIEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIG5ld1ZOb2RlLiRmbGFncyQgJiAyIC8qIGlzU2xvdEZhbGxiYWNrICovID8gJ3Nsb3QtZmInIDogbmV3Vk5vZGUuJHRhZyQpXG4gICAgICAgICAgICA6IGRvYy5jcmVhdGVFbGVtZW50KEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIG5ld1ZOb2RlLiRmbGFncyQgJiAyIC8qIGlzU2xvdEZhbGxiYWNrICovID8gJ3Nsb3QtZmInIDogbmV3Vk5vZGUuJHRhZyQpKTtcbiAgICAgICAgaWYgKEJVSUxELnN2ZyAmJiBpc1N2Z01vZGUgJiYgbmV3Vk5vZGUuJHRhZyQgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgICAgICAgICAgaXNTdmdNb2RlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGNzcyBjbGFzc2VzLCBhdHRycywgcHJvcHMsIGxpc3RlbmVycywgZXRjLlxuICAgICAgICBpZiAoQlVJTEQudmRvbUF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgdXBkYXRlRWxlbWVudChudWxsLCBuZXdWTm9kZSwgaXNTdmdNb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKEJVSUxELnNoYWRvd0RvbSB8fCBCVUlMRC5zY29wZWQpICYmIGlzRGVmKHNjb3BlSWQpICYmIGVsbVsncy1zaSddICE9PSBzY29wZUlkKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHNjb3BlSWQgYW5kIHRoaXMgaXMgdGhlIGluaXRpYWwgcmVuZGVyXG4gICAgICAgICAgICAvLyB0aGVuIGxldCdzIGFkZCB0aGUgc2NvcGVJZCBhcyBhIGNzcyBjbGFzc1xuICAgICAgICAgICAgZWxtLmNsYXNzTGlzdC5hZGQoKGVsbVsncy1zaSddID0gc2NvcGVJZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdWTm9kZS4kY2hpbGRyZW4kKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmV3Vk5vZGUuJGNoaWxkcmVuJC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgbm9kZVxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNyZWF0ZUVsbShvbGRQYXJlbnRWTm9kZSwgbmV3Vk5vZGUsIGksIGVsbSk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIG5vZGUgY291bGQgaGF2ZSBiZWVuIG51bGxcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGVuZCBvdXIgbmV3IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgZWxtLmFwcGVuZENoaWxkKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5zdmcpIHtcbiAgICAgICAgICAgIGlmIChuZXdWTm9kZS4kdGFnJCA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJlc2V0IHRoZSBTVkcgY29udGV4dCB3aGVuIHdlJ3JlIGV4aXRpbmcgPHN2Zz4gZWxlbWVudFxuICAgICAgICAgICAgICAgIGlzU3ZnTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWxtLnRhZ05hbWUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIFJlZW50ZXIgU1ZHIGNvbnRleHQgd2hlbiB3ZSdyZSBleGl0aW5nIDxmb3JlaWduT2JqZWN0PiBlbGVtZW50XG4gICAgICAgICAgICAgICAgaXNTdmdNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24pIHtcbiAgICAgICAgZWxtWydzLWhuJ10gPSBob3N0VGFnTmFtZTtcbiAgICAgICAgaWYgKG5ld1ZOb2RlLiRmbGFncyQgJiAoMiAvKiBpc1Nsb3RGYWxsYmFjayAqLyB8IDEgLyogaXNTbG90UmVmZXJlbmNlICovKSkge1xuICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhlIGNvbnRlbnQgcmVmZXJlbmNlIGNvbW1lbnRcbiAgICAgICAgICAgIGVsbVsncy1zciddID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoZSBjb250ZW50IHJlZmVyZW5jZSBjb21tZW50XG4gICAgICAgICAgICBlbG1bJ3MtY3InXSA9IGNvbnRlbnRSZWY7XG4gICAgICAgICAgICAvLyByZW1lbWJlciB0aGUgc2xvdCBuYW1lLCBvciBlbXB0eSBzdHJpbmcgZm9yIGRlZmF1bHQgc2xvdFxuICAgICAgICAgICAgZWxtWydzLXNuJ10gPSBuZXdWTm9kZS4kbmFtZSQgfHwgJyc7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSd2ZSBnb3QgYW4gb2xkIHZub2RlIGZvciB0aGlzIHNsb3RcbiAgICAgICAgICAgIG9sZFZOb2RlID0gb2xkUGFyZW50Vk5vZGUgJiYgb2xkUGFyZW50Vk5vZGUuJGNoaWxkcmVuJCAmJiBvbGRQYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkSW5kZXhdO1xuICAgICAgICAgICAgaWYgKG9sZFZOb2RlICYmIG9sZFZOb2RlLiR0YWckID09PSBuZXdWTm9kZS4kdGFnJCAmJiBvbGRQYXJlbnRWTm9kZS4kZWxtJCkge1xuICAgICAgICAgICAgICAgIC8vIHdlJ3ZlIGdvdCBhbiBvbGQgc2xvdCB2bm9kZSBhbmQgdGhlIHdyYXBwZXIgaXMgYmVpbmcgcmVwbGFjZWRcbiAgICAgICAgICAgICAgICAvLyBzbyBsZXQncyBtb3ZlIHRoZSBvbGQgc2xvdCBjb250ZW50IGJhY2sgdG8gaXQncyBvcmlnaW5hbCBsb2NhdGlvblxuICAgICAgICAgICAgICAgIHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24ob2xkUGFyZW50Vk5vZGUuJGVsbSQsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxtO1xufTtcbmNvbnN0IHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24gPSAocGFyZW50RWxtLCByZWN1cnNpdmUpID0+IHtcbiAgICBwbHQuJGZsYWdzJCB8PSAxIC8qIGlzVG1wRGlzY29ubmVjdGVkICovO1xuICAgIGNvbnN0IG9sZFNsb3RDaGlsZE5vZGVzID0gcGFyZW50RWxtLmNoaWxkTm9kZXM7XG4gICAgZm9yIChsZXQgaSA9IG9sZFNsb3RDaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IG9sZFNsb3RDaGlsZE5vZGVzW2ldO1xuICAgICAgICBpZiAoY2hpbGROb2RlWydzLWhuJ10gIT09IGhvc3RUYWdOYW1lICYmIGNoaWxkTm9kZVsncy1vbCddKSB7XG4gICAgICAgICAgICAvLyAvLyB0aGlzIGNoaWxkIG5vZGUgaW4gdGhlIG9sZCBlbGVtZW50IGlzIGZyb20gYW5vdGhlciBjb21wb25lbnRcbiAgICAgICAgICAgIC8vIC8vIHJlbW92ZSB0aGlzIG5vZGUgZnJvbSB0aGUgb2xkIHNsb3QncyBwYXJlbnRcbiAgICAgICAgICAgIC8vIGNoaWxkTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgIC8vIGFuZCByZWxvY2F0ZSBpdCBiYWNrIHRvIGl0J3Mgb3JpZ2luYWwgbG9jYXRpb25cbiAgICAgICAgICAgIHBhcmVudFJlZmVyZW5jZU5vZGUoY2hpbGROb2RlKS5pbnNlcnRCZWZvcmUoY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKGNoaWxkTm9kZSkpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBvbGQgb3JpZ2luYWwgbG9jYXRpb24gY29tbWVudCBlbnRpcmVseVxuICAgICAgICAgICAgLy8gbGF0ZXIgb24gdGhlIHBhdGNoIGZ1bmN0aW9uIHdpbGwga25vdyB3aGF0IHRvIGRvXG4gICAgICAgICAgICAvLyBhbmQgbW92ZSB0aGlzIHRvIHRoZSBjb3JyZWN0IHNwb3QgaW4gbmVlZCBiZVxuICAgICAgICAgICAgY2hpbGROb2RlWydzLW9sJ10ucmVtb3ZlKCk7XG4gICAgICAgICAgICBjaGlsZE5vZGVbJ3Mtb2wnXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNoZWNrU2xvdFJlbG9jYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjdXJzaXZlKSB7XG4gICAgICAgICAgICBwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKGNoaWxkTm9kZSwgcmVjdXJzaXZlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwbHQuJGZsYWdzJCAmPSB+MSAvKiBpc1RtcERpc2Nvbm5lY3RlZCAqLztcbn07XG5jb25zdCBhZGRWbm9kZXMgPSAocGFyZW50RWxtLCBiZWZvcmUsIHBhcmVudFZOb2RlLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpID0+IHtcbiAgICBsZXQgY29udGFpbmVyRWxtID0gKChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiBwYXJlbnRFbG1bJ3MtY3InXSAmJiBwYXJlbnRFbG1bJ3MtY3InXS5wYXJlbnROb2RlKSB8fCBwYXJlbnRFbG0pO1xuICAgIGxldCBjaGlsZE5vZGU7XG4gICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiBjb250YWluZXJFbG0uc2hhZG93Um9vdCAmJiBjb250YWluZXJFbG0udGFnTmFtZSA9PT0gaG9zdFRhZ05hbWUpIHtcbiAgICAgICAgY29udGFpbmVyRWxtID0gY29udGFpbmVyRWxtLnNoYWRvd1Jvb3Q7XG4gICAgfVxuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgICAgaWYgKHZub2Rlc1tzdGFydElkeF0pIHtcbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNyZWF0ZUVsbShudWxsLCBwYXJlbnRWTm9kZSwgc3RhcnRJZHgsIHBhcmVudEVsbSk7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgdm5vZGVzW3N0YXJ0SWR4XS4kZWxtJCA9IGNoaWxkTm9kZTtcbiAgICAgICAgICAgICAgICBjb250YWluZXJFbG0uaW5zZXJ0QmVmb3JlKGNoaWxkTm9kZSwgQlVJTEQuc2xvdFJlbG9jYXRpb24gPyByZWZlcmVuY2VOb2RlKGJlZm9yZSkgOiBiZWZvcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IHJlbW92ZVZub2RlcyA9ICh2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIHZub2RlLCBlbG0pID0+IHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICAgIGlmICgodm5vZGUgPSB2bm9kZXNbc3RhcnRJZHhdKSkge1xuICAgICAgICAgICAgZWxtID0gdm5vZGUuJGVsbSQ7XG4gICAgICAgICAgICBjYWxsTm9kZVJlZnModm5vZGUpO1xuICAgICAgICAgICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UncmUgcmVtb3ZpbmcgdGhpcyBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gc28gaXQncyBwb3NzaWJsZSB3ZSBuZWVkIHRvIHNob3cgc2xvdCBmYWxsYmFjayBjb250ZW50IG5vd1xuICAgICAgICAgICAgICAgIGNoZWNrU2xvdEZhbGxiYWNrVmlzaWJpbGl0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGVsbVsncy1vbCddKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgb3JpZ2luYWwgbG9jYXRpb24gY29tbWVudFxuICAgICAgICAgICAgICAgICAgICBlbG1bJ3Mtb2wnXS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCBjaGlsZCBub2RlcyBvZiB0aGUgbm9kZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0J3MgYmVpbmcgcmVtb3ZlZCBhcmUgc2xvdCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICBwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKGVsbSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSB2bm9kZSdzIGVsZW1lbnQgZnJvbSB0aGUgZG9tXG4gICAgICAgICAgICBlbG0ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgdXBkYXRlQ2hpbGRyZW4gPSAocGFyZW50RWxtLCBvbGRDaCwgbmV3Vk5vZGUsIG5ld0NoKSA9PiB7XG4gICAgbGV0IG9sZFN0YXJ0SWR4ID0gMDtcbiAgICBsZXQgbmV3U3RhcnRJZHggPSAwO1xuICAgIGxldCBpZHhJbk9sZCA9IDA7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIGxldCBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgbGV0IG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICBsZXQgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICBsZXQgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIGxldCBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGVsbVRvTW92ZTtcbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgICBpZiAob2xkU3RhcnRWbm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBWbm9kZSBtaWdodCBoYXZlIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9sZEVuZFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1N0YXJ0Vm5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld0VuZFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaChvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKTtcbiAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1NhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaChvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpO1xuICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1NhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgICAgIC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgKG9sZFN0YXJ0Vm5vZGUuJHRhZyQgPT09ICdzbG90JyB8fCBuZXdFbmRWbm9kZS4kdGFnJCA9PT0gJ3Nsb3QnKSkge1xuICAgICAgICAgICAgICAgIHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24ob2xkU3RhcnRWbm9kZS4kZWxtJC5wYXJlbnROb2RlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaChvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSk7XG4gICAgICAgICAgICBwYXJlbnRFbG0uaW5zZXJ0QmVmb3JlKG9sZFN0YXJ0Vm5vZGUuJGVsbSQsIG9sZEVuZFZub2RlLiRlbG0kLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICAgICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIChvbGRTdGFydFZub2RlLiR0YWckID09PSAnc2xvdCcgfHwgbmV3RW5kVm5vZGUuJHRhZyQgPT09ICdzbG90JykpIHtcbiAgICAgICAgICAgICAgICBwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKG9sZEVuZFZub2RlLiRlbG0kLnBhcmVudE5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGNoKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKTtcbiAgICAgICAgICAgIHBhcmVudEVsbS5pbnNlcnRCZWZvcmUob2xkRW5kVm5vZGUuJGVsbSQsIG9sZFN0YXJ0Vm5vZGUuJGVsbSQpO1xuICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBjcmVhdGVLZXlUb09sZElkeFxuICAgICAgICAgICAgaWR4SW5PbGQgPSAtMTtcbiAgICAgICAgICAgIGlmIChCVUlMRC52ZG9tS2V5KSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gb2xkU3RhcnRJZHg7IGkgPD0gb2xkRW5kSWR4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZENoW2ldICYmIG9sZENoW2ldLiRrZXkkICE9PSBudWxsICYmIG9sZENoW2ldLiRrZXkkID09PSBuZXdTdGFydFZub2RlLiRrZXkkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHhJbk9sZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC52ZG9tS2V5ICYmIGlkeEluT2xkID49IDApIHtcbiAgICAgICAgICAgICAgICBlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgICAgICAgaWYgKGVsbVRvTW92ZS4kdGFnJCAhPT0gbmV3U3RhcnRWbm9kZS4kdGFnJCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gY3JlYXRlRWxtKG9sZENoICYmIG9sZENoW25ld1N0YXJ0SWR4XSwgbmV3Vk5vZGUsIGlkeEluT2xkLCBwYXJlbnRFbG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2goZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gZWxtVG9Nb3ZlLiRlbG0kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVFbG0ob2xkQ2ggJiYgb2xkQ2hbbmV3U3RhcnRJZHhdLCBuZXdWTm9kZSwgbmV3U3RhcnRJZHgsIHBhcmVudEVsbSk7XG4gICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50UmVmZXJlbmNlTm9kZShvbGRTdGFydFZub2RlLiRlbG0kKS5pbnNlcnRCZWZvcmUobm9kZSwgcmVmZXJlbmNlTm9kZShvbGRTdGFydFZub2RlLiRlbG0kKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlLiRlbG0kLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIG9sZFN0YXJ0Vm5vZGUuJGVsbSQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgbmV3Q2hbbmV3RW5kSWR4ICsgMV0gPT0gbnVsbCA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS4kZWxtJCwgbmV3Vk5vZGUsIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQlVJTEQudXBkYXRhYmxlICYmIG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxufTtcbmNvbnN0IGlzU2FtZVZub2RlID0gKHZub2RlMSwgdm5vZGUyKSA9PiB7XG4gICAgLy8gY29tcGFyZSBpZiB0d28gdm5vZGUgdG8gc2VlIGlmIHRoZXkncmUgXCJ0ZWNobmljYWxseVwiIHRoZSBzYW1lXG4gICAgLy8gbmVlZCB0byBoYXZlIHRoZSBzYW1lIGVsZW1lbnQgdGFnLCBhbmQgc2FtZSBrZXkgdG8gYmUgdGhlIHNhbWVcbiAgICBpZiAodm5vZGUxLiR0YWckID09PSB2bm9kZTIuJHRhZyQpIHtcbiAgICAgICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIHZub2RlMS4kdGFnJCA9PT0gJ3Nsb3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gdm5vZGUxLiRuYW1lJCA9PT0gdm5vZGUyLiRuYW1lJDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQudmRvbUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHZub2RlMS4ka2V5JCA9PT0gdm5vZGUyLiRrZXkkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgcmVmZXJlbmNlTm9kZSA9IChub2RlKSA9PiB7XG4gICAgLy8gdGhpcyBub2RlIHdhcyByZWxvY2F0ZWQgdG8gYSBuZXcgbG9jYXRpb24gaW4gdGhlIGRvbVxuICAgIC8vIGJlY2F1c2Ugb2Ygc29tZSBvdGhlciBjb21wb25lbnQncyBzbG90XG4gICAgLy8gYnV0IHdlIHN0aWxsIGhhdmUgYW4gaHRtbCBjb21tZW50IGluIHBsYWNlIG9mIHdoZXJlXG4gICAgLy8gaXQncyBvcmlnaW5hbCBsb2NhdGlvbiB3YXMgYWNjb3JkaW5nIHRvIGl0J3Mgb3JpZ2luYWwgdmRvbVxuICAgIHJldHVybiAobm9kZSAmJiBub2RlWydzLW9sJ10pIHx8IG5vZGU7XG59O1xuY29uc3QgcGFyZW50UmVmZXJlbmNlTm9kZSA9IChub2RlKSA9PiAobm9kZVsncy1vbCddID8gbm9kZVsncy1vbCddIDogbm9kZSkucGFyZW50Tm9kZTtcbmNvbnN0IHBhdGNoID0gKG9sZFZOb2RlLCBuZXdWTm9kZSkgPT4ge1xuICAgIGNvbnN0IGVsbSA9IChuZXdWTm9kZS4kZWxtJCA9IG9sZFZOb2RlLiRlbG0kKTtcbiAgICBjb25zdCBvbGRDaGlsZHJlbiA9IG9sZFZOb2RlLiRjaGlsZHJlbiQ7XG4gICAgY29uc3QgbmV3Q2hpbGRyZW4gPSBuZXdWTm9kZS4kY2hpbGRyZW4kO1xuICAgIGNvbnN0IHRhZyA9IG5ld1ZOb2RlLiR0YWckO1xuICAgIGNvbnN0IHRleHQgPSBuZXdWTm9kZS4kdGV4dCQ7XG4gICAgbGV0IGRlZmF1bHRIb2xkZXI7XG4gICAgaWYgKCFCVUlMRC52ZG9tVGV4dCB8fCB0ZXh0ID09PSBudWxsKSB7XG4gICAgICAgIGlmIChCVUlMRC5zdmcpIHtcbiAgICAgICAgICAgIC8vIHRlc3QgaWYgd2UncmUgcmVuZGVyaW5nIGFuIHN2ZyBlbGVtZW50LCBvciBzdGlsbCByZW5kZXJpbmcgbm9kZXMgaW5zaWRlIG9mIG9uZVxuICAgICAgICAgICAgLy8gb25seSBhZGQgdGhpcyB0byB0aGUgd2hlbiB0aGUgY29tcGlsZXIgc2VlcyB3ZSdyZSB1c2luZyBhbiBzdmcgc29tZXdoZXJlXG4gICAgICAgICAgICBpc1N2Z01vZGUgPSB0YWcgPT09ICdzdmcnID8gdHJ1ZSA6IHRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnID8gZmFsc2UgOiBpc1N2Z01vZGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxlbWVudCBub2RlXG4gICAgICAgIGlmIChCVUlMRC52ZG9tQXR0cmlidXRlIHx8IEJVSUxELnJlZmxlY3QpIHtcbiAgICAgICAgICAgIGlmIChCVUlMRC5zbG90ICYmIHRhZyA9PT0gJ3Nsb3QnKVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCByZW5kZXIgb2YgYW4gZWxlbWVudCBPUiBpdCdzIGFuIHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIEFORCB3ZSBhbHJlYWR5IGtub3cgaXQncyBwb3NzaWJsZSBpdCBjb3VsZCBoYXZlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHVwZGF0ZXMgdGhlIGVsZW1lbnQncyBjc3MgY2xhc3NlcywgYXR0cnMsIHByb3BzLCBsaXN0ZW5lcnMsIGV0Yy5cbiAgICAgICAgICAgICAgICB1cGRhdGVFbGVtZW50KG9sZFZOb2RlLCBuZXdWTm9kZSwgaXNTdmdNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQudXBkYXRhYmxlICYmIG9sZENoaWxkcmVuICE9PSBudWxsICYmIG5ld0NoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBsb29rcyBsaWtlIHRoZXJlJ3MgY2hpbGQgdm5vZGVzIGZvciBib3RoIHRoZSBvbGQgYW5kIG5ldyB2bm9kZXNcbiAgICAgICAgICAgIHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2hpbGRyZW4sIG5ld1ZOb2RlLCBuZXdDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3Q2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vIG9sZCBjaGlsZCB2bm9kZXMsIGJ1dCB0aGVyZSBhcmUgbmV3IGNoaWxkIHZub2RlcyB0byBhZGRcbiAgICAgICAgICAgIGlmIChCVUlMRC51cGRhdGFibGUgJiYgQlVJTEQudmRvbVRleHQgJiYgb2xkVk5vZGUuJHRleHQkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIG9sZCB2bm9kZSB3YXMgdGV4dCwgc28gYmUgc3VyZSB0byBjbGVhciBpdCBvdXRcbiAgICAgICAgICAgICAgICBlbG0udGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgbmV3IHZub2RlIGNoaWxkcmVuXG4gICAgICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBuZXdWTm9kZSwgbmV3Q2hpbGRyZW4sIDAsIG5ld0NoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJVSUxELnVwZGF0YWJsZSAmJiBvbGRDaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm8gbmV3IGNoaWxkIHZub2RlcywgYnV0IHRoZXJlIGFyZSBvbGQgY2hpbGQgdm5vZGVzIHRvIHJlbW92ZVxuICAgICAgICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoaWxkcmVuLCAwLCBvbGRDaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQuc3ZnICYmIGlzU3ZnTW9kZSAmJiB0YWcgPT09ICdzdmcnKSB7XG4gICAgICAgICAgICBpc1N2Z01vZGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChCVUlMRC52ZG9tVGV4dCAmJiBCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiAoZGVmYXVsdEhvbGRlciA9IGVsbVsncy1jciddKSkge1xuICAgICAgICAvLyB0aGlzIGVsZW1lbnQgaGFzIHNsb3R0ZWQgY29udGVudFxuICAgICAgICBkZWZhdWx0SG9sZGVyLnBhcmVudE5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgIH1cbiAgICBlbHNlIGlmIChCVUlMRC52ZG9tVGV4dCAmJiBvbGRWTm9kZS4kdGV4dCQgIT09IHRleHQpIHtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSB0ZXh0IGNvbnRlbnQgZm9yIHRoZSB0ZXh0IG9ubHkgdm5vZGVcbiAgICAgICAgLy8gYW5kIGFsc28gb25seSBpZiB0aGUgdGV4dCBpcyBkaWZmZXJlbnQgdGhhbiBiZWZvcmVcbiAgICAgICAgZWxtLmRhdGEgPSB0ZXh0O1xuICAgIH1cbn07XG5jb25zdCB1cGRhdGVGYWxsYmFja1Nsb3RWaXNpYmlsaXR5ID0gKGVsbSkgPT4ge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogcHJlZmVyLWNvbnN0XG4gICAgbGV0IGNoaWxkTm9kZXMgPSBlbG0uY2hpbGROb2RlcztcbiAgICBsZXQgY2hpbGROb2RlO1xuICAgIGxldCBpO1xuICAgIGxldCBpbGVuO1xuICAgIGxldCBqO1xuICAgIGxldCBzbG90TmFtZUF0dHI7XG4gICAgbGV0IG5vZGVUeXBlO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlWydzLXNyJ10pIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgc2xvdCBmYWxsYmFjayBub2RlXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBzbG90IG5hbWUgZm9yIHRoaXMgc2xvdCByZWZlcmVuY2Ugbm9kZVxuICAgICAgICAgICAgICAgIHNsb3ROYW1lQXR0ciA9IGNoaWxkTm9kZVsncy1zbiddO1xuICAgICAgICAgICAgICAgIC8vIGJ5IGRlZmF1bHQgYWx3YXlzIHNob3cgYSBmYWxsYmFjayBzbG90IG5vZGVcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGhpZGUgaXQgaWYgdGhlcmUgYXJlIG90aGVyIHNsb3RzIGluIHRoZSBsaWdodCBkb21cbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGlsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICBub2RlVHlwZSA9IGNoaWxkTm9kZXNbal0ubm9kZVR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzW2pdWydzLWhuJ10gIT09IGNoaWxkTm9kZVsncy1obiddIHx8IHNsb3ROYW1lQXR0ciAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgc2libGluZyBub2RlIGlzIGZyb20gYSBkaWZmZXJlbnQgY29tcG9uZW50IE9SIGlzIGEgbmFtZWQgZmFsbGJhY2sgc2xvdCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8gJiYgc2xvdE5hbWVBdHRyID09PSBjaGlsZE5vZGVzW2pdLmdldEF0dHJpYnV0ZSgnc2xvdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgZGVmYXVsdCBmYWxsYmFjayBzbG90IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFueSBlbGVtZW50IG9yIHRleHQgbm9kZSAod2l0aCBjb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIGhpZGUgdGhlIGRlZmF1bHQgZmFsbGJhY2sgc2xvdCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobm9kZVR5cGUgPT09IDMgLyogVGV4dE5vZGUgKi8gJiYgY2hpbGROb2Rlc1tqXS50ZXh0Q29udGVudC50cmltKCkgIT09ICcnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8ga2VlcCBkcmlsbGluZyBkb3duXG4gICAgICAgICAgICB1cGRhdGVGYWxsYmFja1Nsb3RWaXNpYmlsaXR5KGNoaWxkTm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgcmVsb2NhdGVOb2RlcyA9IFtdO1xuY29uc3QgcmVsb2NhdGVTbG90Q29udGVudCA9IChlbG0pID0+IHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IHByZWZlci1jb25zdFxuICAgIGxldCBjaGlsZE5vZGU7XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGhvc3RDb250ZW50Tm9kZXM7XG4gICAgbGV0IHNsb3ROYW1lQXR0cjtcbiAgICBsZXQgcmVsb2NhdGVOb2RlRGF0YTtcbiAgICBsZXQgajtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGNoaWxkTm9kZXMgPSBlbG0uY2hpbGROb2RlcztcbiAgICBsZXQgaWxlbiA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIGZvciAoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgIGlmIChjaGlsZE5vZGVbJ3Mtc3InXSAmJiAobm9kZSA9IGNoaWxkTm9kZVsncy1jciddKSAmJiBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IGdvdCB0aGUgY29udGVudCByZWZlcmVuY2UgY29tbWVudCBub2RlXG4gICAgICAgICAgICAvLyB0aGVuIHdlIGdvdCBpdCdzIHBhcmVudCwgd2hpY2ggaXMgd2hlcmUgYWxsIHRoZSBob3N0IGNvbnRlbnQgaXMgaW4gbm93XG4gICAgICAgICAgICBob3N0Q29udGVudE5vZGVzID0gbm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICBzbG90TmFtZUF0dHIgPSBjaGlsZE5vZGVbJ3Mtc24nXTtcbiAgICAgICAgICAgIGZvciAoaiA9IGhvc3RDb250ZW50Tm9kZXMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBub2RlID0gaG9zdENvbnRlbnROb2Rlc1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVbJ3MtY24nXSAmJiAhbm9kZVsncy1uciddICYmIG5vZGVbJ3MtaG4nXSAhPT0gY2hpbGROb2RlWydzLWhuJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGV0J3MgZG8gc29tZSByZWxvY2F0aW5nIHRvIGl0cyBuZXcgaG9tZVxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgbmV2ZXIgcmVsb2NhdGUgYSBjb250ZW50IHJlZmVyZW5jZSBub2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgaXMgc3VwcG9zZSB0byBhbHdheXMgcmVwcmVzZW50IHRoZSBvcmlnaW5hbCBjb250ZW50IGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05vZGVMb2NhdGVkSW5TbG90KG5vZGUsIHNsb3ROYW1lQXR0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgd2UndmUgYWxyZWFkeSBkZWNpZGVkIHRvIHJlbG9jYXRlIHRoaXMgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsb2NhdGVOb2RlRGF0YSA9IHJlbG9jYXRlTm9kZXMuZmluZChyID0+IHIuJG5vZGVUb1JlbG9jYXRlJCA9PT0gbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWRlIHNvbWUgY2hhbmdlcyB0byBzbG90c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0J3MgbWFrZSBzdXJlIHdlIGFsc28gZG91YmxlIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmYWxsYmFja3MgYXJlIGNvcnJlY3RseSBoaWRkZW4gb3Igc2hvd25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrU2xvdEZhbGxiYWNrVmlzaWJpbGl0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlWydzLXNuJ10gPSBub2RlWydzLXNuJ10gfHwgc2xvdE5hbWVBdHRyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbG9jYXRlTm9kZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmV2aW91c2x5IHdlIG5ldmVyIGZvdW5kIGEgc2xvdCBob21lIGZvciB0aGlzIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgdHVybnMgb3V0IHdlIGRpZCwgc28gbGV0J3MgcmVtZW1iZXIgaXQgbm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsb2NhdGVOb2RlRGF0YS4kc2xvdFJlZk5vZGUkID0gY2hpbGROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRvIG91ciBsaXN0IG9mIG5vZGVzIHRvIHJlbG9jYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsb2NhdGVOb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNsb3RSZWZOb2RlJDogY2hpbGROb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbm9kZVRvUmVsb2NhdGUkOiBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVbJ3Mtc3InXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbG9jYXRlTm9kZXMubWFwKHJlbG9jYXRlTm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05vZGVMb2NhdGVkSW5TbG90KHJlbG9jYXRlTm9kZS4kbm9kZVRvUmVsb2NhdGUkLCBub2RlWydzLXNuJ10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVEYXRhID0gcmVsb2NhdGVOb2Rlcy5maW5kKHIgPT4gci4kbm9kZVRvUmVsb2NhdGUkID09PSBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWxvY2F0ZU5vZGVEYXRhICYmICFyZWxvY2F0ZU5vZGUuJHNsb3RSZWZOb2RlJCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbG9jYXRlTm9kZS4kc2xvdFJlZk5vZGUkID0gcmVsb2NhdGVOb2RlRGF0YS4kc2xvdFJlZk5vZGUkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXJlbG9jYXRlTm9kZXMuc29tZShyID0+IHIuJG5vZGVUb1JlbG9jYXRlJCA9PT0gbm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIGZhciB0aGlzIGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBhIHNsb3QgaG9tZSwgbm90IHNldHRpbmcgc2xvdFJlZk5vZGUgb24gcHVycG9zZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgbmV2ZXIgZmluZCBhIGhvbWUgZm9yIHRoaXMgZWxlbWVudCB0aGVuIHdlJ2xsIG5lZWQgdG8gaGlkZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsb2NhdGVOb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbm9kZVRvUmVsb2NhdGUkOiBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLykge1xuICAgICAgICAgICAgcmVsb2NhdGVTbG90Q29udGVudChjaGlsZE5vZGUpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGlzTm9kZUxvY2F0ZWRJblNsb3QgPSAobm9kZVRvUmVsb2NhdGUsIHNsb3ROYW1lQXR0cikgPT4ge1xuICAgIGlmIChub2RlVG9SZWxvY2F0ZS5ub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLykge1xuICAgICAgICBpZiAobm9kZVRvUmVsb2NhdGUuZ2V0QXR0cmlidXRlKCdzbG90JykgPT09IG51bGwgJiYgc2xvdE5hbWVBdHRyID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVUb1JlbG9jYXRlLmdldEF0dHJpYnV0ZSgnc2xvdCcpID09PSBzbG90TmFtZUF0dHIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGVUb1JlbG9jYXRlWydzLXNuJ10gPT09IHNsb3ROYW1lQXR0cikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHNsb3ROYW1lQXR0ciA9PT0gJyc7XG59O1xuY29uc3QgY2FsbE5vZGVSZWZzID0gKHZOb2RlKSA9PiB7XG4gICAgaWYgKEJVSUxELnZkb21SZWYpIHtcbiAgICAgICAgdk5vZGUuJGF0dHJzJCAmJiB2Tm9kZS4kYXR0cnMkLnJlZiAmJiB2Tm9kZS4kYXR0cnMkLnJlZihudWxsKTtcbiAgICAgICAgdk5vZGUuJGNoaWxkcmVuJCAmJiB2Tm9kZS4kY2hpbGRyZW4kLm1hcChjYWxsTm9kZVJlZnMpO1xuICAgIH1cbn07XG5jb25zdCByZW5kZXJWZG9tID0gKGhvc3RSZWYsIHJlbmRlckZuUmVzdWx0cykgPT4ge1xuICAgIGNvbnN0IGhvc3RFbG0gPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gICAgY29uc3QgY21wTWV0YSA9IGhvc3RSZWYuJGNtcE1ldGEkO1xuICAgIGNvbnN0IG9sZFZOb2RlID0gaG9zdFJlZi4kdm5vZGUkIHx8IG5ld1ZOb2RlKG51bGwsIG51bGwpO1xuICAgIGNvbnN0IHJvb3RWbm9kZSA9IGlzSG9zdChyZW5kZXJGblJlc3VsdHMpID8gcmVuZGVyRm5SZXN1bHRzIDogaChudWxsLCBudWxsLCByZW5kZXJGblJlc3VsdHMpO1xuICAgIGhvc3RUYWdOYW1lID0gaG9zdEVsbS50YWdOYW1lO1xuICAgIC8vIDxIb3N0PiBydW50aW1lIGNoZWNrXG4gICAgaWYgKEJVSUxELmlzRGV2ICYmIEFycmF5LmlzQXJyYXkocmVuZGVyRm5SZXN1bHRzKSAmJiByZW5kZXJGblJlc3VsdHMuc29tZShpc0hvc3QpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIDxIb3N0PiBtdXN0IGJlIHRoZSBzaW5nbGUgcm9vdCBjb21wb25lbnQuXG5Mb29rcyBsaWtlIHRoZSByZW5kZXIoKSBmdW5jdGlvbiBvZiBcIiR7aG9zdFRhZ05hbWUudG9Mb3dlckNhc2UoKX1cIiBpcyByZXR1cm5pbmcgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgPEhvc3Q+LlxuXG5UaGUgcmVuZGVyKCkgZnVuY3Rpb24gc2hvdWxkIGxvb2sgbGlrZSB0aGlzIGluc3RlYWQ6XG5cbnJlbmRlcigpIHtcbiAgLy8gRG8gbm90IHJldHVybiBhbiBhcnJheVxuICByZXR1cm4gKFxuICAgIDxIb3N0Pntjb250ZW50fTwvSG9zdD5cbiAgKTtcbn1cbiAgYCk7XG4gICAgfVxuICAgIGlmIChCVUlMRC5yZWZsZWN0ICYmIGNtcE1ldGEuJGF0dHJzVG9SZWZsZWN0JCkge1xuICAgICAgICByb290Vm5vZGUuJGF0dHJzJCA9IHJvb3RWbm9kZS4kYXR0cnMkIHx8IHt9O1xuICAgICAgICBjbXBNZXRhLiRhdHRyc1RvUmVmbGVjdCQubWFwKChbcHJvcE5hbWUsIGF0dHJpYnV0ZV0pID0+IChyb290Vm5vZGUuJGF0dHJzJFthdHRyaWJ1dGVdID0gaG9zdEVsbVtwcm9wTmFtZV0pKTtcbiAgICB9XG4gICAgcm9vdFZub2RlLiR0YWckID0gbnVsbDtcbiAgICByb290Vm5vZGUuJGZsYWdzJCB8PSA0IC8qIGlzSG9zdCAqLztcbiAgICBob3N0UmVmLiR2bm9kZSQgPSByb290Vm5vZGU7XG4gICAgcm9vdFZub2RlLiRlbG0kID0gb2xkVk5vZGUuJGVsbSQgPSAoQlVJTEQuc2hhZG93RG9tID8gaG9zdEVsbS5zaGFkb3dSb290IHx8IGhvc3RFbG0gOiBob3N0RWxtKTtcbiAgICBpZiAoQlVJTEQuc2NvcGVkIHx8IEJVSUxELnNoYWRvd0RvbSkge1xuICAgICAgICBzY29wZUlkID0gaG9zdEVsbVsncy1zYyddO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24pIHtcbiAgICAgICAgY29udGVudFJlZiA9IGhvc3RFbG1bJ3MtY3InXTtcbiAgICAgICAgdXNlTmF0aXZlU2hhZG93RG9tID0gc3VwcG9ydHNTaGFkb3cgJiYgKGNtcE1ldGEuJGZsYWdzJCAmIDEgLyogc2hhZG93RG9tRW5jYXBzdWxhdGlvbiAqLykgIT09IDA7XG4gICAgICAgIC8vIGFsd2F5cyByZXNldFxuICAgICAgICBjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHkgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gc3luY2hyb25vdXMgcGF0Y2hcbiAgICBwYXRjaChvbGRWTm9kZSwgcm9vdFZub2RlKTtcbiAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24pIHtcbiAgICAgICAgLy8gd2hpbGUgd2UncmUgbW92aW5nIG5vZGVzIGFyb3VuZCBleGlzdGluZyBub2RlcywgdGVtcG9yYXJpbHkgZGlzYWJsZVxuICAgICAgICAvLyB0aGUgZGlzY29ubmVjdENhbGxiYWNrIGZyb20gd29ya2luZ1xuICAgICAgICBwbHQuJGZsYWdzJCB8PSAxIC8qIGlzVG1wRGlzY29ubmVjdGVkICovO1xuICAgICAgICBpZiAoY2hlY2tTbG90UmVsb2NhdGUpIHtcbiAgICAgICAgICAgIHJlbG9jYXRlU2xvdENvbnRlbnQocm9vdFZub2RlLiRlbG0kKTtcbiAgICAgICAgICAgIGxldCByZWxvY2F0ZURhdGE7XG4gICAgICAgICAgICBsZXQgbm9kZVRvUmVsb2NhdGU7XG4gICAgICAgICAgICBsZXQgb3JnTG9jYXRpb25Ob2RlO1xuICAgICAgICAgICAgbGV0IHBhcmVudE5vZGVSZWY7XG4gICAgICAgICAgICBsZXQgaW5zZXJ0QmVmb3JlTm9kZTtcbiAgICAgICAgICAgIGxldCByZWZOb2RlO1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgZm9yICg7IGkgPCByZWxvY2F0ZU5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVsb2NhdGVEYXRhID0gcmVsb2NhdGVOb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBub2RlVG9SZWxvY2F0ZSA9IHJlbG9jYXRlRGF0YS4kbm9kZVRvUmVsb2NhdGUkO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZVRvUmVsb2NhdGVbJ3Mtb2wnXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgYSByZWZlcmVuY2Ugbm9kZSBtYXJraW5nIHRoaXMgbm9kZSdzIG9yaWdpbmFsIGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhpcyBub2RlIGZvciBsYXRlciBsb29rdXBzXG4gICAgICAgICAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZSA9IEJVSUxELmlzRGVidWcgfHwgQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgPyBvcmlnaW5hbExvY2F0aW9uRGVidWdOb2RlKG5vZGVUb1JlbG9jYXRlKSA6IGRvYy5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgICAgICAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZVsncy1uciddID0gbm9kZVRvUmVsb2NhdGU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVUb1JlbG9jYXRlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKChub2RlVG9SZWxvY2F0ZVsncy1vbCddID0gb3JnTG9jYXRpb25Ob2RlKSwgbm9kZVRvUmVsb2NhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByZWxvY2F0ZU5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVsb2NhdGVEYXRhID0gcmVsb2NhdGVOb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBub2RlVG9SZWxvY2F0ZSA9IHJlbG9jYXRlRGF0YS4kbm9kZVRvUmVsb2NhdGUkO1xuICAgICAgICAgICAgICAgIGlmIChyZWxvY2F0ZURhdGEuJHNsb3RSZWZOb2RlJCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBieSBkZWZhdWx0IHdlJ3JlIGp1c3QgZ29pbmcgdG8gaW5zZXJ0IGl0IGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgIC8vIGFmdGVyIHRoZSBzbG90IHJlZmVyZW5jZSBub2RlXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGVSZWYgPSByZWxvY2F0ZURhdGEuJHNsb3RSZWZOb2RlJC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmVOb2RlID0gcmVsb2NhdGVEYXRhLiRzbG90UmVmTm9kZSQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZSA9IG5vZGVUb1JlbG9jYXRlWydzLW9sJ107XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgob3JnTG9jYXRpb25Ob2RlID0gb3JnTG9jYXRpb25Ob2RlLnByZXZpb3VzU2libGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZk5vZGUgPSBvcmdMb2NhdGlvbk5vZGVbJ3MtbnInXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWZOb2RlICYmIHJlZk5vZGVbJ3Mtc24nXSA9PT0gbm9kZVRvUmVsb2NhdGVbJ3Mtc24nXSAmJiBwYXJlbnROb2RlUmVmID09PSByZWZOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZOb2RlID0gcmVmTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlZk5vZGUgfHwgIXJlZk5vZGVbJ3MtbnInXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmVOb2RlID0gcmVmTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgoIWluc2VydEJlZm9yZU5vZGUgJiYgcGFyZW50Tm9kZVJlZiAhPT0gbm9kZVRvUmVsb2NhdGUucGFyZW50Tm9kZSkgfHwgbm9kZVRvUmVsb2NhdGUubmV4dFNpYmxpbmcgIT09IGluc2VydEJlZm9yZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3ZlIGNoZWNrZWQgdGhhdCBpdCdzIHdvcnRoIHdoaWxlIHRvIHJlbG9jYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGF0IHRoZSBub2RlIHRvIHJlbG9jYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoYXMgYSBkaWZmZXJlbnQgbmV4dCBzaWJsaW5nIG9yIHBhcmVudCByZWxvY2F0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlVG9SZWxvY2F0ZSAhPT0gaW5zZXJ0QmVmb3JlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm9kZVRvUmVsb2NhdGVbJ3MtaG4nXSAmJiBub2RlVG9SZWxvY2F0ZVsncy1vbCddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2JhYmx5IGEgY29tcG9uZW50IGluIHRoZSBpbmRleC5odG1sIHRoYXQgZG9lc24ndCBoYXZlIGl0J3MgaG9zdG5hbWUgc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVUb1JlbG9jYXRlWydzLWhuJ10gPSBub2RlVG9SZWxvY2F0ZVsncy1vbCddLnBhcmVudE5vZGUubm9kZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBpdCBiYWNrIHRvIHRoZSBkb20gYnV0IGluIGl0cyBuZXcgaG9tZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGVSZWYuaW5zZXJ0QmVmb3JlKG5vZGVUb1JlbG9jYXRlLCBpbnNlcnRCZWZvcmVOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBub2RlIGRvZXNuJ3QgaGF2ZSBhIHNsb3QgaG9tZSB0byBnbyB0bywgc28gbGV0J3MgaGlkZSBpdFxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVRvUmVsb2NhdGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVUb1JlbG9jYXRlLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoZWNrU2xvdEZhbGxiYWNrVmlzaWJpbGl0eSkge1xuICAgICAgICAgICAgdXBkYXRlRmFsbGJhY2tTbG90VmlzaWJpbGl0eShyb290Vm5vZGUuJGVsbSQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvbmUgbW92aW5nIG5vZGVzIGFyb3VuZFxuICAgICAgICAvLyBhbGxvdyB0aGUgZGlzY29ubmVjdCBjYWxsYmFjayB0byB3b3JrIGFnYWluXG4gICAgICAgIHBsdC4kZmxhZ3MkICY9IH4xIC8qIGlzVG1wRGlzY29ubmVjdGVkICovO1xuICAgICAgICAvLyBhbHdheXMgcmVzZXRcbiAgICAgICAgcmVsb2NhdGVOb2Rlcy5sZW5ndGggPSAwO1xuICAgIH1cbn07XG4vLyBzbG90IGNvbW1lbnQgZGVidWcgbm9kZXMgb25seSBjcmVhdGVkIHdpdGggdGhlIGAtLWRlYnVnYCBmbGFnXG4vLyBvdGhlcndpc2UgdGhlc2Ugbm9kZXMgYXJlIHRleHQgbm9kZXMgdy9vdXQgY29udGVudFxuY29uc3Qgc2xvdFJlZmVyZW5jZURlYnVnTm9kZSA9IChzbG90Vk5vZGUpID0+IGRvYy5jcmVhdGVDb21tZW50KGA8c2xvdCR7c2xvdFZOb2RlLiRuYW1lJCA/ICcgbmFtZT1cIicgKyBzbG90Vk5vZGUuJG5hbWUkICsgJ1wiJyA6ICcnfT4gKGhvc3Q9JHtob3N0VGFnTmFtZS50b0xvd2VyQ2FzZSgpfSlgKTtcbmNvbnN0IG9yaWdpbmFsTG9jYXRpb25EZWJ1Z05vZGUgPSAobm9kZVRvUmVsb2NhdGUpID0+IGRvYy5jcmVhdGVDb21tZW50KGBvcmctbG9jYXRpb24gZm9yIGAgKyAobm9kZVRvUmVsb2NhdGUubG9jYWxOYW1lID8gYDwke25vZGVUb1JlbG9jYXRlLmxvY2FsTmFtZX0+IChob3N0PSR7bm9kZVRvUmVsb2NhdGVbJ3MtaG4nXX0pYCA6IGBbJHtub2RlVG9SZWxvY2F0ZS50ZXh0Q29udGVudH1dYCkpO1xuY29uc3QgZ2V0RWxlbWVudCA9IChyZWYpID0+IChCVUlMRC5sYXp5TG9hZCA/IGdldEhvc3RSZWYocmVmKS4kaG9zdEVsZW1lbnQkIDogcmVmKTtcbmNvbnN0IGNyZWF0ZUV2ZW50ID0gKHJlZiwgbmFtZSwgZmxhZ3MpID0+IHtcbiAgICBjb25zdCBlbG0gPSBnZXRFbGVtZW50KHJlZik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW1pdDogKGRldGFpbCkgPT4ge1xuICAgICAgICAgICAgaWYgKEJVSUxELmlzRGV2ICYmICFlbG0uaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlRGV2V2FybihgVGhlIFwiJHtuYW1lfVwiIGV2ZW50IHdhcyBlbWl0dGVkLCBidXQgdGhlIGRpc3BhdGNoZXIgbm9kZSBpcyBubyBsb25nZXIgY29ubmVjdGVkIHRvIHRoZSBkb20uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZW1pdEV2ZW50KGVsbSwgbmFtZSwge1xuICAgICAgICAgICAgICAgIGJ1YmJsZXM6ICEhKGZsYWdzICYgNCAvKiBCdWJibGVzICovKSxcbiAgICAgICAgICAgICAgICBjb21wb3NlZDogISEoZmxhZ3MgJiAyIC8qIENvbXBvc2VkICovKSxcbiAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiAhIShmbGFncyAmIDEgLyogQ2FuY2VsbGFibGUgKi8pLFxuICAgICAgICAgICAgICAgIGRldGFpbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuY29uc3QgZW1pdEV2ZW50ID0gKGVsbSwgbmFtZSwgb3B0cykgPT4ge1xuICAgIGNvbnN0IGV2ID0gcGx0LmNlKG5hbWUsIG9wdHMpO1xuICAgIGVsbS5kaXNwYXRjaEV2ZW50KGV2KTtcbiAgICByZXR1cm4gZXY7XG59O1xuY29uc3QgYXR0YWNoVG9BbmNlc3RvciA9IChob3N0UmVmLCBhbmNlc3RvckNvbXBvbmVudCkgPT4ge1xuICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcgJiYgYW5jZXN0b3JDb21wb25lbnQgJiYgIWhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQgJiYgYW5jZXN0b3JDb21wb25lbnRbJ3MtcCddKSB7XG4gICAgICAgIGFuY2VzdG9yQ29tcG9uZW50WydzLXAnXS5wdXNoKG5ldyBQcm9taXNlKHIgPT4gKGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQgPSByKSkpO1xuICAgIH1cbn07XG5jb25zdCBzY2hlZHVsZVVwZGF0ZSA9IChob3N0UmVmLCBpc0luaXRpYWxMb2FkKSA9PiB7XG4gICAgaWYgKEJVSUxELnRhc2tRdWV1ZSAmJiBCVUlMRC51cGRhdGFibGUpIHtcbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDE2IC8qIGlzUXVldWVkRm9yVXBkYXRlICovO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nICYmIGhvc3RSZWYuJGZsYWdzJCAmIDQgLyogaXNXYWl0aW5nRm9yQ2hpbGRyZW4gKi8pIHtcbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDUxMiAvKiBuZWVkc1JlcmVuZGVyICovO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGF0dGFjaFRvQW5jZXN0b3IoaG9zdFJlZiwgaG9zdFJlZi4kYW5jZXN0b3JDb21wb25lbnQkKTtcbiAgICAvLyB0aGVyZSBpcyBubyBhbmNlc3RvciBjb21wb25lbnQgb3IgdGhlIGFuY2VzdG9yIGNvbXBvbmVudFxuICAgIC8vIGhhcyBhbHJlYWR5IGZpcmVkIG9mZiBpdHMgbGlmZWN5Y2xlIHVwZGF0ZSB0aGVuXG4gICAgLy8gZmlyZSBvZmYgdGhlIGluaXRpYWwgdXBkYXRlXG4gICAgY29uc3QgZGlzcGF0Y2ggPSAoKSA9PiBkaXNwYXRjaEhvb2tzKGhvc3RSZWYsIGlzSW5pdGlhbExvYWQpO1xuICAgIHJldHVybiBCVUlMRC50YXNrUXVldWUgPyB3cml0ZVRhc2soZGlzcGF0Y2gpIDogZGlzcGF0Y2goKTtcbn07XG5jb25zdCBkaXNwYXRjaEhvb2tzID0gKGhvc3RSZWYsIGlzSW5pdGlhbExvYWQpID0+IHtcbiAgICBjb25zdCBlbG0gPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gICAgY29uc3QgZW5kU2NoZWR1bGUgPSBjcmVhdGVUaW1lKCdzY2hlZHVsZVVwZGF0ZScsIGhvc3RSZWYuJGNtcE1ldGEkLiR0YWdOYW1lJCk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBCVUlMRC5sYXp5TG9hZCA/IGhvc3RSZWYuJGxhenlJbnN0YW5jZSQgOiBlbG07XG4gICAgbGV0IHByb21pc2U7XG4gICAgaWYgKGlzSW5pdGlhbExvYWQpIHtcbiAgICAgICAgaWYgKEJVSUxELmxhenlMb2FkICYmIEJVSUxELmhvc3RMaXN0ZW5lcikge1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDI1NiAvKiBpc0xpc3RlblJlYWR5ICovO1xuICAgICAgICAgICAgaWYgKGhvc3RSZWYuJHF1ZXVlZExpc3RlbmVycyQpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRxdWV1ZWRMaXN0ZW5lcnMkLm1hcCgoW21ldGhvZE5hbWUsIGV2ZW50XSkgPT4gc2FmZUNhbGwoaW5zdGFuY2UsIG1ldGhvZE5hbWUsIGV2ZW50KSk7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kcXVldWVkTGlzdGVuZXJzJCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudFdpbGxMb2FkJyk7XG4gICAgICAgIGlmIChCVUlMRC5jbXBXaWxsTG9hZCkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50V2lsbExvYWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcbiAgICAgICAgaWYgKEJVSUxELmNtcFdpbGxVcGRhdGUpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbWl0TGlmZWN5Y2xlRXZlbnQoZWxtLCAnY29tcG9uZW50V2lsbFJlbmRlcicpO1xuICAgIGlmIChCVUlMRC5jbXBXaWxsUmVuZGVyKSB7XG4gICAgICAgIHByb21pc2UgPSB0aGVuKHByb21pc2UsICgpID0+IHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50V2lsbFJlbmRlcicpKTtcbiAgICB9XG4gICAgZW5kU2NoZWR1bGUoKTtcbiAgICByZXR1cm4gdGhlbihwcm9taXNlLCAoKSA9PiB1cGRhdGVDb21wb25lbnQoaG9zdFJlZiwgaW5zdGFuY2UsIGlzSW5pdGlhbExvYWQpKTtcbn07XG5jb25zdCB1cGRhdGVDb21wb25lbnQgPSBhc3luYyAoaG9zdFJlZiwgaW5zdGFuY2UsIGlzSW5pdGlhbExvYWQpID0+IHtcbiAgICAvLyB1cGRhdGVDb21wb25lbnRcbiAgICBjb25zdCBlbG0gPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gICAgY29uc3QgZW5kVXBkYXRlID0gY3JlYXRlVGltZSgndXBkYXRlJywgaG9zdFJlZi4kY21wTWV0YSQuJHRhZ05hbWUkKTtcbiAgICBjb25zdCByYyA9IGVsbVsncy1yYyddO1xuICAgIGlmIChCVUlMRC5zdHlsZSAmJiBpc0luaXRpYWxMb2FkKSB7XG4gICAgICAgIC8vIERPTSBXUklURSFcbiAgICAgICAgYXR0YWNoU3R5bGVzKGhvc3RSZWYpO1xuICAgIH1cbiAgICBjb25zdCBlbmRSZW5kZXIgPSBjcmVhdGVUaW1lKCdyZW5kZXInLCBob3N0UmVmLiRjbXBNZXRhJC4kdGFnTmFtZSQpO1xuICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMTAyNCAvKiBkZXZPblJlbmRlciAqLztcbiAgICB9XG4gICAgaWYgKEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlKSB7XG4gICAgICAgIGF3YWl0IGNhbGxSZW5kZXIoaG9zdFJlZiwgaW5zdGFuY2UsIGVsbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYWxsUmVuZGVyKGhvc3RSZWYsIGluc3RhbmNlLCBlbG0pO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuY3NzVmFyU2hpbSAmJiBwbHQuJGNzc1NoaW0kKSB7XG4gICAgICAgIHBsdC4kY3NzU2hpbSQudXBkYXRlSG9zdChlbG0pO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgaG9zdFJlZi4kcmVuZGVyQ291bnQkKys7XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+MTAyNCAvKiBkZXZPblJlbmRlciAqLztcbiAgICB9XG4gICAgaWYgKEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBtYW51YWxseSBjb25uZWN0ZWQgY2hpbGQgY29tcG9uZW50cyBkdXJpbmcgc2VydmVyLXNpZGUgaHlkcmF0ZVxuICAgICAgICAgICAgc2VydmVyU2lkZUNvbm5lY3RlZChlbG0pO1xuICAgICAgICAgICAgaWYgKGlzSW5pdGlhbExvYWQpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2luZyBvbmx5IGR1cmluZyBzZXJ2ZXItc2lkZSBoeWRyYXRlXG4gICAgICAgICAgICAgICAgaWYgKGhvc3RSZWYuJGNtcE1ldGEkLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtWydzLWVuJ10gPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaG9zdFJlZi4kY21wTWV0YSQuJGZsYWdzJCAmIDIgLyogc2NvcGVkQ3NzRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgICAgICAgICAgICBlbG1bJ3MtZW4nXSA9ICdjJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlLCBlbG0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcgJiYgcmMpIHtcbiAgICAgICAgLy8gb2ssIHNvIHR1cm5zIG91dCB0aGVyZSBhcmUgc29tZSBjaGlsZCBob3N0IGVsZW1lbnRzXG4gICAgICAgIC8vIHdhaXRpbmcgb24gdGhpcyBwYXJlbnQgZWxlbWVudCB0byBsb2FkXG4gICAgICAgIC8vIGxldCdzIGZpcmUgb2ZmIGFsbCB1cGRhdGUgY2FsbGJhY2tzIHdhaXRpbmdcbiAgICAgICAgcmMubWFwKGNiID0+IGNiKCkpO1xuICAgICAgICBlbG1bJ3MtcmMnXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZW5kUmVuZGVyKCk7XG4gICAgZW5kVXBkYXRlKCk7XG4gICAgaWYgKEJVSUxELmFzeW5jTG9hZGluZykge1xuICAgICAgICBjb25zdCBjaGlsZHJlblByb21pc2VzID0gZWxtWydzLXAnXTtcbiAgICAgICAgY29uc3QgcG9zdFVwZGF0ZSA9ICgpID0+IHBvc3RVcGRhdGVDb21wb25lbnQoaG9zdFJlZik7XG4gICAgICAgIGlmIChjaGlsZHJlblByb21pc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcG9zdFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgUHJvbWlzZS5hbGwoY2hpbGRyZW5Qcm9taXNlcykudGhlbihwb3N0VXBkYXRlKTtcbiAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSA0IC8qIGlzV2FpdGluZ0ZvckNoaWxkcmVuICovO1xuICAgICAgICAgICAgY2hpbGRyZW5Qcm9taXNlcy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwb3N0VXBkYXRlQ29tcG9uZW50KGhvc3RSZWYpO1xuICAgIH1cbn07XG5jb25zdCBjYWxsUmVuZGVyID0gKGhvc3RSZWYsIGluc3RhbmNlLCBlbG0pID0+IHtcbiAgICAvLyBpbiBvcmRlciBmb3IgYnVuZGxlcnMgdG8gY29ycmVjdGx5IHRyZWVzaGFrZSB0aGUgQlVJTEQgb2JqZWN0XG4gICAgLy8gd2UgbmVlZCB0byBlbnN1cmUgQlVJTEQgaXMgbm90IGRlb3B0aW1pemVkIHdpdGhpbiBhIHRyeS9jYXRjaFxuICAgIC8vIGh0dHBzOi8vcm9sbHVwanMub3JnL2d1aWRlL2VuLyN0cmVlc2hha2UgdHJ5Q2F0Y2hEZW9wdGltaXphdGlvblxuICAgIGNvbnN0IGFsbFJlbmRlckZuID0gQlVJTEQuYWxsUmVuZGVyRm4gPyB0cnVlIDogZmFsc2U7XG4gICAgY29uc3QgbGF6eUxvYWQgPSBCVUlMRC5sYXp5TG9hZCA/IHRydWUgOiBmYWxzZTtcbiAgICBjb25zdCB0YXNrUXVldWUgPSBCVUlMRC50YXNrUXVldWUgPyB0cnVlIDogZmFsc2U7XG4gICAgY29uc3QgdXBkYXRhYmxlID0gQlVJTEQudXBkYXRhYmxlID8gdHJ1ZSA6IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIHJlbmRlcmluZ1JlZiA9IGluc3RhbmNlO1xuICAgICAgICBpbnN0YW5jZSA9IGFsbFJlbmRlckZuID8gaW5zdGFuY2UucmVuZGVyKCkgOiBpbnN0YW5jZS5yZW5kZXIgJiYgaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICAgIGlmICh1cGRhdGFibGUgJiYgdGFza1F1ZXVlKSB7XG4gICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgJj0gfjE2IC8qIGlzUXVldWVkRm9yVXBkYXRlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGFibGUgfHwgbGF6eUxvYWQpIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAyIC8qIGhhc1JlbmRlcmVkICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5oYXNSZW5kZXJGbiB8fCBCVUlMRC5yZWZsZWN0KSB7XG4gICAgICAgICAgICBpZiAoQlVJTEQudmRvbVJlbmRlciB8fCBCVUlMRC5yZWZsZWN0KSB7XG4gICAgICAgICAgICAgICAgLy8gbG9va3MgbGlrZSB3ZSd2ZSBnb3QgY2hpbGQgbm9kZXMgdG8gcmVuZGVyIGludG8gdGhpcyBob3N0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBvciB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgY3NzIGNsYXNzL2F0dHJzIG9uIHRoZSBob3N0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBET00gV1JJVEUhXG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaW5zdGFuY2UpLnRoZW4odmFsdWUgPT4gcmVuZGVyVmRvbShob3N0UmVmLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyVmRvbShob3N0UmVmLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxtLnRleHRDb250ZW50ID0gaW5zdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZUVycm9yKGUsIGhvc3RSZWYuJGhvc3RFbGVtZW50JCk7XG4gICAgfVxuICAgIHJlbmRlcmluZ1JlZiA9IG51bGw7XG4gICAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgZ2V0UmVuZGVyaW5nUmVmID0gKCkgPT4gcmVuZGVyaW5nUmVmO1xuY29uc3QgcG9zdFVwZGF0ZUNvbXBvbmVudCA9IChob3N0UmVmKSA9PiB7XG4gICAgY29uc3QgdGFnTmFtZSA9IGhvc3RSZWYuJGNtcE1ldGEkLiR0YWdOYW1lJDtcbiAgICBjb25zdCBlbG0gPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gICAgY29uc3QgZW5kUG9zdFVwZGF0ZSA9IGNyZWF0ZVRpbWUoJ3Bvc3RVcGRhdGUnLCB0YWdOYW1lKTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IEJVSUxELmxhenlMb2FkID8gaG9zdFJlZi4kbGF6eUluc3RhbmNlJCA6IGVsbTtcbiAgICBjb25zdCBhbmNlc3RvckNvbXBvbmVudCA9IGhvc3RSZWYuJGFuY2VzdG9yQ29tcG9uZW50JDtcbiAgICBpZiAoQlVJTEQuY21wRGlkUmVuZGVyKSB7XG4gICAgICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDEwMjQgLyogZGV2T25SZW5kZXIgKi87XG4gICAgICAgIH1cbiAgICAgICAgc2FmZUNhbGwoaW5zdGFuY2UsICdjb21wb25lbnREaWRSZW5kZXInKTtcbiAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgJj0gfjEwMjQgLyogZGV2T25SZW5kZXIgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudERpZFJlbmRlcicpO1xuICAgIGlmICghKGhvc3RSZWYuJGZsYWdzJCAmIDY0IC8qIGhhc0xvYWRlZENvbXBvbmVudCAqLykpIHtcbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDY0IC8qIGhhc0xvYWRlZENvbXBvbmVudCAqLztcbiAgICAgICAgaWYgKEJVSUxELmFzeW5jTG9hZGluZyAmJiBCVUlMRC5jc3NBbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgLy8gRE9NIFdSSVRFIVxuICAgICAgICAgICAgYWRkSHlkcmF0ZWRGbGFnKGVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELmNtcERpZExvYWQpIHtcbiAgICAgICAgICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAyMDQ4IC8qIGRldk9uRGlkTG9hZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50RGlkTG9hZCcpO1xuICAgICAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4yMDQ4IC8qIGRldk9uRGlkTG9hZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbWl0TGlmZWN5Y2xlRXZlbnQoZWxtLCAnY29tcG9uZW50RGlkTG9hZCcpO1xuICAgICAgICBlbmRQb3N0VXBkYXRlKCk7XG4gICAgICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcpIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJG9uUmVhZHlSZXNvbHZlJChlbG0pO1xuICAgICAgICAgICAgaWYgKCFhbmNlc3RvckNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGFwcERpZExvYWQodGFnTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChCVUlMRC5jbXBEaWRVcGRhdGUpIHtcbiAgICAgICAgICAgIC8vIHdlJ3ZlIGFscmVhZHkgbG9hZGVkIHRoaXMgY29tcG9uZW50XG4gICAgICAgICAgICAvLyBmaXJlIG9mZiB0aGUgdXNlcidzIGNvbXBvbmVudERpZFVwZGF0ZSBtZXRob2QgKGlmIG9uZSB3YXMgcHJvdmlkZWQpXG4gICAgICAgICAgICAvLyBjb21wb25lbnREaWRVcGRhdGUgcnVucyBBRlRFUiByZW5kZXIoKSBoYXMgYmVlbiBjYWxsZWRcbiAgICAgICAgICAgIC8vIGFuZCBhbGwgY2hpbGQgY29tcG9uZW50cyBoYXZlIGZpbmlzaGVkIHVwZGF0aW5nXG4gICAgICAgICAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMTAyNCAvKiBkZXZPblJlbmRlciAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50RGlkVXBkYXRlJyk7XG4gICAgICAgICAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgJj0gfjEwMjQgLyogZGV2T25SZW5kZXIgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICBlbmRQb3N0VXBkYXRlKCk7XG4gICAgfVxuICAgIGlmIChCVUlMRC5ob3RNb2R1bGVSZXBsYWNlbWVudCkge1xuICAgICAgICBlbG1bJ3MtaG1yLWxvYWQnXSAmJiBlbG1bJ3MtaG1yLWxvYWQnXSgpO1xuICAgIH1cbiAgICBpZiAoQlVJTEQubWV0aG9kICYmIEJVSUxELmxhenlMb2FkKSB7XG4gICAgICAgIGhvc3RSZWYuJG9uSW5zdGFuY2VSZXNvbHZlJChlbG0pO1xuICAgIH1cbiAgICAvLyBsb2FkIGV2ZW50cyBmaXJlIGZyb20gYm90dG9tIHRvIHRvcFxuICAgIC8vIHRoZSBkZWVwZXN0IGVsZW1lbnRzIGxvYWQgZmlyc3QgdGhlbiBidWJibGVzIHVwXG4gICAgaWYgKEJVSUxELmFzeW5jTG9hZGluZykge1xuICAgICAgICBpZiAoaG9zdFJlZi4kb25SZW5kZXJSZXNvbHZlJCkge1xuICAgICAgICAgICAgaG9zdFJlZi4kb25SZW5kZXJSZXNvbHZlJCgpO1xuICAgICAgICAgICAgaG9zdFJlZi4kb25SZW5kZXJSZXNvbHZlJCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9zdFJlZi4kZmxhZ3MkICYgNTEyIC8qIG5lZWRzUmVyZW5kZXIgKi8pIHtcbiAgICAgICAgICAgIG5leHRUaWNrKCgpID0+IHNjaGVkdWxlVXBkYXRlKGhvc3RSZWYsIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4oNCAvKiBpc1dhaXRpbmdGb3JDaGlsZHJlbiAqLyB8IDUxMiAvKiBuZWVkc1JlcmVuZGVyICovKTtcbiAgICB9XG4gICAgLy8gKCDigKJf4oCiKVxuICAgIC8vICgg4oCiX+KAoik+4oyQ4pagLeKWoFxuICAgIC8vICjijJDilqBf4pagKVxufTtcbmNvbnN0IGZvcmNlVXBkYXRlID0gKHJlZikgPT4ge1xuICAgIGlmIChCVUlMRC51cGRhdGFibGUpIHtcbiAgICAgICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYocmVmKTtcbiAgICAgICAgY29uc3QgaXNDb25uZWN0ZWQgPSBob3N0UmVmLiRob3N0RWxlbWVudCQuaXNDb25uZWN0ZWQ7XG4gICAgICAgIGlmIChpc0Nvbm5lY3RlZCAmJiAoaG9zdFJlZi4kZmxhZ3MkICYgKDIgLyogaGFzUmVuZGVyZWQgKi8gfCAxNiAvKiBpc1F1ZXVlZEZvclVwZGF0ZSAqLykpID09PSAyIC8qIGhhc1JlbmRlcmVkICovKSB7XG4gICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZShob3N0UmVmLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJucyBcInRydWVcIiB3aGVuIHRoZSBmb3JjZWQgdXBkYXRlIHdhcyBzdWNjZXNzZnVsbHkgc2NoZWR1bGVkXG4gICAgICAgIHJldHVybiBpc0Nvbm5lY3RlZDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmNvbnN0IGFwcERpZExvYWQgPSAod2hvKSA9PiB7XG4gICAgLy8gb24gYXBwbG9hZFxuICAgIC8vIHdlIGhhdmUgZmluaXNoIHRoZSBmaXJzdCBiaWcgaW5pdGlhbCByZW5kZXJcbiAgICBpZiAoQlVJTEQuY3NzQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgYWRkSHlkcmF0ZWRGbGFnKGRvYy5kb2N1bWVudEVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuYXN5bmNRdWV1ZSkge1xuICAgICAgICBwbHQuJGZsYWdzJCB8PSAyIC8qIGFwcExvYWRlZCAqLztcbiAgICB9XG4gICAgbmV4dFRpY2soKCkgPT4gZW1pdEV2ZW50KHdpbiwgJ2FwcGxvYWQnLCB7IGRldGFpbDogeyBuYW1lc3BhY2U6IE5BTUVTUEFDRSB9IH0pKTtcbiAgICBpZiAoQlVJTEQucHJvZmlsZSAmJiBwZXJmb3JtYW5jZS5tZWFzdXJlKSB7XG4gICAgICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoYFtTdGVuY2lsXSAke05BTUVTUEFDRX0gaW5pdGlhbCBsb2FkIChieSAke3dob30pYCwgJ3N0OmFwcDpzdGFydCcpO1xuICAgIH1cbn07XG5jb25zdCBzYWZlQ2FsbCA9IChpbnN0YW5jZSwgbWV0aG9kLCBhcmcpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2VbbWV0aG9kXSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlW21ldGhvZF0oYXJnKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZUVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuY29uc3QgdGhlbiA9IChwcm9taXNlLCB0aGVuRm4pID0+IHtcbiAgICByZXR1cm4gcHJvbWlzZSAmJiBwcm9taXNlLnRoZW4gPyBwcm9taXNlLnRoZW4odGhlbkZuKSA6IHRoZW5GbigpO1xufTtcbmNvbnN0IGVtaXRMaWZlY3ljbGVFdmVudCA9IChlbG0sIGxpZmVjeWNsZU5hbWUpID0+IHtcbiAgICBpZiAoQlVJTEQubGlmZWN5Y2xlRE9NRXZlbnRzKSB7XG4gICAgICAgIGVtaXRFdmVudChlbG0sICdzdGVuY2lsXycgKyBsaWZlY3ljbGVOYW1lLCB7XG4gICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgY29tcG9zZWQ6IHRydWUsXG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IE5BTUVTUEFDRSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5jb25zdCBhZGRIeWRyYXRlZEZsYWcgPSAoZWxtKSA9PiAoQlVJTEQuaHlkcmF0ZWRDbGFzcyA/IGVsbS5jbGFzc0xpc3QuYWRkKCdoeWRyYXRlZCcpIDogQlVJTEQuaHlkcmF0ZWRBdHRyaWJ1dGUgPyBlbG0uc2V0QXR0cmlidXRlKCdoeWRyYXRlZCcsICcnKSA6IHVuZGVmaW5lZCk7XG5jb25zdCBzZXJ2ZXJTaWRlQ29ubmVjdGVkID0gKGVsbSkgPT4ge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gZWxtLmNoaWxkcmVuO1xuICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkRWxtID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkRWxtLmNvbm5lY3RlZENhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRFbG0uY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcnZlclNpZGVDb25uZWN0ZWQoY2hpbGRFbG0pO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGluaXRpYWxpemVDbGllbnRIeWRyYXRlID0gKGhvc3RFbG0sIHRhZ05hbWUsIGhvc3RJZCwgaG9zdFJlZikgPT4ge1xuICAgIGNvbnN0IGVuZEh5ZHJhdGUgPSBjcmVhdGVUaW1lKCdoeWRyYXRlQ2xpZW50JywgdGFnTmFtZSk7XG4gICAgY29uc3Qgc2hhZG93Um9vdCA9IGhvc3RFbG0uc2hhZG93Um9vdDtcbiAgICBjb25zdCBjaGlsZFJlbmRlck5vZGVzID0gW107XG4gICAgY29uc3Qgc2xvdE5vZGVzID0gW107XG4gICAgY29uc3Qgc2hhZG93Um9vdE5vZGVzID0gQlVJTEQuc2hhZG93RG9tICYmIHNoYWRvd1Jvb3QgPyBbXSA6IG51bGw7XG4gICAgY29uc3Qgdm5vZGUgPSAoaG9zdFJlZi4kdm5vZGUkID0gbmV3Vk5vZGUodGFnTmFtZSwgbnVsbCkpO1xuICAgIGlmICghcGx0LiRvcmdMb2NOb2RlcyQpIHtcbiAgICAgICAgaW5pdGlhbGl6ZURvY3VtZW50SHlkcmF0ZShkb2MuYm9keSwgKHBsdC4kb3JnTG9jTm9kZXMkID0gbmV3IE1hcCgpKSk7XG4gICAgfVxuICAgIGhvc3RFbG1bSFlEUkFURV9JRF0gPSBob3N0SWQ7XG4gICAgaG9zdEVsbS5yZW1vdmVBdHRyaWJ1dGUoSFlEUkFURV9JRCk7XG4gICAgY2xpZW50SHlkcmF0ZSh2bm9kZSwgY2hpbGRSZW5kZXJOb2Rlcywgc2xvdE5vZGVzLCBzaGFkb3dSb290Tm9kZXMsIGhvc3RFbG0sIGhvc3RFbG0sIGhvc3RJZCk7XG4gICAgY2hpbGRSZW5kZXJOb2Rlcy5tYXAoYyA9PiB7XG4gICAgICAgIGNvbnN0IG9yZ0xvY2F0aW9uSWQgPSBjLiRob3N0SWQkICsgJy4nICsgYy4kbm9kZUlkJDtcbiAgICAgICAgY29uc3Qgb3JnTG9jYXRpb25Ob2RlID0gcGx0LiRvcmdMb2NOb2RlcyQuZ2V0KG9yZ0xvY2F0aW9uSWQpO1xuICAgICAgICBjb25zdCBub2RlID0gYy4kZWxtJDtcbiAgICAgICAgaWYgKG9yZ0xvY2F0aW9uTm9kZSAmJiBzdXBwb3J0c1NoYWRvdyAmJiBvcmdMb2NhdGlvbk5vZGVbJ3MtZW4nXSA9PT0gJycpIHtcbiAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBvcmdMb2NhdGlvbk5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgbm9kZVsncy1obiddID0gdGFnTmFtZTtcbiAgICAgICAgICAgIGlmIChvcmdMb2NhdGlvbk5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlWydzLW9sJ10gPSBvcmdMb2NhdGlvbk5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZVsncy1vbCddWydzLW5yJ10gPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBsdC4kb3JnTG9jTm9kZXMkLmRlbGV0ZShvcmdMb2NhdGlvbklkKTtcbiAgICB9KTtcbiAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmIHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgc2hhZG93Um9vdE5vZGVzLm1hcChzaGFkb3dSb290Tm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoc2hhZG93Um9vdE5vZGUpIHtcbiAgICAgICAgICAgICAgICBzaGFkb3dSb290LmFwcGVuZENoaWxkKHNoYWRvd1Jvb3ROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVuZEh5ZHJhdGUoKTtcbn07XG5jb25zdCBjbGllbnRIeWRyYXRlID0gKHBhcmVudFZOb2RlLCBjaGlsZFJlbmRlck5vZGVzLCBzbG90Tm9kZXMsIHNoYWRvd1Jvb3ROb2RlcywgaG9zdEVsbSwgbm9kZSwgaG9zdElkKSA9PiB7XG4gICAgbGV0IGNoaWxkTm9kZVR5cGU7XG4gICAgbGV0IGNoaWxkSWRTcGx0O1xuICAgIGxldCBjaGlsZFZOb2RlO1xuICAgIGxldCBpO1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgIGNoaWxkTm9kZVR5cGUgPSBub2RlLmdldEF0dHJpYnV0ZShIWURSQVRFX0NISUxEX0lEKTtcbiAgICAgICAgaWYgKGNoaWxkTm9kZVR5cGUpIHtcbiAgICAgICAgICAgIC8vIGdvdCB0aGUgbm9kZSBkYXRhIGZyb20gdGhlIGVsZW1lbnQncyBhdHRyaWJ1dGVcbiAgICAgICAgICAgIC8vIGAke2hvc3RJZH0uJHtub2RlSWR9LiR7ZGVwdGh9LiR7aW5kZXh9YFxuICAgICAgICAgICAgY2hpbGRJZFNwbHQgPSBjaGlsZE5vZGVUeXBlLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBpZiAoY2hpbGRJZFNwbHRbMF0gPT09IGhvc3RJZCB8fCBjaGlsZElkU3BsdFswXSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRWTm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgJGZsYWdzJDogMCxcbiAgICAgICAgICAgICAgICAgICAgJGhvc3RJZCQ6IGNoaWxkSWRTcGx0WzBdLFxuICAgICAgICAgICAgICAgICAgICAkbm9kZUlkJDogY2hpbGRJZFNwbHRbMV0sXG4gICAgICAgICAgICAgICAgICAgICRkZXB0aCQ6IGNoaWxkSWRTcGx0WzJdLFxuICAgICAgICAgICAgICAgICAgICAkaW5kZXgkOiBjaGlsZElkU3BsdFszXSxcbiAgICAgICAgICAgICAgICAgICAgJHRhZyQ6IG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICAkZWxtJDogbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgJGF0dHJzJDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgJGNoaWxkcmVuJDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgJGtleSQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICRuYW1lJDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgJHRleHQkOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2hpbGRSZW5kZXJOb2Rlcy5wdXNoKGNoaWxkVk5vZGUpO1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKEhZRFJBVEVfQ0hJTERfSUQpO1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBuZXcgY2hpbGQgdm5vZGVcbiAgICAgICAgICAgICAgICAvLyBzbyBlbnN1cmUgaXRzIHBhcmVudCB2bm9kZSBoYXMgdGhlIHZjaGlsZHJlbiBhcnJheVxuICAgICAgICAgICAgICAgIGlmICghcGFyZW50Vk5vZGUuJGNoaWxkcmVuJCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRWTm9kZS4kY2hpbGRyZW4kID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFkZCBvdXIgY2hpbGQgdm5vZGUgdG8gYSBzcGVjaWZpYyBpbmRleCBvZiB0aGUgdm5vZGUncyBjaGlsZHJlblxuICAgICAgICAgICAgICAgIHBhcmVudFZOb2RlLiRjaGlsZHJlbiRbY2hpbGRWTm9kZS4kaW5kZXgkXSA9IGNoaWxkVk5vZGU7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBub3cgdGhlIG5ldyBwYXJlbnQgdm5vZGUgZm9yIGFsbCB0aGUgbmV4dCBjaGlsZCBjaGVja3NcbiAgICAgICAgICAgICAgICBwYXJlbnRWTm9kZSA9IGNoaWxkVk5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHNoYWRvd1Jvb3ROb2RlcyAmJiBjaGlsZFZOb2RlLiRkZXB0aCQgPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICBzaGFkb3dSb290Tm9kZXNbY2hpbGRWTm9kZS4kaW5kZXgkXSA9IGNoaWxkVk5vZGUuJGVsbSQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGRyaWxsIGRvd24sIGVuZCB0byBzdGFydCBzbyB3ZSBjYW4gcmVtb3ZlIG5vZGVzXG4gICAgICAgIGZvciAoaSA9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY2xpZW50SHlkcmF0ZShwYXJlbnRWTm9kZSwgY2hpbGRSZW5kZXJOb2Rlcywgc2xvdE5vZGVzLCBzaGFkb3dSb290Tm9kZXMsIGhvc3RFbG0sIG5vZGUuY2hpbGROb2Rlc1tpXSwgaG9zdElkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICAvLyBrZWVwIGRyaWxsaW5nIGRvd24gdGhyb3VnaCB0aGUgc2hhZG93IHJvb3Qgbm9kZXNcbiAgICAgICAgICAgIGZvciAoaSA9IG5vZGUuc2hhZG93Um9vdC5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgY2xpZW50SHlkcmF0ZShwYXJlbnRWTm9kZSwgY2hpbGRSZW5kZXJOb2Rlcywgc2xvdE5vZGVzLCBzaGFkb3dSb290Tm9kZXMsIGhvc3RFbG0sIG5vZGUuc2hhZG93Um9vdC5jaGlsZE5vZGVzW2ldLCBob3N0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggLyogQ29tbWVudE5vZGUgKi8pIHtcbiAgICAgICAgLy8gYCR7Q09NTUVOVF9UWVBFfS4ke2hvc3RJZH0uJHtub2RlSWR9LiR7ZGVwdGh9LiR7aW5kZXh9YFxuICAgICAgICBjaGlsZElkU3BsdCA9IG5vZGUubm9kZVZhbHVlLnNwbGl0KCcuJyk7XG4gICAgICAgIGlmIChjaGlsZElkU3BsdFsxXSA9PT0gaG9zdElkIHx8IGNoaWxkSWRTcGx0WzFdID09PSAnMCcpIHtcbiAgICAgICAgICAgIC8vIGNvbW1lbnQgbm9kZSBmb3IgZWl0aGVyIHRoZSBob3N0IGlkIG9yIGEgMCBob3N0IGlkXG4gICAgICAgICAgICBjaGlsZE5vZGVUeXBlID0gY2hpbGRJZFNwbHRbMF07XG4gICAgICAgICAgICBjaGlsZFZOb2RlID0ge1xuICAgICAgICAgICAgICAgICRmbGFncyQ6IDAsXG4gICAgICAgICAgICAgICAgJGhvc3RJZCQ6IGNoaWxkSWRTcGx0WzFdLFxuICAgICAgICAgICAgICAgICRub2RlSWQkOiBjaGlsZElkU3BsdFsyXSxcbiAgICAgICAgICAgICAgICAkZGVwdGgkOiBjaGlsZElkU3BsdFszXSxcbiAgICAgICAgICAgICAgICAkaW5kZXgkOiBjaGlsZElkU3BsdFs0XSxcbiAgICAgICAgICAgICAgICAkZWxtJDogbm9kZSxcbiAgICAgICAgICAgICAgICAkYXR0cnMkOiBudWxsLFxuICAgICAgICAgICAgICAgICRjaGlsZHJlbiQ6IG51bGwsXG4gICAgICAgICAgICAgICAgJGtleSQ6IG51bGwsXG4gICAgICAgICAgICAgICAgJG5hbWUkOiBudWxsLFxuICAgICAgICAgICAgICAgICR0YWckOiBudWxsLFxuICAgICAgICAgICAgICAgICR0ZXh0JDogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlVHlwZSA9PT0gVEVYVF9OT0RFX0lEKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRWTm9kZS4kZWxtJCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkVk5vZGUuJGVsbSQgJiYgY2hpbGRWTm9kZS4kZWxtJC5ub2RlVHlwZSA9PT0gMyAvKiBUZXh0Tm9kZSAqLykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFZOb2RlLiR0ZXh0JCA9IGNoaWxkVk5vZGUuJGVsbSQudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkUmVuZGVyTm9kZXMucHVzaChjaGlsZFZOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSB0ZXh0IGNvbW1lbnQgc2luY2UgaXQncyBubyBsb25nZXIgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50Vk5vZGUuJGNoaWxkcmVuJCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Vk5vZGUuJGNoaWxkcmVuJCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFZOb2RlLiRjaGlsZHJlbiRbY2hpbGRWTm9kZS4kaW5kZXgkXSA9IGNoaWxkVk5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaGFkb3dSb290Tm9kZXMgJiYgY2hpbGRWTm9kZS4kZGVwdGgkID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd1Jvb3ROb2Rlc1tjaGlsZFZOb2RlLiRpbmRleCRdID0gY2hpbGRWTm9kZS4kZWxtJDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkVk5vZGUuJGhvc3RJZCQgPT09IGhvc3RJZCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgY29tbWVudCBub2RlIGlzIHNwZWNpZmNhbGx5IGZvciB0aGlzIGhvc3QgaWRcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlVHlwZSA9PT0gU0xPVF9OT0RFX0lEKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGAke1NMT1RfTk9ERV9JRH0uJHtob3N0SWR9LiR7bm9kZUlkfS4ke2RlcHRofS4ke2luZGV4fS4ke3Nsb3ROYW1lfWA7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVk5vZGUuJHRhZyQgPSAnc2xvdCc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZElkU3BsdFs1XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVsncy1zbiddID0gY2hpbGRWTm9kZS4kbmFtZSQgPSBjaGlsZElkU3BsdFs1XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVbJ3Mtc24nXSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGVbJ3Mtc3InXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChCVUlMRC5zaGFkb3dEb20gJiYgc2hhZG93Um9vdE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBicm93c2VyIHN1cHBvcnQgc2hhZG93Um9vdCBhbmQgdGhpcyBpcyBhIHNoYWRvdyBkb20gY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYW4gYWN0dWFsIHNsb3QgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRWTm9kZS4kZWxtJCA9IGRvYy5jcmVhdGVFbGVtZW50KGNoaWxkVk5vZGUuJHRhZyQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkVk5vZGUuJG5hbWUkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBzbG90IG5hbWUgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRWTm9kZS4kZWxtJC5zZXRBdHRyaWJ1dGUoJ25hbWUnLCBjaGlsZFZOb2RlLiRuYW1lJCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlcnQgdGhlIG5ldyBzbG90IGVsZW1lbnQgYmVmb3JlIHRoZSBzbG90IGNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGRWTm9kZS4kZWxtJCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIHNsb3QgY29tbWVudCBzaW5jZSBpdCdzIG5vdCBuZWVkZWQgZm9yIHNoYWRvd1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZFZOb2RlLiRkZXB0aCQgPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd1Jvb3ROb2Rlc1tjaGlsZFZOb2RlLiRpbmRleCRdID0gY2hpbGRWTm9kZS4kZWxtJDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzbG90Tm9kZXMucHVzaChjaGlsZFZOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRWTm9kZS4kY2hpbGRyZW4kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRWTm9kZS4kY2hpbGRyZW4kID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Vk5vZGUuJGNoaWxkcmVuJFtjaGlsZFZOb2RlLiRpbmRleCRdID0gY2hpbGRWTm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGROb2RlVHlwZSA9PT0gQ09OVEVOVF9SRUZfSUQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYCR7Q09OVEVOVF9SRUZfSUR9LiR7aG9zdElkfWA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChCVUlMRC5zaGFkb3dEb20gJiYgc2hhZG93Um9vdE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGNvbnRlbnQgcmVmIGNvbW1lbnQgc2luY2UgaXQncyBub3QgbmVlZGVkIGZvciBzaGFkb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RFbG1bJ3MtY3InXSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlWydzLWNuJ10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcmVudFZOb2RlICYmIHBhcmVudFZOb2RlLiR0YWckID09PSAnc3R5bGUnKSB7XG4gICAgICAgIGNvbnN0IHZub2RlID0gbmV3Vk5vZGUobnVsbCwgbm9kZS50ZXh0Q29udGVudCk7XG4gICAgICAgIHZub2RlLiRlbG0kID0gbm9kZTtcbiAgICAgICAgdm5vZGUuJGluZGV4JCA9ICcwJztcbiAgICAgICAgcGFyZW50Vk5vZGUuJGNoaWxkcmVuJCA9IFt2bm9kZV07XG4gICAgfVxufTtcbmNvbnN0IGluaXRpYWxpemVEb2N1bWVudEh5ZHJhdGUgPSAobm9kZSwgb3JnTG9jTm9kZXMpID0+IHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLykge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpbml0aWFsaXplRG9jdW1lbnRIeWRyYXRlKG5vZGUuY2hpbGROb2Rlc1tpXSwgb3JnTG9jTm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBub2RlLnNoYWRvd1Jvb3QuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemVEb2N1bWVudEh5ZHJhdGUobm9kZS5zaGFkb3dSb290LmNoaWxkTm9kZXNbaV0sIG9yZ0xvY05vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIENvbW1lbnROb2RlICovKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkSWRTcGx0ID0gbm9kZS5ub2RlVmFsdWUuc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKGNoaWxkSWRTcGx0WzBdID09PSBPUkdfTE9DQVRJT05fSUQpIHtcbiAgICAgICAgICAgIG9yZ0xvY05vZGVzLnNldChjaGlsZElkU3BsdFsxXSArICcuJyArIGNoaWxkSWRTcGx0WzJdLCBub2RlKTtcbiAgICAgICAgICAgIG5vZGUubm9kZVZhbHVlID0gJyc7XG4gICAgICAgICAgICAvLyB1c2VmdWwgdG8ga25vdyBpZiB0aGUgb3JpZ2luYWwgbG9jYXRpb24gaXNcbiAgICAgICAgICAgIC8vIHRoZSByb290IGxpZ2h0LWRvbSBvZiBhIHNoYWRvdyBkb20gY29tcG9uZW50XG4gICAgICAgICAgICBub2RlWydzLWVuJ10gPSBjaGlsZElkU3BsdFszXTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBwYXJzZVByb3BlcnR5VmFsdWUgPSAocHJvcFZhbHVlLCBwcm9wVHlwZSkgPT4ge1xuICAgIC8vIGVuc3VyZSB0aGlzIHZhbHVlIGlzIG9mIHRoZSBjb3JyZWN0IHByb3AgdHlwZVxuICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiAhaXNDb21wbGV4VHlwZShwcm9wVmFsdWUpKSB7XG4gICAgICAgIGlmIChCVUlMRC5wcm9wQm9vbGVhbiAmJiBwcm9wVHlwZSAmIDQgLyogQm9vbGVhbiAqLykge1xuICAgICAgICAgICAgLy8gcGVyIHRoZSBIVE1MIHNwZWMsIGFueSBzdHJpbmcgdmFsdWUgbWVhbnMgaXQgaXMgYSBib29sZWFuIHRydWUgdmFsdWVcbiAgICAgICAgICAgIC8vIGJ1dCB3ZSdsbCBjaGVhdCBoZXJlIGFuZCBzYXkgdGhhdCB0aGUgc3RyaW5nIFwiZmFsc2VcIiBpcyB0aGUgYm9vbGVhbiBmYWxzZVxuICAgICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZSA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogcHJvcFZhbHVlID09PSAnJyB8fCAhIXByb3BWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQucHJvcE51bWJlciAmJiBwcm9wVHlwZSAmIDIgLyogTnVtYmVyICovKSB7XG4gICAgICAgICAgICAvLyBmb3JjZSBpdCB0byBiZSBhIG51bWJlclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQocHJvcFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQucHJvcFN0cmluZyAmJiBwcm9wVHlwZSAmIDEgLyogU3RyaW5nICovKSB7XG4gICAgICAgICAgICAvLyBjb3VsZCBoYXZlIGJlZW4gcGFzc2VkIGFzIGEgbnVtYmVyIG9yIGJvb2xlYW5cbiAgICAgICAgICAgIC8vIGJ1dCB3ZSBzdGlsbCB3YW50IGl0IGFzIGEgc3RyaW5nXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHByb3BWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVkdW5kYW50IHJldHVybiBoZXJlIGZvciBiZXR0ZXIgbWluaWZpY2F0aW9uXG4gICAgICAgIHJldHVybiBwcm9wVmFsdWU7XG4gICAgfVxuICAgIC8vIG5vdCBzdXJlIGV4YWN0bHkgd2hhdCB0eXBlIHdlIHdhbnRcbiAgICAvLyBzbyBubyBuZWVkIHRvIGNoYW5nZSB0byBhIGRpZmZlcmVudCB0eXBlXG4gICAgcmV0dXJuIHByb3BWYWx1ZTtcbn07XG5jb25zdCBnZXRWYWx1ZSA9IChyZWYsIHByb3BOYW1lKSA9PiBnZXRIb3N0UmVmKHJlZikuJGluc3RhbmNlVmFsdWVzJC5nZXQocHJvcE5hbWUpO1xuY29uc3Qgc2V0VmFsdWUgPSAocmVmLCBwcm9wTmFtZSwgbmV3VmFsLCBjbXBNZXRhKSA9PiB7XG4gICAgLy8gY2hlY2sgb3VyIG5ldyBwcm9wZXJ0eSB2YWx1ZSBhZ2FpbnN0IG91ciBpbnRlcm5hbCB2YWx1ZVxuICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKHJlZik7XG4gICAgY29uc3QgZWxtID0gQlVJTEQubGF6eUxvYWQgPyBob3N0UmVmLiRob3N0RWxlbWVudCQgOiByZWY7XG4gICAgY29uc3Qgb2xkVmFsID0gaG9zdFJlZi4kaW5zdGFuY2VWYWx1ZXMkLmdldChwcm9wTmFtZSk7XG4gICAgY29uc3QgZmxhZ3MgPSBob3N0UmVmLiRmbGFncyQ7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBCVUlMRC5sYXp5TG9hZCA/IGhvc3RSZWYuJGxhenlJbnN0YW5jZSQgOiBlbG07XG4gICAgbmV3VmFsID0gcGFyc2VQcm9wZXJ0eVZhbHVlKG5ld1ZhbCwgY21wTWV0YS4kbWVtYmVycyRbcHJvcE5hbWVdWzBdKTtcbiAgICBpZiAoKCFCVUlMRC5sYXp5TG9hZCB8fCAhKGZsYWdzICYgOCAvKiBpc0NvbnN0cnVjdGluZ0luc3RhbmNlICovKSB8fCBvbGRWYWwgPT09IHVuZGVmaW5lZCkgJiYgbmV3VmFsICE9PSBvbGRWYWwpIHtcbiAgICAgICAgLy8gZ2Fkem9va3MhIHRoZSBwcm9wZXJ0eSdzIHZhbHVlIGhhcyBjaGFuZ2VkISFcbiAgICAgICAgLy8gc2V0IG91ciBuZXcgdmFsdWUhXG4gICAgICAgIGhvc3RSZWYuJGluc3RhbmNlVmFsdWVzJC5zZXQocHJvcE5hbWUsIG5ld1ZhbCk7XG4gICAgICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICAgICAgaWYgKGhvc3RSZWYuJGZsYWdzJCAmIDEwMjQgLyogZGV2T25SZW5kZXIgKi8pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlRGV2V2FybihgVGhlIHN0YXRlL3Byb3AgXCIke3Byb3BOYW1lfVwiIGNoYW5nZWQgZHVyaW5nIHJlbmRlcmluZy4gVGhpcyBjYW4gcG90ZW50aWFsbHkgbGVhZCB0byBpbmZpbml0ZS1sb29wcyBhbmQgb3RoZXIgYnVncy5gLCAnXFxuRWxlbWVudCcsIGVsbSwgJ1xcbk5ldyB2YWx1ZScsIG5ld1ZhbCwgJ1xcbk9sZCB2YWx1ZScsIG9sZFZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChob3N0UmVmLiRmbGFncyQgJiAyMDQ4IC8qIGRldk9uRGlkTG9hZCAqLykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGVEZXZXYXJuKGBUaGUgc3RhdGUvcHJvcCBcIiR7cHJvcE5hbWV9XCIgY2hhbmdlZCBkdXJpbmcgXCJjb21wb25lbnREaWRMb2FkKClcIiwgdGhpcyB0cmlnZ2VycyBleHRyYSByZS1yZW5kZXJzLCB0cnkgdG8gc2V0dXAgb24gXCJjb21wb25lbnRXaWxsTG9hZCgpXCJgLCAnXFxuRWxlbWVudCcsIGVsbSwgJ1xcbk5ldyB2YWx1ZScsIG5ld1ZhbCwgJ1xcbk9sZCB2YWx1ZScsIG9sZFZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFCVUlMRC5sYXp5TG9hZCB8fCBpbnN0YW5jZSkge1xuICAgICAgICAgICAgLy8gZ2V0IGFuIGFycmF5IG9mIG1ldGhvZCBuYW1lcyBvZiB3YXRjaCBmdW5jdGlvbnMgdG8gY2FsbFxuICAgICAgICAgICAgaWYgKEJVSUxELndhdGNoQ2FsbGJhY2sgJiYgY21wTWV0YS4kd2F0Y2hlcnMkICYmIGZsYWdzICYgMTI4IC8qIGlzV2F0Y2hSZWFkeSAqLykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhdGNoTWV0aG9kcyA9IGNtcE1ldGEuJHdhdGNoZXJzJFtwcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHdhdGNoTWV0aG9kcykge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGluc3RhbmNlIGlzIHdhdGNoaW5nIGZvciB3aGVuIHRoaXMgcHJvcGVydHkgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICB3YXRjaE1ldGhvZHMubWFwKHdhdGNoTWV0aG9kTmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcmUgb2ZmIGVhY2ggb2YgdGhlIHdhdGNoIG1ldGhvZHMgdGhhdCBhcmUgd2F0Y2hpbmcgdGhpcyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlW3dhdGNoTWV0aG9kTmFtZV0obmV3VmFsLCBvbGRWYWwsIHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZUVycm9yKGUsIGVsbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC51cGRhdGFibGUgJiYgKGZsYWdzICYgKDIgLyogaGFzUmVuZGVyZWQgKi8gfCAxNiAvKiBpc1F1ZXVlZEZvclVwZGF0ZSAqLykpID09PSAyIC8qIGhhc1JlbmRlcmVkICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELmNtcFNob3VsZFVwZGF0ZSAmJiBpbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZShuZXdWYWwsIG9sZFZhbCwgcHJvcE5hbWUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGxvb2tzIGxpa2UgdGhpcyB2YWx1ZSBhY3R1YWxseSBjaGFuZ2VkLCBzbyB3ZSd2ZSBnb3Qgd29yayB0byBkbyFcbiAgICAgICAgICAgICAgICAvLyBidXQgb25seSBpZiB3ZSd2ZSBhbHJlYWR5IHJlbmRlcmVkLCBvdGhlcndpc2UganVzdCBjaGlsbCBvdXRcbiAgICAgICAgICAgICAgICAvLyBxdWV1ZSB0aGF0IHdlIG5lZWQgdG8gZG8gYW4gdXBkYXRlLCBidXQgZG9uJ3Qgd29ycnkgYWJvdXQgcXVldWluZ1xuICAgICAgICAgICAgICAgIC8vIHVwIG1pbGxpb25zIGN1eiB0aGlzIGZ1bmN0aW9uIGVuc3VyZXMgaXQgb25seSBydW5zIG9uY2VcbiAgICAgICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZShob3N0UmVmLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgcHJveHlDb21wb25lbnQgPSAoQ3N0ciwgY21wTWV0YSwgZmxhZ3MpID0+IHtcbiAgICBpZiAoQlVJTEQubWVtYmVyICYmIGNtcE1ldGEuJG1lbWJlcnMkKSB7XG4gICAgICAgIGlmIChCVUlMRC53YXRjaENhbGxiYWNrICYmIENzdHIud2F0Y2hlcnMpIHtcbiAgICAgICAgICAgIGNtcE1ldGEuJHdhdGNoZXJzJCA9IENzdHIud2F0Y2hlcnM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQncyBiZXR0ZXIgdG8gaGF2ZSBhIGNvbnN0IHRoYW4gdHdvIE9iamVjdC5lbnRyaWVzKClcbiAgICAgICAgY29uc3QgbWVtYmVycyA9IE9iamVjdC5lbnRyaWVzKGNtcE1ldGEuJG1lbWJlcnMkKTtcbiAgICAgICAgY29uc3QgcHJvdG90eXBlID0gQ3N0ci5wcm90b3R5cGU7XG4gICAgICAgIG1lbWJlcnMubWFwKChbbWVtYmVyTmFtZSwgW21lbWJlckZsYWdzXV0pID0+IHtcbiAgICAgICAgICAgIGlmICgoQlVJTEQucHJvcCB8fCBCVUlMRC5zdGF0ZSkgJiYgKG1lbWJlckZsYWdzICYgMzEgLyogUHJvcCAqLyB8fCAoKCFCVUlMRC5sYXp5TG9hZCB8fCBmbGFncyAmIDIgLyogcHJveHlTdGF0ZSAqLykgJiYgbWVtYmVyRmxhZ3MgJiAzMiAvKiBTdGF0ZSAqLykpKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJveHlDb21wb25lbnQgLSBwcm9wXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgbWVtYmVyTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm94eUNvbXBvbmVudCwgZ2V0IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VmFsdWUodGhpcywgbWVtYmVyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNldChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBkdXJpbmcgZGV2IHRpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IGdldEhvc3RSZWYodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBwcm94eWluZyB0aGUgaW5zdGFuY2UgKG5vdCBlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmbGFncyAmIDEgLyogaXNFbGVtZW50Q29uc3RydWN0b3IgKi8pID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBlbGVtZW50IGlzIG5vdCBjb25zdHJ1Y3RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlZi4kZmxhZ3MkICYgOCAvKiBpc0NvbnN0cnVjdGluZ0luc3RhbmNlICovKSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbWVtYmVyIGlzIGEgcHJvcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWVtYmVyRmxhZ3MgJiAzMSAvKiBQcm9wICovKSAhPT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbWVtYmVyIGlzIG5vdCBtdXRhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtZW1iZXJGbGFncyAmIDEwMjQgLyogTXV0YWJsZSAqLykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZURldldhcm4oYEBQcm9wKCkgXCIke21lbWJlck5hbWV9XCIgb24gPCR7Y21wTWV0YS4kdGFnTmFtZSR9PiBpcyBpbW11dGFibGUgYnV0IHdhcyBtb2RpZmllZCBmcm9tIHdpdGhpbiB0aGUgY29tcG9uZW50Llxcbk1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vc3RlbmNpbGpzLmNvbS9kb2NzL3Byb3BlcnRpZXMjcHJvcC1tdXRhYmlsaXR5YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJveHlDb21wb25lbnQsIHNldCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUodGhpcywgbWVtYmVyTmFtZSwgbmV3VmFsdWUsIGNtcE1ldGEpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChCVUlMRC5sYXp5TG9hZCAmJiBCVUlMRC5tZXRob2QgJiYgZmxhZ3MgJiAxIC8qIGlzRWxlbWVudENvbnN0cnVjdG9yICovICYmIG1lbWJlckZsYWdzICYgNjQgLyogTWV0aG9kICovKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJveHlDb21wb25lbnQgLSBtZXRob2RcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBtZW1iZXJOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IGdldEhvc3RSZWYodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVmLiRvbkluc3RhbmNlUHJvbWlzZSQudGhlbigoKSA9PiByZWYuJGxhenlJbnN0YW5jZSRbbWVtYmVyTmFtZV0oLi4uYXJncykpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKEJVSUxELm9ic2VydmVBdHRyaWJ1dGUgJiYgKCFCVUlMRC5sYXp5TG9hZCB8fCBmbGFncyAmIDEgLyogaXNFbGVtZW50Q29uc3RydWN0b3IgKi8pKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyTmFtZVRvUHJvcE5hbWUgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBwcm90b3R5cGUuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrID0gZnVuY3Rpb24gKGF0dHJOYW1lLCBfb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcGx0LmptcCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lID0gYXR0ck5hbWVUb1Byb3BOYW1lLmdldChhdHRyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbmV3VmFsdWUgPT09IG51bGwgJiYgdHlwZW9mIHRoaXNbcHJvcE5hbWVdID09PSAnYm9vbGVhbicgPyBmYWxzZSA6IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBhcnJheSBvZiBhdHRyaWJ1dGVzIHRvIG9ic2VydmVcbiAgICAgICAgICAgIC8vIGFuZCBhbHNvIGNyZWF0ZSBhIG1hcCBvZiBodG1sIGF0dHJpYnV0ZSBuYW1lIHRvIGpzIHByb3BlcnR5IG5hbWVcbiAgICAgICAgICAgIENzdHIub2JzZXJ2ZWRBdHRyaWJ1dGVzID0gbWVtYmVyc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKFtfLCBtXSkgPT4gbVswXSAmIDE1IC8qIEhhc0F0dHJpYnV0ZSAqLykgLy8gZmlsdGVyIHRvIG9ubHkga2VlcCBwcm9wcyB0aGF0IHNob3VsZCBtYXRjaCBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgLm1hcCgoW3Byb3BOYW1lLCBtXSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJOYW1lID0gbVsxXSB8fCBwcm9wTmFtZTtcbiAgICAgICAgICAgICAgICBhdHRyTmFtZVRvUHJvcE5hbWUuc2V0KGF0dHJOYW1lLCBwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELnJlZmxlY3QgJiYgbVswXSAmIDUxMiAvKiBSZWZsZWN0QXR0ciAqLykge1xuICAgICAgICAgICAgICAgICAgICBjbXBNZXRhLiRhdHRyc1RvUmVmbGVjdCQucHVzaChbcHJvcE5hbWUsIGF0dHJOYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhdHRyTmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBDc3RyO1xufTtcbmNvbnN0IGluaXRpYWxpemVDb21wb25lbnQgPSBhc3luYyAoZWxtLCBob3N0UmVmLCBjbXBNZXRhLCBobXJWZXJzaW9uSWQsIENzdHIpID0+IHtcbiAgICAvLyBpbml0aWFsaXplQ29tcG9uZW50XG4gICAgaWYgKChCVUlMRC5sYXp5TG9hZCB8fCBCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSB8fCBCVUlMRC5zdHlsZSkgJiYgKGhvc3RSZWYuJGZsYWdzJCAmIDMyIC8qIGhhc0luaXRpYWxpemVkQ29tcG9uZW50ICovKSA9PT0gMCkge1xuICAgICAgICBpZiAoQlVJTEQubGF6eUxvYWQgfHwgQlVJTEQuaHlkcmF0ZUNsaWVudFNpZGUpIHtcbiAgICAgICAgICAgIC8vIHdlIGhhdmVuJ3QgaW5pdGlhbGl6ZWQgdGhpcyBlbGVtZW50IHlldFxuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDMyIC8qIGhhc0luaXRpYWxpemVkQ29tcG9uZW50ICovO1xuICAgICAgICAgICAgLy8gbGF6eSBsb2FkZWQgY29tcG9uZW50c1xuICAgICAgICAgICAgLy8gcmVxdWVzdCB0aGUgY29tcG9uZW50J3MgaW1wbGVtZW50YXRpb24gdG8gYmVcbiAgICAgICAgICAgIC8vIHdpcmVkIHVwIHdpdGggdGhlIGhvc3QgZWxlbWVudFxuICAgICAgICAgICAgQ3N0ciA9IGxvYWRNb2R1bGUoY21wTWV0YSwgaG9zdFJlZiwgaG1yVmVyc2lvbklkKTtcbiAgICAgICAgICAgIGlmIChDc3RyLnRoZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBBd2FpdCBjcmVhdGVzIGEgbWljcm8tdGFzayBhdm9pZCBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgIGNvbnN0IGVuZExvYWQgPSB1bmlxdWVUaW1lKGBzdDpsb2FkOiR7Y21wTWV0YS4kdGFnTmFtZSR9OiR7aG9zdFJlZi4kbW9kZU5hbWUkfWAsIGBbU3RlbmNpbF0gTG9hZCBtb2R1bGUgZm9yIDwke2NtcE1ldGEuJHRhZ05hbWUkfT5gKTtcbiAgICAgICAgICAgICAgICBDc3RyID0gYXdhaXQgQ3N0cjtcbiAgICAgICAgICAgICAgICBlbmRMb2FkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKEJVSUxELmlzRGV2IHx8IEJVSUxELmlzRGVidWcpICYmICFDc3RyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25zdHJ1Y3RvciBmb3IgXCIke2NtcE1ldGEuJHRhZ05hbWUkfSMke2hvc3RSZWYuJG1vZGVOYW1lJH1cIiB3YXMgbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQubWVtYmVyICYmICFDc3RyLmlzUHJveGllZCkge1xuICAgICAgICAgICAgICAgIC8vIHdlJ2V2ZSBuZXZlciBwcm94aWVkIHRoaXMgQ29uc3RydWN0b3IgYmVmb3JlXG4gICAgICAgICAgICAgICAgLy8gbGV0J3MgYWRkIHRoZSBnZXR0ZXJzL3NldHRlcnMgdG8gaXRzIHByb3RvdHlwZSBiZWZvcmVcbiAgICAgICAgICAgICAgICAvLyB0aGUgZmlyc3QgdGltZSB3ZSBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhlIGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELndhdGNoQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY21wTWV0YS4kd2F0Y2hlcnMkID0gQ3N0ci53YXRjaGVycztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJveHlDb21wb25lbnQoQ3N0ciwgY21wTWV0YSwgMiAvKiBwcm94eVN0YXRlICovKTtcbiAgICAgICAgICAgICAgICBDc3RyLmlzUHJveGllZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbmROZXdJbnN0YW5jZSA9IGNyZWF0ZVRpbWUoJ2NyZWF0ZUluc3RhbmNlJywgY21wTWV0YS4kdGFnTmFtZSQpO1xuICAgICAgICAgICAgLy8gb2ssIHRpbWUgdG8gY29uc3RydWN0IHRoZSBpbnN0YW5jZVxuICAgICAgICAgICAgLy8gYnV0IGxldCdzIGtlZXAgdHJhY2sgb2Ygd2hlbiB3ZSBzdGFydCBhbmQgc3RvcFxuICAgICAgICAgICAgLy8gc28gdGhhdCB0aGUgZ2V0dGVycy9zZXR0ZXJzIGRvbid0IGluY29ycmVjdGx5IHN0ZXAgb24gZGF0YVxuICAgICAgICAgICAgaWYgKEJVSUxELm1lbWJlcikge1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSA4IC8qIGlzQ29uc3RydWN0aW5nSW5zdGFuY2UgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb25zdHJ1Y3QgdGhlIGxhenktbG9hZGVkIGNvbXBvbmVudCBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgLy8gcGFzc2luZyB0aGUgaG9zdFJlZiBpcyB2ZXJ5IGltcG9ydGFudCBkdXJpbmdcbiAgICAgICAgICAgIC8vIGNvbnN0cnVjdGlvbiBpbiBvcmRlciB0byBkaXJlY3RseSB3aXJlIHRvZ2V0aGVyIHRoZVxuICAgICAgICAgICAgLy8gaG9zdCBlbGVtZW50IGFuZCB0aGUgbGF6eS1sb2FkZWQgaW5zdGFuY2VcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbmV3IENzdHIoaG9zdFJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5tZW1iZXIpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgJj0gfjggLyogaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC53YXRjaENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDEyOCAvKiBpc1dhdGNoUmVhZHkgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmROZXdJbnN0YW5jZSgpO1xuICAgICAgICAgICAgZmlyZUNvbm5lY3RlZENhbGxiYWNrKGhvc3RSZWYuJGxhenlJbnN0YW5jZSQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gc3luYyBjb25zdHJ1Y3RvciBjb21wb25lbnRcbiAgICAgICAgICAgIENzdHIgPSBlbG0uY29uc3RydWN0b3I7XG4gICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMTI4IC8qIGlzV2F0Y2hSZWFkeSAqLyB8IDMyIC8qIGhhc0luaXRpYWxpemVkQ29tcG9uZW50ICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5zdHlsZSAmJiBDc3RyLnN0eWxlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGNvbXBvbmVudCBoYXMgc3R5bGVzIGJ1dCB3ZSBoYXZlbid0IHJlZ2lzdGVyZWQgdGhlbSB5ZXRcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IENzdHIuc3R5bGU7XG4gICAgICAgICAgICBpZiAoQlVJTEQubW9kZSAmJiB0eXBlb2Ygc3R5bGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZVsoaG9zdFJlZi4kbW9kZU5hbWUkID0gY29tcHV0ZU1vZGUoZWxtKSldO1xuICAgICAgICAgICAgICAgIGlmIChCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSAmJiBob3N0UmVmLiRtb2RlTmFtZSQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZSgncy1tb2RlJywgaG9zdFJlZi4kbW9kZU5hbWUkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzY29wZUlkID0gZ2V0U2NvcGVJZChjbXBNZXRhLCBob3N0UmVmLiRtb2RlTmFtZSQpO1xuICAgICAgICAgICAgaWYgKCFzdHlsZXMuaGFzKHNjb3BlSWQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kUmVnaXN0ZXJTdHlsZXMgPSBjcmVhdGVUaW1lKCdyZWdpc3RlclN0eWxlcycsIGNtcE1ldGEuJHRhZ05hbWUkKTtcbiAgICAgICAgICAgICAgICBpZiAoIUJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlICYmIEJVSUxELnNoYWRvd0RvbSAmJiBCVUlMRC5zaGFkb3dEb21TaGltICYmIGNtcE1ldGEuJGZsYWdzJCAmIDggLyogbmVlZHNTaGFkb3dEb21TaGltICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlID0gYXdhaXQgaW1wb3J0KCcuL3NoYWRvdy1jc3MuanMnKS50aGVuKG0gPT4gbS5zY29wZUNzcyhzdHlsZSwgc2NvcGVJZCwgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJTdHlsZShzY29wZUlkLCBzdHlsZSwgISEoY21wTWV0YS4kZmxhZ3MkICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSk7XG4gICAgICAgICAgICAgICAgZW5kUmVnaXN0ZXJTdHlsZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB3ZSd2ZSBzdWNjZXNzZnVsbHkgY3JlYXRlZCBhIGxhenkgaW5zdGFuY2VcbiAgICBjb25zdCBhbmNlc3RvckNvbXBvbmVudCA9IGhvc3RSZWYuJGFuY2VzdG9yQ29tcG9uZW50JDtcbiAgICBjb25zdCBzY2hlZHVsZSA9ICgpID0+IHNjaGVkdWxlVXBkYXRlKGhvc3RSZWYsIHRydWUpO1xuICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcgJiYgYW5jZXN0b3JDb21wb25lbnQgJiYgYW5jZXN0b3JDb21wb25lbnRbJ3MtcmMnXSkge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBpbnRpYWwgbG9hZCBhbmQgdGhpcyBjb21wb25lbnQgaXQgaGFzIGFuIGFuY2VzdG9yIGNvbXBvbmVudFxuICAgICAgICAvLyBidXQgdGhlIGFuY2VzdG9yIGNvbXBvbmVudCBoYXMgTk9UIGZpcmVkIGl0cyB3aWxsIHVwZGF0ZSBsaWZlY3ljbGUgeWV0XG4gICAgICAgIC8vIHNvIGxldCdzIGp1c3QgY29vbCBvdXIgamV0cyBhbmQgd2FpdCBmb3IgdGhlIGFuY2VzdG9yIHRvIGNvbnRpbnVlIGZpcnN0XG4gICAgICAgIC8vIHRoaXMgd2lsbCBnZXQgZmlyZWQgb2ZmIHdoZW4gdGhlIGFuY2VzdG9yIGNvbXBvbmVudFxuICAgICAgICAvLyBmaW5hbGx5IGdldHMgYXJvdW5kIHRvIHJlbmRlcmluZyBpdHMgbGF6eSBzZWxmXG4gICAgICAgIC8vIGZpcmUgb2ZmIHRoZSBpbml0aWFsIHVwZGF0ZVxuICAgICAgICBhbmNlc3RvckNvbXBvbmVudFsncy1yYyddLnB1c2goc2NoZWR1bGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2NoZWR1bGUoKTtcbiAgICB9XG59O1xuY29uc3QgZmlyZUNvbm5lY3RlZENhbGxiYWNrID0gKGluc3RhbmNlKSA9PiB7XG4gICAgaWYgKEJVSUxELmxhenlMb2FkICYmIEJVSUxELmNvbm5lY3RlZENhbGxiYWNrKSB7XG4gICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29ubmVjdGVkQ2FsbGJhY2snKTtcbiAgICB9XG59O1xuY29uc3QgY29ubmVjdGVkQ2FsbGJhY2sgPSAoZWxtKSA9PiB7XG4gICAgaWYgKChwbHQuJGZsYWdzJCAmIDEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi8pID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKGVsbSk7XG4gICAgICAgIGNvbnN0IGNtcE1ldGEgPSBob3N0UmVmLiRjbXBNZXRhJDtcbiAgICAgICAgY29uc3QgZW5kQ29ubmVjdGVkID0gY3JlYXRlVGltZSgnY29ubmVjdGVkQ2FsbGJhY2snLCBjbXBNZXRhLiR0YWdOYW1lJCk7XG4gICAgICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXJUYXJnZXRQYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgcnVuIGlmIHdlIGhhdmUgbGlzdGVuZXJzIGJlaW5nIGF0dGFjaGVkIHRvIGEgcGFyZW50XG4gICAgICAgICAgICBhZGRIb3N0RXZlbnRMaXN0ZW5lcnMoZWxtLCBob3N0UmVmLCBjbXBNZXRhLiRsaXN0ZW5lcnMkLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShob3N0UmVmLiRmbGFncyQgJiAxIC8qIGhhc0Nvbm5lY3RlZCAqLykpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IHRpbWUgdGhpcyBjb21wb25lbnQgaGFzIGNvbm5lY3RlZFxuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDEgLyogaGFzQ29ubmVjdGVkICovO1xuICAgICAgICAgICAgbGV0IGhvc3RJZDtcbiAgICAgICAgICAgIGlmIChCVUlMRC5oeWRyYXRlQ2xpZW50U2lkZSkge1xuICAgICAgICAgICAgICAgIGhvc3RJZCA9IGVsbS5nZXRBdHRyaWJ1dGUoSFlEUkFURV9JRCk7XG4gICAgICAgICAgICAgICAgaWYgKGhvc3RJZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmIHN1cHBvcnRzU2hhZG93ICYmIGNtcE1ldGEuJGZsYWdzJCAmIDEgLyogc2hhZG93RG9tRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NvcGVJZCA9IEJVSUxELm1vZGUgPyBhZGRTdHlsZShlbG0uc2hhZG93Um9vdCwgY21wTWV0YSwgZWxtLmdldEF0dHJpYnV0ZSgncy1tb2RlJykpIDogYWRkU3R5bGUoZWxtLnNoYWRvd1Jvb3QsIGNtcE1ldGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxtLmNsYXNzTGlzdC5yZW1vdmUoc2NvcGVJZCArICctaCcsIHNjb3BlSWQgKyAnLXMnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXplQ2xpZW50SHlkcmF0ZShlbG0sIGNtcE1ldGEuJHRhZ05hbWUkLCBob3N0SWQsIGhvc3RSZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiAhaG9zdElkKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5pdFVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzbG90IHBvbHlmaWxsIGlzIHJlcXVpcmVkIHdlJ2xsIG5lZWQgdG8gcHV0IHNvbWUgbm9kZXNcbiAgICAgICAgICAgICAgICAvLyBpbiBoZXJlIHRvIGFjdCBhcyBvcmlnaW5hbCBjb250ZW50IGFuY2hvcnMgYXMgd2UgbW92ZSBub2RlcyBhcm91bmRcbiAgICAgICAgICAgICAgICAvLyBob3N0IGVsZW1lbnQgaGFzIGJlZW4gY29ubmVjdGVkIHRvIHRoZSBET01cbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgfHwgKChCVUlMRC5zbG90IHx8IEJVSUxELnNoYWRvd0RvbSkgJiYgY21wTWV0YS4kZmxhZ3MkICYgKDQgLyogaGFzU2xvdFJlbG9jYXRpb24gKi8gfCA4IC8qIG5lZWRzU2hhZG93RG9tU2hpbSAqLykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldENvbnRlbnRSZWZlcmVuY2UoZWxtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgZmlyc3QgYW5jZXN0b3IgY29tcG9uZW50IChpZiB0aGVyZSBpcyBvbmUpIGFuZCByZWdpc3RlclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY29tcG9uZW50IGFzIG9uZSBvZiB0aGUgYWN0aXZlbHkgbG9hZGluZyBjaGlsZCBjb21wb25lbnRzIGZvciBpdHMgYW5jZXN0b3JcbiAgICAgICAgICAgICAgICBsZXQgYW5jZXN0b3JDb21wb25lbnQgPSBlbG07XG4gICAgICAgICAgICAgICAgd2hpbGUgKChhbmNlc3RvckNvbXBvbmVudCA9IGFuY2VzdG9yQ29tcG9uZW50LnBhcmVudE5vZGUgfHwgYW5jZXN0b3JDb21wb25lbnQuaG9zdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xpbWIgdXAgdGhlIGFuY2VzdG9ycyBsb29raW5nIGZvciB0aGUgZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IHRoYXQgaGFzbid0IGZpbmlzaGVkIGl0cyBsaWZlY3ljbGUgdXBkYXRlIHlldFxuICAgICAgICAgICAgICAgICAgICBpZiAoKEJVSUxELmh5ZHJhdGVDbGllbnRTaWRlICYmIGFuY2VzdG9yQ29tcG9uZW50Lm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovICYmIGFuY2VzdG9yQ29tcG9uZW50Lmhhc0F0dHJpYnV0ZSgncy1pZCcpICYmIGFuY2VzdG9yQ29tcG9uZW50WydzLXAnXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2VzdG9yQ29tcG9uZW50WydzLXAnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZm91bmQgdGhpcyBjb21wb25lbnRzIGZpcnN0IGFuY2VzdG9yIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGlzIGNvbXBvbmVudCdzIGFuY2VzdG9yIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNoVG9BbmNlc3Rvcihob3N0UmVmLCAoaG9zdFJlZi4kYW5jZXN0b3JDb21wb25lbnQkID0gYW5jZXN0b3JDb21wb25lbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGF6eSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvZnVuZGFtZW50YWxzL3dlYi1jb21wb25lbnRzL2Jlc3QtcHJhY3RpY2VzI2xhenktcHJvcGVydGllc1xuICAgICAgICAgICAgaWYgKEJVSUxELnByb3AgJiYgQlVJTEQubGF6eUxvYWQgJiYgIUJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlICYmIGNtcE1ldGEuJG1lbWJlcnMkKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoY21wTWV0YS4kbWVtYmVycyQpLm1hcCgoW21lbWJlck5hbWUsIFttZW1iZXJGbGFnc11dKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXJGbGFncyAmIDMxIC8qIFByb3AgKi8gJiYgZWxtLmhhc093blByb3BlcnR5KG1lbWJlck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGVsbVttZW1iZXJOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbG1bbWVtYmVyTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbG1bbWVtYmVyTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELmluaXRpYWxpemVOZXh0VGljaykge1xuICAgICAgICAgICAgICAgIC8vIGNvbm5lY3RlZENhbGxiYWNrLCB0YXNrUXVldWUsIGluaXRpYWxMb2FkXG4gICAgICAgICAgICAgICAgLy8gYW5ndWxhciBzZXRzIGF0dHJpYnV0ZSBBRlRFUiBjb25uZWN0Q2FsbGJhY2tcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8xODkwOVxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzE5OTQwXG4gICAgICAgICAgICAgICAgbmV4dFRpY2soKCkgPT4gaW5pdGlhbGl6ZUNvbXBvbmVudChlbG0sIGhvc3RSZWYsIGNtcE1ldGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemVDb21wb25lbnQoZWxtLCBob3N0UmVmLCBjbXBNZXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vdCB0aGUgZmlyc3QgdGltZSB0aGlzIGhhcyBjb25uZWN0ZWRcbiAgICAgICAgICAgIC8vIHJlYXR0YWNoIGFueSBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIGhvc3RcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkgd291bGQgaGF2ZSBiZWVuIHJlbW92ZWQgd2hlbiBkaXNjb25uZWN0ZWRcbiAgICAgICAgICAgIGFkZEhvc3RFdmVudExpc3RlbmVycyhlbG0sIGhvc3RSZWYsIGNtcE1ldGEuJGxpc3RlbmVycyQsIGZhbHNlKTtcbiAgICAgICAgICAgIC8vIGZpcmUgb2ZmIGNvbm5lY3RlZENhbGxiYWNrKCkgb24gY29tcG9uZW50IGluc3RhbmNlXG4gICAgICAgICAgICBmaXJlQ29ubmVjdGVkQ2FsbGJhY2soaG9zdFJlZi4kbGF6eUluc3RhbmNlJCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5kQ29ubmVjdGVkKCk7XG4gICAgfVxufTtcbmNvbnN0IHNldENvbnRlbnRSZWZlcmVuY2UgPSAoZWxtKSA9PiB7XG4gICAgLy8gb25seSByZXF1aXJlZCB3aGVuIHdlJ3JlIE5PVCB1c2luZyBuYXRpdmUgc2hhZG93IGRvbSAoc2xvdClcbiAgICAvLyBvciB0aGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IG5hdGl2ZSBzaGFkb3cgZG9tXG4gICAgLy8gYW5kIHRoaXMgaG9zdCBlbGVtZW50IHdhcyBOT1QgY3JlYXRlZCB3aXRoIFNTUlxuICAgIC8vIGxldCdzIHBpY2sgb3V0IHRoZSBpbm5lciBjb250ZW50IGZvciBzbG90IHByb2plY3Rpb25cbiAgICAvLyBjcmVhdGUgYSBub2RlIHRvIHJlcHJlc2VudCB3aGVyZSB0aGUgb3JpZ2luYWxcbiAgICAvLyBjb250ZW50IHdhcyBmaXJzdCBwbGFjZWQsIHdoaWNoIGlzIHVzZWZ1bCBsYXRlciBvblxuICAgIGNvbnN0IGNvbnRlbnRSZWZFbG0gPSAoZWxtWydzLWNyJ10gPSBkb2MuY3JlYXRlQ29tbWVudChCVUlMRC5pc0RlYnVnID8gYGNvbnRlbnQtcmVmIChob3N0PSR7ZWxtLmxvY2FsTmFtZX0pYCA6ICcnKSk7XG4gICAgY29udGVudFJlZkVsbVsncy1jbiddID0gdHJ1ZTtcbiAgICBlbG0uaW5zZXJ0QmVmb3JlKGNvbnRlbnRSZWZFbG0sIGVsbS5maXJzdENoaWxkKTtcbn07XG5jb25zdCBkaXNjb25uZWN0ZWRDYWxsYmFjayA9IChlbG0pID0+IHtcbiAgICBpZiAoKHBsdC4kZmxhZ3MkICYgMSAvKiBpc1RtcERpc2Nvbm5lY3RlZCAqLykgPT09IDApIHtcbiAgICAgICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYoZWxtKTtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBCVUlMRC5sYXp5TG9hZCA/IGhvc3RSZWYuJGxhenlJbnN0YW5jZSQgOiBlbG07XG4gICAgICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGlmIChob3N0UmVmLiRybUxpc3RlbmVycyQpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRybUxpc3RlbmVycyQubWFwKHJtTGlzdGVuZXIgPT4gcm1MaXN0ZW5lcigpKTtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRybUxpc3RlbmVycyQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2xlYXIgQ1NTIHZhci1zaGltIHRyYWNraW5nXG4gICAgICAgIGlmIChCVUlMRC5jc3NWYXJTaGltICYmIHBsdC4kY3NzU2hpbSQpIHtcbiAgICAgICAgICAgIHBsdC4kY3NzU2hpbSQucmVtb3ZlSG9zdChlbG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5sYXp5TG9hZCAmJiBCVUlMRC5kaXNjb25uZWN0ZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgc2FmZUNhbGwoaW5zdGFuY2UsICdkaXNjb25uZWN0ZWRDYWxsYmFjaycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5jbXBEaWRVbmxvYWQpIHtcbiAgICAgICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50RGlkVW5sb2FkJyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgZGVmaW5lQ3VzdG9tRWxlbWVudCA9IChDc3RyLCBjb21wYWN0TWV0YSkgPT4ge1xuICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZShjb21wYWN0TWV0YVsxXSwgcHJveHlDdXN0b21FbGVtZW50KENzdHIsIGNvbXBhY3RNZXRhKSk7XG59O1xuY29uc3QgcHJveHlDdXN0b21FbGVtZW50ID0gKENzdHIsIGNvbXBhY3RNZXRhKSA9PiB7XG4gICAgY29uc3QgY21wTWV0YSA9IHtcbiAgICAgICAgJGZsYWdzJDogY29tcGFjdE1ldGFbMF0sXG4gICAgICAgICR0YWdOYW1lJDogY29tcGFjdE1ldGFbMV0sXG4gICAgfTtcbiAgICBpZiAoQlVJTEQubWVtYmVyKSB7XG4gICAgICAgIGNtcE1ldGEuJG1lbWJlcnMkID0gY29tcGFjdE1ldGFbMl07XG4gICAgfVxuICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXIpIHtcbiAgICAgICAgY21wTWV0YS4kbGlzdGVuZXJzJCA9IGNvbXBhY3RNZXRhWzNdO1xuICAgIH1cbiAgICBpZiAoQlVJTEQud2F0Y2hDYWxsYmFjaykge1xuICAgICAgICBjbXBNZXRhLiR3YXRjaGVycyQgPSBDc3RyLiR3YXRjaGVycyQ7XG4gICAgfVxuICAgIGlmIChCVUlMRC5yZWZsZWN0KSB7XG4gICAgICAgIGNtcE1ldGEuJGF0dHJzVG9SZWZsZWN0JCA9IFtdO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmICFzdXBwb3J0c1NoYWRvdyAmJiBjbXBNZXRhLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgY21wTWV0YS4kZmxhZ3MkIHw9IDggLyogbmVlZHNTaGFkb3dEb21TaGltICovO1xuICAgIH1cbiAgICBjb25zdCBvcmlnaW5hbENvbm5lY3RlZENhbGxiYWNrID0gQ3N0ci5wcm90b3R5cGUuY29ubmVjdGVkQ2FsbGJhY2s7XG4gICAgY29uc3Qgb3JpZ2luYWxEaXNjb25uZWN0ZWRDYWxsYmFjayA9IENzdHIucHJvdG90eXBlLmRpc2Nvbm5lY3RlZENhbGxiYWNrO1xuICAgIE9iamVjdC5hc3NpZ24oQ3N0ci5wcm90b3R5cGUsIHtcbiAgICAgICAgX19yZWdpc3Rlckhvc3QoKSB7XG4gICAgICAgICAgICByZWdpc3Rlckhvc3QodGhpcywgY21wTWV0YSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2sodGhpcyk7XG4gICAgICAgICAgICBpZiAoQlVJTEQuY29ubmVjdGVkQ2FsbGJhY2sgJiYgb3JpZ2luYWxDb25uZWN0ZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsQ29ubmVjdGVkQ2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjayh0aGlzKTtcbiAgICAgICAgICAgIGlmIChCVUlMRC5kaXNjb25uZWN0ZWRDYWxsYmFjayAmJiBvcmlnaW5hbERpc2Nvbm5lY3RlZENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxEaXNjb25uZWN0ZWRDYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIENzdHIuaXMgPSBjbXBNZXRhLiR0YWdOYW1lJDtcbiAgICByZXR1cm4gcHJveHlDb21wb25lbnQoQ3N0ciwgY21wTWV0YSwgMSAvKiBpc0VsZW1lbnRDb25zdHJ1Y3RvciAqLyB8IDIgLyogcHJveHlTdGF0ZSAqLyk7XG59O1xuY29uc3QgZm9yY2VNb2RlVXBkYXRlID0gKGVsbSkgPT4ge1xuICAgIGlmIChCVUlMRC5zdHlsZSAmJiBCVUlMRC5tb2RlICYmICFCVUlMRC5sYXp5TG9hZCkge1xuICAgICAgICBjb25zdCBtb2RlID0gY29tcHV0ZU1vZGUoZWxtKTtcbiAgICAgICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYoZWxtKTtcbiAgICAgICAgaWYgKGhvc3RSZWYuJG1vZGVOYW1lJCAhPT0gbW9kZSkge1xuICAgICAgICAgICAgY29uc3QgY21wTWV0YSA9IGhvc3RSZWYuJGNtcE1ldGEkO1xuICAgICAgICAgICAgY29uc3Qgb2xkU2NvcGVJZCA9IGVsbVsncy1zYyddO1xuICAgICAgICAgICAgY29uc3Qgc2NvcGVJZCA9IGdldFNjb3BlSWQoY21wTWV0YSwgbW9kZSk7XG4gICAgICAgICAgICBjb25zdCBzdHlsZSA9IGVsbS5jb25zdHJ1Y3Rvci5zdHlsZVttb2RlXTtcbiAgICAgICAgICAgIGNvbnN0IGZsYWdzID0gY21wTWV0YS4kZmxhZ3MkO1xuICAgICAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdHlsZXMuaGFzKHNjb3BlSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyU3R5bGUoc2NvcGVJZCwgc3R5bGUsICEhKGZsYWdzICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhvc3RSZWYuJG1vZGVOYW1lJCA9IG1vZGU7XG4gICAgICAgICAgICAgICAgZWxtLmNsYXNzTGlzdC5yZW1vdmUob2xkU2NvcGVJZCArICctaCcsIG9sZFNjb3BlSWQgKyAnLXMnKTtcbiAgICAgICAgICAgICAgICBhdHRhY2hTdHlsZXMoaG9zdFJlZik7XG4gICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUoZWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBhdHRhY2hTaGFkb3cgPSAoZWwpID0+IHtcbiAgICBpZiAoc3VwcG9ydHNTaGFkb3cpIHtcbiAgICAgICAgZWwuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWwuc2hhZG93Um9vdCA9IGVsO1xuICAgIH1cbn07XG5jb25zdCBobXJTdGFydCA9IChlbG0sIGNtcE1ldGEsIGhtclZlcnNpb25JZCkgPT4ge1xuICAgIC8vIMKvXFxfKOODhClfL8KvXG4gICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYoZWxtKTtcbiAgICAvLyByZXNldCBzdGF0ZSBmbGFncyB0byBvbmx5IGhhdmUgYmVlbiBjb25uZWN0ZWRcbiAgICBob3N0UmVmLiRmbGFncyQgPSAxIC8qIGhhc0Nvbm5lY3RlZCAqLztcbiAgICAvLyBUT0RPXG4gICAgLy8gZGV0YXRjaCBhbnkgZXZlbnQgbGlzdGVuZXJzIHRoYXQgbWF5IGhhdmUgYmVlbiBhZGRlZFxuICAgIC8vIGJlY2F1c2Ugd2UncmUgbm90IHBhc3NpbmcgYW4gZXhhY3QgZXZlbnQgbmFtZSBpdCdsbFxuICAgIC8vIHJlbW92ZSBhbGwgb2YgdGhpcyBlbGVtZW50J3MgZXZlbnQsIHdoaWNoIGlzIGdvb2RcbiAgICAvLyBjcmVhdGUgYSBjYWxsYmFjayBmb3Igd2hlbiB0aGlzIGNvbXBvbmVudCBmaW5pc2hlcyBobXJcbiAgICBlbG1bJ3MtaG1yLWxvYWQnXSA9ICgpID0+IHtcbiAgICAgICAgLy8gZmluaXNoZWQgaG1yIGZvciB0aGlzIGVsZW1lbnRcbiAgICAgICAgZGVsZXRlIGVsbVsncy1obXItbG9hZCddO1xuICAgIH07XG4gICAgLy8gcmUtaW5pdGlhbGl6ZSB0aGUgY29tcG9uZW50XG4gICAgaW5pdGlhbGl6ZUNvbXBvbmVudChlbG0sIGhvc3RSZWYsIGNtcE1ldGEsIGhtclZlcnNpb25JZCk7XG59O1xuY29uc3QgcGF0Y2hDbG9uZU5vZGUgPSAoSG9zdEVsZW1lbnRQcm90b3R5cGUpID0+IHtcbiAgICBjb25zdCBvcmdDbG9uZU5vZGUgPSBIb3N0RWxlbWVudFByb3RvdHlwZS5jbG9uZU5vZGU7XG4gICAgSG9zdEVsZW1lbnRQcm90b3R5cGUuY2xvbmVOb2RlID0gZnVuY3Rpb24gKGRlZXApIHtcbiAgICAgICAgY29uc3Qgc3JjTm9kZSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGlzU2hhZG93RG9tID0gQlVJTEQuc2hhZG93RG9tID8gc3JjTm9kZS5zaGFkb3dSb290ICYmIHN1cHBvcnRzU2hhZG93IDogZmFsc2U7XG4gICAgICAgIGNvbnN0IGNsb25lZE5vZGUgPSBvcmdDbG9uZU5vZGUuY2FsbChzcmNOb2RlLCBpc1NoYWRvd0RvbSA/IGRlZXAgOiBmYWxzZSk7XG4gICAgICAgIGlmIChCVUlMRC5zbG90ICYmICFpc1NoYWRvd0RvbSAmJiBkZWVwKSB7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBsZXQgc2xvdHRlZCwgbm9uU3RlbmNpbE5vZGU7XG4gICAgICAgICAgICBsZXQgc3RlbmNpbFByaXZhdGVzID0gWydzLWlkJywgJ3MtY3InLCAncy1scicsICdzLXJjJywgJ3Mtc2MnLCAncy1wJywgJ3MtY24nLCAncy1zcicsICdzLXNuJywgJ3MtaG4nLCAncy1vbCcsICdzLW5yJywgJ3Mtc2knXTtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgc3JjTm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2xvdHRlZCA9IHNyY05vZGUuY2hpbGROb2Rlc1tpXVsncy1uciddO1xuICAgICAgICAgICAgICAgIG5vblN0ZW5jaWxOb2RlID0gc3RlbmNpbFByaXZhdGVzLmV2ZXJ5KChwcml2YXRlRmllbGQpID0+ICFzcmNOb2RlLmNoaWxkTm9kZXNbaV1bcHJpdmF0ZUZpZWxkXSk7XG4gICAgICAgICAgICAgICAgaWYgKHNsb3R0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELmFwcGVuZENoaWxkU2xvdEZpeCAmJiBjbG9uZWROb2RlLl9fYXBwZW5kQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZE5vZGUuX19hcHBlbmRDaGlsZChzbG90dGVkLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWROb2RlLmFwcGVuZENoaWxkKHNsb3R0ZWQuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9uU3RlbmNpbE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkTm9kZS5hcHBlbmRDaGlsZChzcmNOb2RlLmNoaWxkTm9kZXNbaV0uY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lZE5vZGU7XG4gICAgfTtcbn07XG5jb25zdCBwYXRjaFNsb3RBcHBlbmRDaGlsZCA9IChIb3N0RWxlbWVudFByb3RvdHlwZSkgPT4ge1xuICAgIEhvc3RFbGVtZW50UHJvdG90eXBlLl9fYXBwZW5kQ2hpbGQgPSBIb3N0RWxlbWVudFByb3RvdHlwZS5hcHBlbmRDaGlsZDtcbiAgICBIb3N0RWxlbWVudFByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChuZXdDaGlsZCkge1xuICAgICAgICBjb25zdCBzbG90TmFtZSA9IChuZXdDaGlsZFsncy1zbiddID0gZ2V0U2xvdE5hbWUobmV3Q2hpbGQpKTtcbiAgICAgICAgY29uc3Qgc2xvdE5vZGUgPSBnZXRIb3N0U2xvdE5vZGUodGhpcy5jaGlsZE5vZGVzLCBzbG90TmFtZSk7XG4gICAgICAgIGlmIChzbG90Tm9kZSkge1xuICAgICAgICAgICAgY29uc3Qgc2xvdENoaWxkTm9kZXMgPSBnZXRIb3N0U2xvdENoaWxkTm9kZXMoc2xvdE5vZGUsIHNsb3ROYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGFwcGVuZEFmdGVyID0gc2xvdENoaWxkTm9kZXNbc2xvdENoaWxkTm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICByZXR1cm4gYXBwZW5kQWZ0ZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Q2hpbGQsIGFwcGVuZEFmdGVyLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fX2FwcGVuZENoaWxkKG5ld0NoaWxkKTtcbiAgICB9O1xufTtcbmNvbnN0IHBhdGNoQ2hpbGRTbG90Tm9kZXMgPSAoZWxtLCBjbXBNZXRhKSA9PiB7XG4gICAgY2xhc3MgRmFrZU5vZGVMaXN0IGV4dGVuZHMgQXJyYXkge1xuICAgICAgICBpdGVtKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW25dO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbXBNZXRhLiRmbGFncyQgJiA4IC8qIG5lZWRzU2hhZG93RG9tU2hpbSAqLykge1xuICAgICAgICBjb25zdCBjaGlsZE5vZGVzRm4gPSBlbG0uX19sb29rdXBHZXR0ZXJfXygnY2hpbGROb2RlcycpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxtLCAnY2hpbGRyZW4nLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2Rlcy5tYXAoKG4pID0+IG4ubm9kZVR5cGUgPT09IDEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbG0sICdjaGlsZEVsZW1lbnRDb3VudCcsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxtLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxtLCAnY2hpbGROb2RlcycsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gY2hpbGROb2Rlc0ZuLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKChwbHQuJGZsYWdzJCAmIDEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi8pID09PSAwICYmIGdldEhvc3RSZWYodGhpcykuJGZsYWdzJCAmIDIgLyogaGFzUmVuZGVyZWQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEZha2VOb2RlTGlzdCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNsb3QgPSBjaGlsZE5vZGVzW2ldWydzLW5yJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNsb3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBGYWtlTm9kZUxpc3QuZnJvbShjaGlsZE5vZGVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5jb25zdCBnZXRTbG90TmFtZSA9IChub2RlKSA9PiBub2RlWydzLXNuJ10gfHwgKG5vZGUubm9kZVR5cGUgPT09IDEgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ3Nsb3QnKSkgfHwgJyc7XG5jb25zdCBnZXRIb3N0U2xvdE5vZGUgPSAoY2hpbGROb2Rlcywgc2xvdE5hbWUpID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGNoaWxkTm9kZTtcbiAgICBmb3IgKDsgaSA8IGNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgaWYgKGNoaWxkTm9kZVsncy1zciddICYmIGNoaWxkTm9kZVsncy1zbiddID09PSBzbG90TmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZE5vZGUgPSBnZXRIb3N0U2xvdE5vZGUoY2hpbGROb2RlLmNoaWxkTm9kZXMsIHNsb3ROYW1lKTtcbiAgICAgICAgaWYgKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5jb25zdCBnZXRIb3N0U2xvdENoaWxkTm9kZXMgPSAobiwgc2xvdE5hbWUpID0+IHtcbiAgICBjb25zdCBjaGlsZE5vZGVzID0gW25dO1xuICAgIHdoaWxlICgobiA9IG4ubmV4dFNpYmxpbmcpICYmIG5bJ3Mtc24nXSA9PT0gc2xvdE5hbWUpIHtcbiAgICAgICAgY2hpbGROb2Rlcy5wdXNoKG4pO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGROb2Rlcztcbn07XG5jb25zdCBib290c3RyYXBMYXp5ID0gKGxhenlCdW5kbGVzLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBpZiAoQlVJTEQucHJvZmlsZSAmJiBwZXJmb3JtYW5jZS5tYXJrKSB7XG4gICAgICAgIHBlcmZvcm1hbmNlLm1hcmsoJ3N0OmFwcDpzdGFydCcpO1xuICAgIH1cbiAgICBpbnN0YWxsRGV2VG9vbHMoKTtcbiAgICBjb25zdCBlbmRCb290c3RyYXAgPSBjcmVhdGVUaW1lKCdib290c3RyYXBMYXp5Jyk7XG4gICAgY29uc3QgY21wVGFncyA9IFtdO1xuICAgIGNvbnN0IGV4Y2x1ZGUgPSBvcHRpb25zLmV4Y2x1ZGUgfHwgW107XG4gICAgY29uc3QgY3VzdG9tRWxlbWVudHMgPSB3aW4uY3VzdG9tRWxlbWVudHM7XG4gICAgY29uc3QgaGVhZCA9IGRvYy5oZWFkO1xuICAgIGNvbnN0IG1ldGFDaGFyc2V0ID0gLypAX19QVVJFX18qLyBoZWFkLnF1ZXJ5U2VsZWN0b3IoJ21ldGFbY2hhcnNldF0nKTtcbiAgICBjb25zdCB2aXNpYmlsaXR5U3R5bGUgPSAvKkBfX1BVUkVfXyovIGRvYy5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIGNvbnN0IGRlZmVycmVkQ29ubmVjdGVkQ2FsbGJhY2tzID0gW107XG4gICAgY29uc3Qgc3R5bGVzID0gLypAX19QVVJFX18qLyBkb2MucXVlcnlTZWxlY3RvckFsbChgWyR7SFlEUkFURURfU1RZTEVfSUR9XWApO1xuICAgIGxldCBhcHBMb2FkRmFsbGJhY2s7XG4gICAgbGV0IGlzQm9vdHN0cmFwcGluZyA9IHRydWU7XG4gICAgbGV0IGkgPSAwO1xuICAgIE9iamVjdC5hc3NpZ24ocGx0LCBvcHRpb25zKTtcbiAgICBwbHQuJHJlc291cmNlc1VybCQgPSBuZXcgVVJMKG9wdGlvbnMucmVzb3VyY2VzVXJsIHx8ICcuLycsIGRvYy5iYXNlVVJJKS5ocmVmO1xuICAgIGlmIChCVUlMRC5hc3luY1F1ZXVlKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnN5bmNRdWV1ZSkge1xuICAgICAgICAgICAgcGx0LiRmbGFncyQgfD0gNCAvKiBxdWV1ZVN5bmMgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKEJVSUxELmh5ZHJhdGVDbGllbnRTaWRlKSB7XG4gICAgICAgIC8vIElmIHRoZSBhcHAgaXMgYWxyZWFkeSBoeWRyYXRlZCB0aGVyZSBpcyBub3QgcG9pbnQgdG8gZGlzYWJsZSB0aGVcbiAgICAgICAgLy8gYXN5bmMgcXVldWUuIFRoaXMgd2lsbCBpbXByb3ZlIHRoZSBmaXJzdCBpbnB1dCBkZWxheVxuICAgICAgICBwbHQuJGZsYWdzJCB8PSAyIC8qIGFwcExvYWRlZCAqLztcbiAgICB9XG4gICAgaWYgKEJVSUxELmh5ZHJhdGVDbGllbnRTaWRlICYmIEJVSUxELnNoYWRvd0RvbSkge1xuICAgICAgICBmb3IgKDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVnaXN0ZXJTdHlsZShzdHlsZXNbaV0uZ2V0QXR0cmlidXRlKEhZRFJBVEVEX1NUWUxFX0lEKSwgY29udmVydFNjb3BlZFRvU2hhZG93KHN0eWxlc1tpXS5pbm5lckhUTUwpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsYXp5QnVuZGxlcy5tYXAobGF6eUJ1bmRsZSA9PiBsYXp5QnVuZGxlWzFdLm1hcChjb21wYWN0TWV0YSA9PiB7XG4gICAgICAgIGNvbnN0IGNtcE1ldGEgPSB7XG4gICAgICAgICAgICAkZmxhZ3MkOiBjb21wYWN0TWV0YVswXSxcbiAgICAgICAgICAgICR0YWdOYW1lJDogY29tcGFjdE1ldGFbMV0sXG4gICAgICAgICAgICAkbWVtYmVycyQ6IGNvbXBhY3RNZXRhWzJdLFxuICAgICAgICAgICAgJGxpc3RlbmVycyQ6IGNvbXBhY3RNZXRhWzNdLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoQlVJTEQubWVtYmVyKSB7XG4gICAgICAgICAgICBjbXBNZXRhLiRtZW1iZXJzJCA9IGNvbXBhY3RNZXRhWzJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNtcE1ldGEuJGxpc3RlbmVycyQgPSBjb21wYWN0TWV0YVszXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQucmVmbGVjdCkge1xuICAgICAgICAgICAgY21wTWV0YS4kYXR0cnNUb1JlZmxlY3QkID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELndhdGNoQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNtcE1ldGEuJHdhdGNoZXJzJCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5zaGFkb3dEb20gJiYgIXN1cHBvcnRzU2hhZG93ICYmIGNtcE1ldGEuJGZsYWdzJCAmIDEgLyogc2hhZG93RG9tRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgICAgY21wTWV0YS4kZmxhZ3MkIHw9IDggLyogbmVlZHNTaGFkb3dEb21TaGltICovO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSBCVUlMRC50cmFuc2Zvcm1UYWdOYW1lICYmIG9wdGlvbnMudHJhbnNmb3JtVGFnTmFtZSA/IG9wdGlvbnMudHJhbnNmb3JtVGFnTmFtZShjbXBNZXRhLiR0YWdOYW1lJCkgOiBjbXBNZXRhLiR0YWdOYW1lJDtcbiAgICAgICAgY29uc3QgSG9zdEVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICAgICAgICAgIC8vIFN0ZW5jaWxMYXp5SG9zdFxuICAgICAgICAgICAgY29uc3RydWN0b3Ioc2VsZikge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBzdXBlcihzZWxmKTtcbiAgICAgICAgICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZWdpc3Rlckhvc3Qoc2VsZiwgY21wTWV0YSk7XG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiBjbXBNZXRhLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjb21wb25lbnQgaXMgdXNpbmcgc2hhZG93IGRvbVxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhpcyBicm93c2VyIHN1cHBvcnRzIHNoYWRvdyBkb21cbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSByZWFkLW9ubHkgcHJvcGVydHkgXCJzaGFkb3dSb290XCIgdG8gdGhlIGhvc3QgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAvLyBhZGRpbmcgdGhlIHNoYWRvdyByb290IGJ1aWxkIGNvbmRpdGlvbmFscyB0byBtaW5pbWl6ZSBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0c1NoYWRvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnNoYWRvd0RlbGVnYXRlc0ZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hdHRhY2hTaGFkb3coe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiAnb3BlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlc0ZvY3VzOiAhIShjbXBNZXRhLiRmbGFncyQgJiAxNiAvKiBzaGFkb3dEZWxlZ2F0ZXNGb2N1cyAqLyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgJiYgISgnc2hhZG93Um9vdCcgaW4gc2VsZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2hhZG93Um9vdCA9IHNlbGY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELnNsb3RDaGlsZE5vZGVzRml4KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoQ2hpbGRTbG90Tm9kZXMoc2VsZiwgY21wTWV0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFwcExvYWRGYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoYXBwTG9hZEZhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgYXBwTG9hZEZhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzQm9vdHN0cmFwcGluZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25uZWN0ZWRDYWxsYmFjayB3aWxsIGJlIHByb2Nlc3NlZCBvbmNlIGFsbCBjb21wb25lbnRzIGhhdmUgYmVlbiByZWdpc3RlcmVkXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkQ29ubmVjdGVkQ2FsbGJhY2tzLnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwbHQuam1wKCgpID0+IGNvbm5lY3RlZENhbGxiYWNrKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgICAgICBwbHQuam1wKCgpID0+IGRpc2Nvbm5lY3RlZENhbGxiYWNrKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvbmVudE9uUmVhZHkoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEhvc3RSZWYodGhpcykuJG9uUmVhZHlQcm9taXNlJDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKEJVSUxELmNsb25lTm9kZUZpeCkge1xuICAgICAgICAgICAgcGF0Y2hDbG9uZU5vZGUoSG9zdEVsZW1lbnQucHJvdG90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQuYXBwZW5kQ2hpbGRTbG90Rml4KSB7XG4gICAgICAgICAgICBwYXRjaFNsb3RBcHBlbmRDaGlsZChIb3N0RWxlbWVudC5wcm90b3R5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5ob3RNb2R1bGVSZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgSG9zdEVsZW1lbnQucHJvdG90eXBlWydzLWhtciddID0gZnVuY3Rpb24gKGhtclZlcnNpb25JZCkge1xuICAgICAgICAgICAgICAgIGhtclN0YXJ0KHRoaXMsIGNtcE1ldGEsIGhtclZlcnNpb25JZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNtcE1ldGEuJGxhenlCdW5kbGVJZCQgPSBsYXp5QnVuZGxlWzBdO1xuICAgICAgICBpZiAoIWV4Y2x1ZGUuaW5jbHVkZXModGFnTmFtZSkgJiYgIWN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkge1xuICAgICAgICAgICAgY21wVGFncy5wdXNoKHRhZ05hbWUpO1xuICAgICAgICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKHRhZ05hbWUsIHByb3h5Q29tcG9uZW50KEhvc3RFbGVtZW50LCBjbXBNZXRhLCAxIC8qIGlzRWxlbWVudENvbnN0cnVjdG9yICovKSk7XG4gICAgICAgIH1cbiAgICB9KSk7XG4gICAgaWYgKEJVSUxELmh5ZHJhdGVkQ2xhc3MgfHwgQlVJTEQuaHlkcmF0ZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgdmlzaWJpbGl0eVN0eWxlLmlubmVySFRNTCA9IGNtcFRhZ3MgKyBIWURSQVRFRF9DU1M7XG4gICAgICAgIHZpc2liaWxpdHlTdHlsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3R5bGVzJywgJycpO1xuICAgICAgICBoZWFkLmluc2VydEJlZm9yZSh2aXNpYmlsaXR5U3R5bGUsIG1ldGFDaGFyc2V0ID8gbWV0YUNoYXJzZXQubmV4dFNpYmxpbmcgOiBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICAvLyBQcm9jZXNzIGRlZmVycmVkIGNvbm5lY3RlZENhbGxiYWNrcyBub3cgYWxsIGNvbXBvbmVudHMgaGF2ZSBiZWVuIHJlZ2lzdGVyZWRcbiAgICBpc0Jvb3RzdHJhcHBpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVmZXJyZWRDb25uZWN0ZWRDYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgIGRlZmVycmVkQ29ubmVjdGVkQ2FsbGJhY2tzLm1hcChob3N0ID0+IGhvc3QuY29ubmVjdGVkQ2FsbGJhY2soKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoQlVJTEQucHJvZmlsZSkge1xuICAgICAgICAgICAgcGx0LmptcCgoKSA9PiAoYXBwTG9hZEZhbGxiYWNrID0gc2V0VGltZW91dChhcHBEaWRMb2FkLCAzMCwgJ3RpbWVvdXQnKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGx0LmptcCgoKSA9PiAoYXBwTG9hZEZhbGxiYWNrID0gc2V0VGltZW91dChhcHBEaWRMb2FkLCAzMCkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBGYWxsYmFjayBhcHBMb2FkIGV2ZW50XG4gICAgZW5kQm9vdHN0cmFwKCk7XG59O1xuY29uc3QgZ2V0QXNzZXRQYXRoID0gKHBhdGgpID0+IHtcbiAgICBjb25zdCBhc3NldFVybCA9IG5ldyBVUkwocGF0aCwgcGx0LiRyZXNvdXJjZXNVcmwkKTtcbiAgICByZXR1cm4gYXNzZXRVcmwub3JpZ2luICE9PSB3aW4ubG9jYXRpb24ub3JpZ2luID8gYXNzZXRVcmwuaHJlZiA6IGFzc2V0VXJsLnBhdGhuYW1lO1xufTtcbmNvbnN0IHNldEFzc2V0UGF0aCA9IChwYXRoKSA9PiAocGx0LiRyZXNvdXJjZXNVcmwkID0gcGF0aCk7XG5jb25zdCBnZXRDb25uZWN0ID0gKF9yZWYsIHRhZ05hbWUpID0+IHtcbiAgICBjb25zdCBjb21wb25lbnRPblJlYWR5ID0gKCkgPT4ge1xuICAgICAgICBsZXQgZWxtID0gZG9jLnF1ZXJ5U2VsZWN0b3IodGFnTmFtZSk7XG4gICAgICAgIGlmICghZWxtKSB7XG4gICAgICAgICAgICBlbG0gPSBkb2MuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICAgICAgICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKGVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiBlbG0uY29tcG9uZW50T25SZWFkeSA9PT0gJ2Z1bmN0aW9uJyA/IGVsbS5jb21wb25lbnRPblJlYWR5KCkgOiBQcm9taXNlLnJlc29sdmUoZWxtKTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRPblJlYWR5KCkudGhlbihlbCA9PiBlbC5jcmVhdGUoLi4uYXJncykpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlLFxuICAgICAgICBjb21wb25lbnRPblJlYWR5LFxuICAgIH07XG59O1xuY29uc3QgZ2V0Q29udGV4dCA9IChfZWxtLCBjb250ZXh0KSA9PiB7XG4gICAgaWYgKGNvbnRleHQgaW4gQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gQ29udGV4dFtjb250ZXh0XTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgICAgcmV0dXJuIHdpbjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCA9PT0gJ2RvY3VtZW50Jykge1xuICAgICAgICByZXR1cm4gZG9jO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb250ZXh0ID09PSAnaXNTZXJ2ZXInIHx8IGNvbnRleHQgPT09ICdpc1ByZXJlbmRlcicpIHtcbiAgICAgICAgcmV0dXJuIEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb250ZXh0ID09PSAnaXNDbGllbnQnKSB7XG4gICAgICAgIHJldHVybiBCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSA/IGZhbHNlIDogdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCA9PT0gJ3Jlc291cmNlc1VybCcgfHwgY29udGV4dCA9PT0gJ3B1YmxpY1BhdGgnKSB7XG4gICAgICAgIHJldHVybiBnZXRBc3NldFBhdGgoJy4nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCA9PT0gJ3F1ZXVlJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd3JpdGU6IHdyaXRlVGFzayxcbiAgICAgICAgICAgIHJlYWQ6IHJlYWRUYXNrLFxuICAgICAgICAgICAgdGljazoge1xuICAgICAgICAgICAgICAgIHRoZW4oY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHRUaWNrKGNiKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5jb25zdCBpbnNlcnRWZG9tQW5ub3RhdGlvbnMgPSAoZG9jLCBzdGF0aWNDb21wb25lbnRzKSA9PiB7XG4gICAgaWYgKGRvYyAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGRvY0RhdGEgPSB7XG4gICAgICAgICAgICBob3N0SWRzOiAwLFxuICAgICAgICAgICAgcm9vdExldmVsSWRzOiAwLFxuICAgICAgICAgICAgc3RhdGljQ29tcG9uZW50czogbmV3IFNldChzdGF0aWNDb21wb25lbnRzKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb3JnTG9jYXRpb25Ob2RlcyA9IFtdO1xuICAgICAgICBwYXJzZVZOb2RlQW5ub3RhdGlvbnMoZG9jLCBkb2MuYm9keSwgZG9jRGF0YSwgb3JnTG9jYXRpb25Ob2Rlcyk7XG4gICAgICAgIG9yZ0xvY2F0aW9uTm9kZXMuZm9yRWFjaChvcmdMb2NhdGlvbk5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKG9yZ0xvY2F0aW9uTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVJlZiA9IG9yZ0xvY2F0aW9uTm9kZVsncy1uciddO1xuICAgICAgICAgICAgICAgIGxldCBob3N0SWQgPSBub2RlUmVmWydzLWhvc3QtaWQnXTtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZUlkID0gbm9kZVJlZlsncy1ub2RlLWlkJ107XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkSWQgPSBgJHtob3N0SWR9LiR7bm9kZUlkfWA7XG4gICAgICAgICAgICAgICAgaWYgKGhvc3RJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RJZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGRvY0RhdGEucm9vdExldmVsSWRzKys7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJZCA9IGRvY0RhdGEucm9vdExldmVsSWRzO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZElkID0gYCR7aG9zdElkfS4ke25vZGVJZH1gO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVJlZi5ub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVJlZi5zZXRBdHRyaWJ1dGUoSFlEUkFURV9DSElMRF9JRCwgY2hpbGRJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZVJlZi5ub2RlVHlwZSA9PT0gMyAvKiBUZXh0Tm9kZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvc3RJZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gbm9kZVJlZi5ub2RlVmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0Q29udGVudCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlbGVzcyB3aGl0ZXNwYWNlIG5vZGUgYXQgdGhlIGRvY3VtZW50IHJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JnTG9jYXRpb25Ob2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tbWVudEJlZm9yZVRleHROb2RlID0gZG9jLmNyZWF0ZUNvbW1lbnQoY2hpbGRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50QmVmb3JlVGV4dE5vZGUubm9kZVZhbHVlID0gYCR7VEVYVF9OT0RFX0lEfS4ke2NoaWxkSWR9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVSZWYucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY29tbWVudEJlZm9yZVRleHROb2RlLCBub2RlUmVmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgb3JnTG9jYXRpb25Ob2RlSWQgPSBgJHtPUkdfTE9DQVRJT05fSUR9LiR7Y2hpbGRJZH1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yZ0xvY2F0aW9uUGFyZW50Tm9kZSA9IG9yZ0xvY2F0aW9uTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIGlmIChvcmdMb2NhdGlvblBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yZ0xvY2F0aW9uUGFyZW50Tm9kZVsncy1lbiddID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5kaW5nIHdpdGggYSBcIi5cIiBtZWFucyB0aGF0IHRoZSBwYXJlbnQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhpcyBub2RlJ3Mgb3JpZ2luYWwgbG9jYXRpb24gaXMgYSBTSEFET1cgZG9tIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGlzIG5vZGUgaXMgYXBhcnQgb2YgdGhlIHJvb3QgbGV2ZWwgbGlnaHQgZG9tXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGVJZCArPSBgLmA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3JnTG9jYXRpb25QYXJlbnROb2RlWydzLWVuJ10gPT09ICdjJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5kaW5nIHdpdGggYSBcIi5jXCIgbWVhbnMgdGhhdCB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoaXMgbm9kZSdzIG9yaWdpbmFsIGxvY2F0aW9uIGlzIGEgU0NPUEVEIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGlzIG5vZGUgaXMgYXBhcnQgb2YgdGhlIHJvb3QgbGV2ZWwgbGlnaHQgZG9tXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGVJZCArPSBgLmNgO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZS5ub2RlVmFsdWUgPSBvcmdMb2NhdGlvbk5vZGVJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IHBhcnNlVk5vZGVBbm5vdGF0aW9ucyA9IChkb2MsIG5vZGUsIGRvY0RhdGEsIG9yZ0xvY2F0aW9uTm9kZXMpID0+IHtcbiAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5vZGVbJ3MtbnInXSAhPSBudWxsKSB7XG4gICAgICAgIG9yZ0xvY2F0aW9uTm9kZXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgbm9kZS5jaGlsZE5vZGVzLmZvckVhY2goY2hpbGROb2RlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICBpZiAoaG9zdFJlZiAhPSBudWxsICYmICFkb2NEYXRhLnN0YXRpY0NvbXBvbmVudHMuaGFzKGNoaWxkTm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNtcERhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJZHM6IDAsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpbnNlcnRWTm9kZUFubm90YXRpb25zKGRvYywgY2hpbGROb2RlLCBob3N0UmVmLiR2bm9kZSQsIGRvY0RhdGEsIGNtcERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VWTm9kZUFubm90YXRpb25zKGRvYywgY2hpbGROb2RlLCBkb2NEYXRhLCBvcmdMb2NhdGlvbk5vZGVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IGluc2VydFZOb2RlQW5ub3RhdGlvbnMgPSAoZG9jLCBob3N0RWxtLCB2bm9kZSwgZG9jRGF0YSwgY21wRGF0YSkgPT4ge1xuICAgIGlmICh2bm9kZSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGhvc3RJZCA9ICsrZG9jRGF0YS5ob3N0SWRzO1xuICAgICAgICBob3N0RWxtLnNldEF0dHJpYnV0ZShIWURSQVRFX0lELCBob3N0SWQpO1xuICAgICAgICBpZiAoaG9zdEVsbVsncy1jciddICE9IG51bGwpIHtcbiAgICAgICAgICAgIGhvc3RFbG1bJ3MtY3InXS5ub2RlVmFsdWUgPSBgJHtDT05URU5UX1JFRl9JRH0uJHtob3N0SWR9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm5vZGUuJGNoaWxkcmVuJCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBkZXB0aCA9IDA7XG4gICAgICAgICAgICB2bm9kZS4kY2hpbGRyZW4kLmZvckVhY2goKHZub2RlQ2hpbGQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0Q2hpbGRWTm9kZUFubm90YXRpb25zKGRvYywgdm5vZGVDaGlsZCwgY21wRGF0YSwgaG9zdElkLCBkZXB0aCwgaW5kZXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvc3RFbG0gJiYgdm5vZGUgJiYgdm5vZGUuJGVsbSQgJiYgIWhvc3RFbG0uaGFzQXR0cmlidXRlKCdjLWlkJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGhvc3RFbG0ucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LmNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRDaGlsZE5vZGVzID0gQXJyYXkuZnJvbShwYXJlbnQuY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IHBhcmVudENoaWxkTm9kZXMuZmluZChub2RlID0+IG5vZGUubm9kZVR5cGUgPT09IDggLyogQ29tbWVudE5vZGUgKi8gJiYgbm9kZVsncy1zciddKTtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHBhcmVudENoaWxkTm9kZXMuaW5kZXhPZihob3N0RWxtKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHZub2RlLiRlbG0kLnNldEF0dHJpYnV0ZShIWURSQVRFX0NISUxEX0lELCBgJHtjb21tZW50WydzLWhvc3QtaWQnXX0uJHtjb21tZW50WydzLW5vZGUtaWQnXX0uMC4ke2luZGV4fWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBpbnNlcnRDaGlsZFZOb2RlQW5ub3RhdGlvbnMgPSAoZG9jLCB2bm9kZUNoaWxkLCBjbXBEYXRhLCBob3N0SWQsIGRlcHRoLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGNoaWxkRWxtID0gdm5vZGVDaGlsZC4kZWxtJDtcbiAgICBpZiAoY2hpbGRFbG0gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vZGVJZCA9IGNtcERhdGEubm9kZUlkcysrO1xuICAgIGNvbnN0IGNoaWxkSWQgPSBgJHtob3N0SWR9LiR7bm9kZUlkfS4ke2RlcHRofS4ke2luZGV4fWA7XG4gICAgY2hpbGRFbG1bJ3MtaG9zdC1pZCddID0gaG9zdElkO1xuICAgIGNoaWxkRWxtWydzLW5vZGUtaWQnXSA9IG5vZGVJZDtcbiAgICBpZiAoY2hpbGRFbG0ubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgY2hpbGRFbG0uc2V0QXR0cmlidXRlKEhZRFJBVEVfQ0hJTERfSUQsIGNoaWxkSWQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGlsZEVsbS5ub2RlVHlwZSA9PT0gMyAvKiBUZXh0Tm9kZSAqLykge1xuICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gY2hpbGRFbG0ucGFyZW50Tm9kZTtcbiAgICAgICAgY29uc3Qgbm9kZU5hbWUgPSBwYXJlbnROb2RlLm5vZGVOYW1lO1xuICAgICAgICBpZiAobm9kZU5hbWUgIT09ICdTVFlMRScgJiYgbm9kZU5hbWUgIT09ICdTQ1JJUFQnKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0Tm9kZUlkID0gYCR7VEVYVF9OT0RFX0lEfS4ke2NoaWxkSWR9YDtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1lbnRCZWZvcmVUZXh0Tm9kZSA9IGRvYy5jcmVhdGVDb21tZW50KHRleHROb2RlSWQpO1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY29tbWVudEJlZm9yZVRleHROb2RlLCBjaGlsZEVsbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoY2hpbGRFbG0ubm9kZVR5cGUgPT09IDggLyogQ29tbWVudE5vZGUgKi8pIHtcbiAgICAgICAgaWYgKGNoaWxkRWxtWydzLXNyJ10pIHtcbiAgICAgICAgICAgIGNvbnN0IHNsb3ROYW1lID0gY2hpbGRFbG1bJ3Mtc24nXSB8fCAnJztcbiAgICAgICAgICAgIGNvbnN0IHNsb3ROb2RlSWQgPSBgJHtTTE9UX05PREVfSUR9LiR7Y2hpbGRJZH0uJHtzbG90TmFtZX1gO1xuICAgICAgICAgICAgY2hpbGRFbG0ubm9kZVZhbHVlID0gc2xvdE5vZGVJZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodm5vZGVDaGlsZC4kY2hpbGRyZW4kICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgY2hpbGREZXB0aCA9IGRlcHRoICsgMTtcbiAgICAgICAgdm5vZGVDaGlsZC4kY2hpbGRyZW4kLmZvckVhY2goKHZub2RlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaW5zZXJ0Q2hpbGRWTm9kZUFubm90YXRpb25zKGRvYywgdm5vZGUsIGNtcERhdGEsIGhvc3RJZCwgY2hpbGREZXB0aCwgaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3Qgc2V0UGxhdGZvcm1PcHRpb25zID0gKG9wdHMpID0+IE9iamVjdC5hc3NpZ24ocGx0LCBvcHRzKTtcbmNvbnN0IEZyYWdtZW50ID0gKF8sIGNoaWxkcmVuKSA9PiBjaGlsZHJlbjtcbmNvbnN0IGhvc3RSZWZzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGdldEhvc3RSZWYgPSAocmVmKSA9PiBob3N0UmVmcy5nZXQocmVmKTtcbmNvbnN0IHJlZ2lzdGVySW5zdGFuY2UgPSAobGF6eUluc3RhbmNlLCBob3N0UmVmKSA9PiBob3N0UmVmcy5zZXQoKGhvc3RSZWYuJGxhenlJbnN0YW5jZSQgPSBsYXp5SW5zdGFuY2UpLCBob3N0UmVmKTtcbmNvbnN0IHJlZ2lzdGVySG9zdCA9IChlbG0sIGNtcE1ldGEpID0+IHtcbiAgICBjb25zdCBob3N0UmVmID0ge1xuICAgICAgICAkZmxhZ3MkOiAwLFxuICAgICAgICAkaG9zdEVsZW1lbnQkOiBlbG0sXG4gICAgICAgICRjbXBNZXRhJDogY21wTWV0YSxcbiAgICAgICAgJGluc3RhbmNlVmFsdWVzJDogbmV3IE1hcCgpLFxuICAgIH07XG4gICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgIGhvc3RSZWYuJHJlbmRlckNvdW50JCA9IDA7XG4gICAgfVxuICAgIGlmIChCVUlMRC5tZXRob2QgJiYgQlVJTEQubGF6eUxvYWQpIHtcbiAgICAgICAgaG9zdFJlZi4kb25JbnN0YW5jZVByb21pc2UkID0gbmV3IFByb21pc2UociA9PiAoaG9zdFJlZi4kb25JbnN0YW5jZVJlc29sdmUkID0gcikpO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nKSB7XG4gICAgICAgIGhvc3RSZWYuJG9uUmVhZHlQcm9taXNlJCA9IG5ldyBQcm9taXNlKHIgPT4gKGhvc3RSZWYuJG9uUmVhZHlSZXNvbHZlJCA9IHIpKTtcbiAgICAgICAgZWxtWydzLXAnXSA9IFtdO1xuICAgICAgICBlbG1bJ3MtcmMnXSA9IFtdO1xuICAgIH1cbiAgICBhZGRIb3N0RXZlbnRMaXN0ZW5lcnMoZWxtLCBob3N0UmVmLCBjbXBNZXRhLiRsaXN0ZW5lcnMkLCBmYWxzZSk7XG4gICAgcmV0dXJuIGhvc3RSZWZzLnNldChlbG0sIGhvc3RSZWYpO1xufTtcbmNvbnN0IGlzTWVtYmVySW5FbGVtZW50ID0gKGVsbSwgbWVtYmVyTmFtZSkgPT4gbWVtYmVyTmFtZSBpbiBlbG07XG5jb25zdCBjb25zb2xlRXJyb3IgPSAoZSwgZWwpID0+IChjdXN0b21FcnJvciB8fCBjb25zb2xlLmVycm9yKShlLCBlbCk7XG5jb25zdCBTVEVOQ0lMX0RFVl9NT0RFID0gQlVJTEQuaXNUZXN0aW5nXG4gICAgPyBbJ1NURU5DSUw6J10gLy8gRTJFIHRlc3RpbmdcbiAgICA6IFsnJWNzdGVuY2lsJywgJ2NvbG9yOiB3aGl0ZTtiYWNrZ3JvdW5kOiM0YzQ3ZmY7Zm9udC13ZWlnaHQ6IGJvbGQ7IGZvbnQtc2l6ZToxMHB4OyBwYWRkaW5nOjJweCA2cHg7IGJvcmRlci1yYWRpdXM6IDVweCddO1xuY29uc3QgY29uc29sZURldkVycm9yID0gKC4uLm0pID0+IGNvbnNvbGUuZXJyb3IoLi4uU1RFTkNJTF9ERVZfTU9ERSwgLi4ubSk7XG5jb25zdCBjb25zb2xlRGV2V2FybiA9ICguLi5tKSA9PiBjb25zb2xlLndhcm4oLi4uU1RFTkNJTF9ERVZfTU9ERSwgLi4ubSk7XG5jb25zdCBjb25zb2xlRGV2SW5mbyA9ICguLi5tKSA9PiBjb25zb2xlLmluZm8oLi4uU1RFTkNJTF9ERVZfTU9ERSwgLi4ubSk7XG5jb25zdCBzZXRFcnJvckhhbmRsZXIgPSAoaGFuZGxlcikgPT4gY3VzdG9tRXJyb3IgPSBoYW5kbGVyO1xuY29uc3QgY21wTW9kdWxlcyA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hcCgpO1xuY29uc3QgbG9hZE1vZHVsZSA9IChjbXBNZXRhLCBob3N0UmVmLCBobXJWZXJzaW9uSWQpID0+IHtcbiAgICAvLyBsb2FkTW9kdWxlSW1wb3J0XG4gICAgY29uc3QgZXhwb3J0TmFtZSA9IGNtcE1ldGEuJHRhZ05hbWUkLnJlcGxhY2UoLy0vZywgJ18nKTtcbiAgICBjb25zdCBidW5kbGVJZCA9IGNtcE1ldGEuJGxhenlCdW5kbGVJZCQ7XG4gICAgaWYgKEJVSUxELmlzRGV2ICYmIHR5cGVvZiBidW5kbGVJZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc29sZURldkVycm9yKGBUcnlpbmcgdG8gbGF6aWx5IGxvYWQgY29tcG9uZW50IDwke2NtcE1ldGEuJHRhZ05hbWUkfT4gd2l0aCBzdHlsZSBtb2RlIFwiJHtob3N0UmVmLiRtb2RlTmFtZSR9XCIsIGJ1dCBpdCBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgbW9kdWxlID0gIUJVSUxELmhvdE1vZHVsZVJlcGxhY2VtZW50ID8gY21wTW9kdWxlcy5nZXQoYnVuZGxlSWQpIDogZmFsc2U7XG4gICAgaWYgKG1vZHVsZSkge1xuICAgICAgICByZXR1cm4gbW9kdWxlW2V4cG9ydE5hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gaW1wb3J0KFxuICAgIC8qIHdlYnBhY2tJbmNsdWRlOiAvXFwuZW50cnlcXC5qcyQvICovXG4gICAgLyogd2VicGFja0V4Y2x1ZGU6IC9cXC5zeXN0ZW1cXC5lbnRyeVxcLmpzJC8gKi9cbiAgICAvKiB3ZWJwYWNrTW9kZTogXCJsYXp5XCIgKi9cbiAgICBgLi8ke2J1bmRsZUlkfS5lbnRyeS5qcyR7QlVJTEQuaG90TW9kdWxlUmVwbGFjZW1lbnQgJiYgaG1yVmVyc2lvbklkID8gJz9zLWhtcj0nICsgaG1yVmVyc2lvbklkIDogJyd9YCkudGhlbihpbXBvcnRlZE1vZHVsZSA9PiB7XG4gICAgICAgIGlmICghQlVJTEQuaG90TW9kdWxlUmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIGNtcE1vZHVsZXMuc2V0KGJ1bmRsZUlkLCBpbXBvcnRlZE1vZHVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltcG9ydGVkTW9kdWxlW2V4cG9ydE5hbWVdO1xuICAgIH0sIGNvbnNvbGVFcnJvcik7XG59O1xuY29uc3Qgc3R5bGVzID0gbmV3IE1hcCgpO1xuY29uc3QgbW9kZVJlc29sdXRpb25DaGFpbiA9IFtdO1xuY29uc3QgcXVldWVEb21SZWFkcyA9IFtdO1xuY29uc3QgcXVldWVEb21Xcml0ZXMgPSBbXTtcbmNvbnN0IHF1ZXVlRG9tV3JpdGVzTG93ID0gW107XG5jb25zdCBxdWV1ZVRhc2sgPSAocXVldWUsIHdyaXRlKSA9PiAoY2IpID0+IHtcbiAgICBxdWV1ZS5wdXNoKGNiKTtcbiAgICBpZiAoIXF1ZXVlUGVuZGluZykge1xuICAgICAgICBxdWV1ZVBlbmRpbmcgPSB0cnVlO1xuICAgICAgICBpZiAod3JpdGUgJiYgcGx0LiRmbGFncyQgJiA0IC8qIHF1ZXVlU3luYyAqLykge1xuICAgICAgICAgICAgbmV4dFRpY2soZmx1c2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGx0LnJhZihmbHVzaCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgY29uc3VtZSA9IChxdWV1ZSkgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHF1ZXVlW2ldKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZUVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG59O1xuY29uc3QgY29uc3VtZVRpbWVvdXQgPSAocXVldWUsIHRpbWVvdXQpID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IHRzID0gMDtcbiAgICB3aGlsZSAoaSA8IHF1ZXVlLmxlbmd0aCAmJiAodHMgPSBwZXJmb3JtYW5jZS5ub3coKSkgPCB0aW1lb3V0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBxdWV1ZVtpKytdKHRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZUVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpID09PSBxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaSAhPT0gMCkge1xuICAgICAgICBxdWV1ZS5zcGxpY2UoMCwgaSk7XG4gICAgfVxufTtcbmNvbnN0IGZsdXNoID0gKCkgPT4ge1xuICAgIGlmIChCVUlMRC5hc3luY1F1ZXVlKSB7XG4gICAgICAgIHF1ZXVlQ29uZ2VzdGlvbisrO1xuICAgIH1cbiAgICAvLyBhbHdheXMgZm9yY2UgYSBidW5jaCBvZiBtZWRpdW0gY2FsbGJhY2tzIHRvIHJ1biwgYnV0IHN0aWxsIGhhdmVcbiAgICAvLyBhIHRocm90dGxlIG9uIGhvdyBtYW55IGNhbiBydW4gaW4gYSBjZXJ0YWluIHRpbWVcbiAgICAvLyBET00gUkVBRFMhISFcbiAgICBjb25zdW1lKHF1ZXVlRG9tUmVhZHMpO1xuICAgIC8vIERPTSBXUklURVMhISFcbiAgICBpZiAoQlVJTEQuYXN5bmNRdWV1ZSkge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gKHBsdC4kZmxhZ3MkICYgNiAvKiBxdWV1ZU1hc2sgKi8pID09PSAyIC8qIGFwcExvYWRlZCAqLyA/IHBlcmZvcm1hbmNlLm5vdygpICsgMTQgKiBNYXRoLmNlaWwocXVldWVDb25nZXN0aW9uICogKDEuMCAvIDEwLjApKSA6IEluZmluaXR5O1xuICAgICAgICBjb25zdW1lVGltZW91dChxdWV1ZURvbVdyaXRlcywgdGltZW91dCk7XG4gICAgICAgIGNvbnN1bWVUaW1lb3V0KHF1ZXVlRG9tV3JpdGVzTG93LCB0aW1lb3V0KTtcbiAgICAgICAgaWYgKHF1ZXVlRG9tV3JpdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHF1ZXVlRG9tV3JpdGVzTG93LnB1c2goLi4ucXVldWVEb21Xcml0ZXMpO1xuICAgICAgICAgICAgcXVldWVEb21Xcml0ZXMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHF1ZXVlUGVuZGluZyA9IHF1ZXVlRG9tUmVhZHMubGVuZ3RoICsgcXVldWVEb21Xcml0ZXMubGVuZ3RoICsgcXVldWVEb21Xcml0ZXNMb3cubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgIC8vIHN0aWxsIG1vcmUgdG8gZG8geWV0LCBidXQgd2UndmUgcnVuIG91dCBvZiB0aW1lXG4gICAgICAgICAgICAvLyBsZXQncyBsZXQgdGhpcyB0aGluZyBjb29sIG9mZiBhbmQgdHJ5IGFnYWluIGluIHRoZSBuZXh0IHRpY2tcbiAgICAgICAgICAgIHBsdC5yYWYoZmx1c2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcXVldWVDb25nZXN0aW9uID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3VtZShxdWV1ZURvbVdyaXRlcyk7XG4gICAgICAgIGlmICgocXVldWVQZW5kaW5nID0gcXVldWVEb21SZWFkcy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgLy8gc3RpbGwgbW9yZSB0byBkbyB5ZXQsIGJ1dCB3ZSd2ZSBydW4gb3V0IG9mIHRpbWVcbiAgICAgICAgICAgIC8vIGxldCdzIGxldCB0aGlzIHRoaW5nIGNvb2wgb2ZmIGFuZCB0cnkgYWdhaW4gaW4gdGhlIG5leHQgdGlja1xuICAgICAgICAgICAgcGx0LnJhZihmbHVzaCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgbmV4dFRpY2sgPSAvKkBfX1BVUkVfXyovIChjYikgPT4gcHJvbWlzZVJlc29sdmUoKS50aGVuKGNiKTtcbmNvbnN0IHJlYWRUYXNrID0gLypAX19QVVJFX18qLyBxdWV1ZVRhc2socXVldWVEb21SZWFkcywgZmFsc2UpO1xuY29uc3Qgd3JpdGVUYXNrID0gLypAX19QVVJFX18qLyBxdWV1ZVRhc2socXVldWVEb21Xcml0ZXMsIHRydWUpO1xuY29uc3QgQnVpbGQgPSB7XG4gICAgaXNEZXY6IEJVSUxELmlzRGV2ID8gdHJ1ZSA6IGZhbHNlLFxuICAgIGlzQnJvd3NlcjogdHJ1ZSxcbiAgICBpc1NlcnZlcjogZmFsc2UsXG4gICAgaXNUZXN0aW5nOiBCVUlMRC5pc1Rlc3RpbmcgPyB0cnVlIDogZmFsc2UsXG59O1xuZXhwb3J0IHsgQlVJTEQsIEVudiwgTkFNRVNQQUNFIH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9hcHAtZGF0YSc7XG5leHBvcnQgeyBCdWlsZCwgQ1NTLCBDb250ZXh0LCBGcmFnbWVudCwgSCwgSCBhcyBIVE1MRWxlbWVudCwgSG9zdCwgU1RFTkNJTF9ERVZfTU9ERSwgYWRkSG9zdEV2ZW50TGlzdGVuZXJzLCBhdHRhY2hTaGFkb3csIGJvb3RzdHJhcExhenksIGNtcE1vZHVsZXMsIGNvbm5lY3RlZENhbGxiYWNrLCBjb25zb2xlRGV2RXJyb3IsIGNvbnNvbGVEZXZJbmZvLCBjb25zb2xlRGV2V2FybiwgY29uc29sZUVycm9yLCBjcmVhdGVFdmVudCwgZGVmaW5lQ3VzdG9tRWxlbWVudCwgZGlzY29ubmVjdGVkQ2FsbGJhY2ssIGRvYywgZm9yY2VNb2RlVXBkYXRlLCBmb3JjZVVwZGF0ZSwgZ2V0QXNzZXRQYXRoLCBnZXRDb25uZWN0LCBnZXRDb250ZXh0LCBnZXRFbGVtZW50LCBnZXRIb3N0UmVmLCBnZXRNb2RlLCBnZXRSZW5kZXJpbmdSZWYsIGdldFZhbHVlLCBoLCBpbnNlcnRWZG9tQW5ub3RhdGlvbnMsIGlzTWVtYmVySW5FbGVtZW50LCBsb2FkTW9kdWxlLCBtb2RlUmVzb2x1dGlvbkNoYWluLCBuZXh0VGljaywgcGFyc2VQcm9wZXJ0eVZhbHVlLCBwbHQsIHBvc3RVcGRhdGVDb21wb25lbnQsIHByb21pc2VSZXNvbHZlLCBwcm94eUNvbXBvbmVudCwgcHJveHlDdXN0b21FbGVtZW50LCByZWFkVGFzaywgcmVnaXN0ZXJIb3N0LCByZWdpc3Rlckluc3RhbmNlLCByZW5kZXJWZG9tLCBzZXRBc3NldFBhdGgsIHNldEVycm9ySGFuZGxlciwgc2V0TW9kZSwgc2V0UGxhdGZvcm1PcHRpb25zLCBzZXRWYWx1ZSwgc3R5bGVzLCBzdXBwb3J0c0NvbnN0cnVjdGlibGVTdHlsZXNoZWV0cywgc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnMsIHN1cHBvcnRzU2hhZG93LCB3aW4sIHdyaXRlVGFzayB9O1xuIl0sIm5hbWVzIjpbInNjb3BlSWQiLCJjb250ZW50UmVmIiwiaG9zdFRhZ05hbWUiLCJjdXN0b21FcnJvciIsImkiLCJ1c2VOYXRpdmVTaGFkb3dEb20iLCJjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHkiLCJjaGVja1Nsb3RSZWxvY2F0ZSIsImlzU3ZnTW9kZSIsInJlbmRlcmluZ1JlZiIsInF1ZXVlQ29uZ2VzdGlvbiIsInF1ZXVlUGVuZGluZyIsIkJVSUxEIiwiTkFNRVNQQUNFIiwid2luIiwid2luZG93IiwiQ1NTIiwiY3NzVmFyU2hpbSIsImRvYyIsImRvY3VtZW50IiwiaGVhZCIsIkgiLCJIVE1MRWxlbWVudCIsInBsdCIsIiRmbGFncyQiLCIkcmVzb3VyY2VzVXJsJCIsImptcCIsImgiLCJyYWYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJhZWwiLCJlbCIsImV2ZW50TmFtZSIsImxpc3RlbmVyIiwib3B0cyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZWwiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2UiLCJDdXN0b21FdmVudCIsInN1cHBvcnRzU2hhZG93Iiwic2hhZG93RG9tU2hpbSIsInNoYWRvd0RvbSIsImF0dGFjaFNoYWRvdyIsImluZGV4T2YiLCJzdXBwb3J0c0xpc3RlbmVyT3B0aW9ucyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiZSIsInByb21pc2VSZXNvbHZlIiwidiIsIlByb21pc2UiLCJyZXNvbHZlIiwic3VwcG9ydHNDb25zdHJ1Y3RpYmxlU3R5bGVzaGVldHMiLCJjb25zdHJ1Y3RhYmxlQ1NTIiwiQ1NTU3R5bGVTaGVldCIsInJlcGxhY2UiLCJDb250ZXh0IiwiYWRkSG9zdEV2ZW50TGlzdGVuZXJzIiwiZWxtIiwiaG9zdFJlZiIsImxpc3RlbmVycyIsImF0dGFjaFBhcmVudExpc3RlbmVycyIsImhvc3RMaXN0ZW5lciIsImhvc3RMaXN0ZW5lclRhcmdldFBhcmVudCIsImZpbHRlciIsImZsYWdzIiwibWFwIiwibmFtZSIsIm1ldGhvZCIsInRhcmdldCIsImhvc3RMaXN0ZW5lclRhcmdldCIsImdldEhvc3RMaXN0ZW5lclRhcmdldCIsImhhbmRsZXIiLCJob3N0TGlzdGVuZXJQcm94eSIsImhvc3RMaXN0ZW5lck9wdHMiLCIkcm1MaXN0ZW5lcnMkIiwicHVzaCIsIm1ldGhvZE5hbWUiLCJldiIsImxhenlMb2FkIiwiJGxhenlJbnN0YW5jZSQiLCIkcXVldWVkTGlzdGVuZXJzJCIsIiRob3N0RWxlbWVudCQiLCJjb25zb2xlRXJyb3IiLCJob3N0TGlzdGVuZXJUYXJnZXREb2N1bWVudCIsImhvc3RMaXN0ZW5lclRhcmdldFdpbmRvdyIsImhvc3RMaXN0ZW5lclRhcmdldEJvZHkiLCJib2R5IiwicGFyZW50RWxlbWVudCIsInBhc3NpdmUiLCJjYXB0dXJlIiwiQ09OVEVOVF9SRUZfSUQiLCJPUkdfTE9DQVRJT05fSUQiLCJTTE9UX05PREVfSUQiLCJURVhUX05PREVfSUQiLCJIWURSQVRFX0lEIiwiSFlEUkFURURfU1RZTEVfSUQiLCJIWURSQVRFX0NISUxEX0lEIiwiSFlEUkFURURfQ1NTIiwiWExJTktfTlMiLCJjcmVhdGVUaW1lIiwiZm5OYW1lIiwidGFnTmFtZSIsInByb2ZpbGUiLCJwZXJmb3JtYW5jZSIsIm1hcmsiLCJrZXkiLCJtZWFzdXJlIiwidW5pcXVlVGltZSIsIm1lYXN1cmVUZXh0IiwiZ2V0RW50cmllc0J5TmFtZSIsImxlbmd0aCIsImluc3BlY3QiLCJyZWYiLCJnZXRIb3N0UmVmIiwidW5kZWZpbmVkIiwiaG9zdEVsZW1lbnQiLCJyZW5kZXJDb3VudCIsIiRyZW5kZXJDb3VudCQiLCJoYXNSZW5kZXJlZCIsImhhc0Nvbm5lY3RlZCIsImlzV2FpdGluZ0ZvckNoaWxkcmVuIiwiaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZSIsImlzUXVldWVkRm9yVXBkYXRlIiwiaGFzSW5pdGlhbGl6ZWRDb21wb25lbnQiLCJoYXNMb2FkZWRDb21wb25lbnQiLCJpc1dhdGNoUmVhZHkiLCJpc0xpc3RlblJlYWR5IiwibmVlZHNSZXJlbmRlciIsImluc3RhbmNlVmFsdWVzIiwiJGluc3RhbmNlVmFsdWVzJCIsImFuY2VzdG9yQ29tcG9uZW50IiwiJGFuY2VzdG9yQ29tcG9uZW50JCIsImxhenlJbnN0YW5jZSIsInZub2RlIiwiJHZub2RlJCIsIm1vZGVOYW1lIiwiJG1vZGVOYW1lJCIsIm9uUmVhZHlQcm9taXNlIiwiJG9uUmVhZHlQcm9taXNlJCIsIm9uUmVhZHlSZXNvbHZlIiwiJG9uUmVhZHlSZXNvbHZlJCIsIm9uSW5zdGFuY2VQcm9taXNlIiwiJG9uSW5zdGFuY2VQcm9taXNlJCIsIm9uSW5zdGFuY2VSZXNvbHZlIiwiJG9uSW5zdGFuY2VSZXNvbHZlJCIsIm9uUmVuZGVyUmVzb2x2ZSIsIiRvblJlbmRlclJlc29sdmUkIiwicXVldWVkTGlzdGVuZXJzIiwicm1MaXN0ZW5lcnMiLCJpbnN0YWxsRGV2VG9vbHMiLCJkZXZUb29scyIsInN0ZW5jaWwiLCJvcmlnaW5hbEluc3BlY3QiLCJyZXN1bHQiLCJyb290QXBwbGllZFN0eWxlcyIsIldlYWtNYXAiLCJyZWdpc3RlclN0eWxlIiwiY3NzVGV4dCIsImFsbG93Q1MiLCJzdHlsZSIsInN0eWxlcyIsInNldCIsImFkZFN0eWxlIiwic3R5bGVDb250YWluZXJOb2RlIiwiY21wTWV0YSIsIm1vZGUiLCJob3N0RWxtIiwiZ2V0U2NvcGVJZCIsImF0dGFjaFN0eWxlcyIsIm5vZGVUeXBlIiwiYXBwbGllZFN0eWxlcyIsInN0eWxlRWxtIiwiU2V0IiwiaGFzIiwiaHlkcmF0ZUNsaWVudFNpZGUiLCJob3N0IiwicXVlcnlTZWxlY3RvciIsImlubmVySFRNTCIsIiRjc3NTaGltJCIsImNyZWF0ZUhvc3RTdHlsZSIsIm5ld1Njb3BlSWQiLCJjcmVhdGVFbGVtZW50IiwiaHlkcmF0ZVNlcnZlclNpZGUiLCJob3RNb2R1bGVSZXBsYWNlbWVudCIsInNldEF0dHJpYnV0ZSIsImluc2VydEJlZm9yZSIsImFkZCIsImFkb3B0ZWRTdHlsZVNoZWV0cyIsImluY2x1ZGVzIiwiJGNtcE1ldGEkIiwiZW5kQXR0YWNoU3R5bGVzIiwiJHRhZ05hbWUkIiwic2hhZG93Um9vdCIsImdldFJvb3ROb2RlIiwic2NvcGVkIiwiY3NzQW5ub3RhdGlvbnMiLCJjbGFzc0xpc3QiLCJjbXAiLCJjb252ZXJ0U2NvcGVkVG9TaGFkb3ciLCJjc3MiLCJjb21wdXRlTW9kZSIsIm1vZGVSZXNvbHV0aW9uQ2hhaW4iLCJmaW5kIiwibSIsInNldE1vZGUiLCJnZXRNb2RlIiwiRU1QVFlfT0JKIiwiU1ZHX05TIiwiSFRNTF9OUyIsImlzRGVmIiwiaXNDb21wbGV4VHlwZSIsIm8iLCJub2RlTmFtZSIsInZub2RlRGF0YSIsImNoaWxkcmVuIiwiY2hpbGQiLCJzbG90TmFtZSIsInNpbXBsZSIsImxhc3RTaW1wbGUiLCJ2Tm9kZUNoaWxkcmVuIiwid2FsayIsImMiLCJBcnJheSIsImlzQXJyYXkiLCJTdHJpbmciLCJpc0RldiIsImNvbnNvbGVEZXZFcnJvciIsIiR0ZXh0JCIsIm5ld1ZOb2RlIiwidmFsaWRhdGVJbnB1dFByb3BlcnRpZXMiLCJ2ZG9tS2V5Iiwic2xvdFJlbG9jYXRpb24iLCJ2ZG9tQ2xhc3MiLCJjbGFzc0RhdGEiLCJjbGFzc05hbWUiLCJjbGFzcyIsImtleXMiLCJrIiwiam9pbiIsInNvbWUiLCJpc0hvc3QiLCJ2ZG9tRnVuY3Rpb25hbCIsInZkb21GblV0aWxzIiwiJGF0dHJzJCIsIiRjaGlsZHJlbiQiLCIka2V5JCIsIiRuYW1lJCIsInRhZyIsInRleHQiLCIkdGFnJCIsIiRlbG0kIiwidmRvbUF0dHJpYnV0ZSIsIkhvc3QiLCJub2RlIiwiZm9yRWFjaCIsImNiIiwiY29udmVydFRvUHVibGljIiwiY29udmVydFRvUHJpdmF0ZSIsInZhdHRycyIsInZjaGlsZHJlbiIsInZrZXkiLCJ2bmFtZSIsInZ0YWciLCJ2dGV4dCIsImFzc2lnbiIsInByb3BzIiwidHlwZUluZGV4IiwibWluSW5kZXgiLCJtYXhJbmRleCIsInN0ZXBJbmRleCIsInZhbHVlIiwiY29uc29sZURldldhcm4iLCJzZXRBY2Nlc3NvciIsIm1lbWJlck5hbWUiLCJvbGRWYWx1ZSIsIm5ld1ZhbHVlIiwiaXNTdmciLCJpc1Byb3AiLCJpc01lbWJlckluRWxlbWVudCIsImxuIiwidG9Mb3dlckNhc2UiLCJvbGRDbGFzc2VzIiwicGFyc2VDbGFzc0xpc3QiLCJuZXdDbGFzc2VzIiwicmVtb3ZlIiwidmRvbVN0eWxlIiwidXBkYXRhYmxlIiwicHJvcCIsInJlbW92ZVByb3BlcnR5Iiwic2V0UHJvcGVydHkiLCJ2ZG9tUmVmIiwidmRvbUxpc3RlbmVyIiwiX19sb29rdXBTZXR0ZXJfXyIsInNsaWNlIiwidmRvbVByb3BPckF0dHIiLCJpc0NvbXBsZXgiLCJuIiwieGxpbmsiLCJ2ZG9tWGxpbmsiLCJnZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsInJlbW92ZUF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZU5TIiwicGFyc2VDbGFzc0xpc3RSZWdleCIsInNwbGl0IiwidXBkYXRlRWxlbWVudCIsIm9sZFZub2RlIiwibmV3Vm5vZGUiLCJvbGRWbm9kZUF0dHJzIiwibmV3Vm5vZGVBdHRycyIsImNyZWF0ZUVsbSIsIm9sZFBhcmVudFZOb2RlIiwibmV3UGFyZW50Vk5vZGUiLCJjaGlsZEluZGV4IiwicGFyZW50RWxtIiwiY2hpbGROb2RlIiwib2xkVk5vZGUiLCJ2ZG9tVGV4dCIsImNyZWF0ZVRleHROb2RlIiwiaXNEZWJ1ZyIsInNsb3RSZWZlcmVuY2VEZWJ1Z05vZGUiLCJzdmciLCJjcmVhdGVFbGVtZW50TlMiLCJhcHBlbmRDaGlsZCIsInB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24iLCJyZWN1cnNpdmUiLCJvbGRTbG90Q2hpbGROb2RlcyIsImNoaWxkTm9kZXMiLCJwYXJlbnRSZWZlcmVuY2VOb2RlIiwicmVmZXJlbmNlTm9kZSIsImFkZFZub2RlcyIsImJlZm9yZSIsInBhcmVudFZOb2RlIiwidm5vZGVzIiwic3RhcnRJZHgiLCJlbmRJZHgiLCJjb250YWluZXJFbG0iLCJwYXJlbnROb2RlIiwicmVtb3ZlVm5vZGVzIiwiY2FsbE5vZGVSZWZzIiwidXBkYXRlQ2hpbGRyZW4iLCJvbGRDaCIsIm5ld0NoIiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsImlkeEluT2xkIiwib2xkRW5kSWR4Iiwib2xkU3RhcnRWbm9kZSIsIm9sZEVuZFZub2RlIiwibmV3RW5kSWR4IiwibmV3U3RhcnRWbm9kZSIsIm5ld0VuZFZub2RlIiwiZWxtVG9Nb3ZlIiwiaXNTYW1lVm5vZGUiLCJwYXRjaCIsIm5leHRTaWJsaW5nIiwidm5vZGUxIiwidm5vZGUyIiwib2xkQ2hpbGRyZW4iLCJuZXdDaGlsZHJlbiIsImRlZmF1bHRIb2xkZXIiLCJyZWZsZWN0Iiwic2xvdCIsInRleHRDb250ZW50IiwiZGF0YSIsInVwZGF0ZUZhbGxiYWNrU2xvdFZpc2liaWxpdHkiLCJpbGVuIiwiaiIsInNsb3ROYW1lQXR0ciIsImhpZGRlbiIsInRyaW0iLCJyZWxvY2F0ZU5vZGVzIiwicmVsb2NhdGVTbG90Q29udGVudCIsImhvc3RDb250ZW50Tm9kZXMiLCJyZWxvY2F0ZU5vZGVEYXRhIiwiaXNOb2RlTG9jYXRlZEluU2xvdCIsInIiLCIkbm9kZVRvUmVsb2NhdGUkIiwiJHNsb3RSZWZOb2RlJCIsInJlbG9jYXRlTm9kZSIsIm5vZGVUb1JlbG9jYXRlIiwidk5vZGUiLCJyZW5kZXJWZG9tIiwicmVuZGVyRm5SZXN1bHRzIiwicm9vdFZub2RlIiwiRXJyb3IiLCIkYXR0cnNUb1JlZmxlY3QkIiwicHJvcE5hbWUiLCJhdHRyaWJ1dGUiLCJyZWxvY2F0ZURhdGEiLCJvcmdMb2NhdGlvbk5vZGUiLCJwYXJlbnROb2RlUmVmIiwiaW5zZXJ0QmVmb3JlTm9kZSIsInJlZk5vZGUiLCJvcmlnaW5hbExvY2F0aW9uRGVidWdOb2RlIiwicHJldmlvdXNTaWJsaW5nIiwic2xvdFZOb2RlIiwiY3JlYXRlQ29tbWVudCIsImxvY2FsTmFtZSIsImdldEVsZW1lbnQiLCJjcmVhdGVFdmVudCIsImVtaXQiLCJkZXRhaWwiLCJpc0Nvbm5lY3RlZCIsImVtaXRFdmVudCIsImJ1YmJsZXMiLCJjb21wb3NlZCIsImNhbmNlbGFibGUiLCJkaXNwYXRjaEV2ZW50IiwiYXR0YWNoVG9BbmNlc3RvciIsImFzeW5jTG9hZGluZyIsInNjaGVkdWxlVXBkYXRlIiwiaXNJbml0aWFsTG9hZCIsInRhc2tRdWV1ZSIsImRpc3BhdGNoIiwiZGlzcGF0Y2hIb29rcyIsIndyaXRlVGFzayIsImVuZFNjaGVkdWxlIiwiaW5zdGFuY2UiLCJwcm9taXNlIiwiZXZlbnQiLCJzYWZlQ2FsbCIsImVtaXRMaWZlY3ljbGVFdmVudCIsImNtcFdpbGxMb2FkIiwiY21wV2lsbFVwZGF0ZSIsImNtcFdpbGxSZW5kZXIiLCJ0aGVuIiwidXBkYXRlQ29tcG9uZW50IiwiZW5kVXBkYXRlIiwicmMiLCJlbmRSZW5kZXIiLCJjYWxsUmVuZGVyIiwidXBkYXRlSG9zdCIsInNlcnZlclNpZGVDb25uZWN0ZWQiLCJjaGlsZHJlblByb21pc2VzIiwicG9zdFVwZGF0ZSIsInBvc3RVcGRhdGVDb21wb25lbnQiLCJhbGwiLCJhbGxSZW5kZXJGbiIsInJlbmRlciIsImhhc1JlbmRlckZuIiwidmRvbVJlbmRlciIsImdldFJlbmRlcmluZ1JlZiIsImVuZFBvc3RVcGRhdGUiLCJjbXBEaWRSZW5kZXIiLCJhZGRIeWRyYXRlZEZsYWciLCJjbXBEaWRMb2FkIiwiYXBwRGlkTG9hZCIsImNtcERpZFVwZGF0ZSIsIm5leHRUaWNrIiwiZm9yY2VVcGRhdGUiLCJ3aG8iLCJkb2N1bWVudEVsZW1lbnQiLCJhc3luY1F1ZXVlIiwibmFtZXNwYWNlIiwiYXJnIiwidGhlbkZuIiwibGlmZWN5Y2xlTmFtZSIsImxpZmVjeWNsZURPTUV2ZW50cyIsImh5ZHJhdGVkQ2xhc3MiLCJoeWRyYXRlZEF0dHJpYnV0ZSIsImlpIiwiY2hpbGRFbG0iLCJjb25uZWN0ZWRDYWxsYmFjayIsImluaXRpYWxpemVDbGllbnRIeWRyYXRlIiwiaG9zdElkIiwiZW5kSHlkcmF0ZSIsImNoaWxkUmVuZGVyTm9kZXMiLCJzbG90Tm9kZXMiLCJzaGFkb3dSb290Tm9kZXMiLCIkb3JnTG9jTm9kZXMkIiwiaW5pdGlhbGl6ZURvY3VtZW50SHlkcmF0ZSIsIk1hcCIsImNsaWVudEh5ZHJhdGUiLCJvcmdMb2NhdGlvbklkIiwiJGhvc3RJZCQiLCIkbm9kZUlkJCIsImRlbGV0ZSIsInNoYWRvd1Jvb3ROb2RlIiwiY2hpbGROb2RlVHlwZSIsImNoaWxkSWRTcGx0IiwiY2hpbGRWTm9kZSIsIiRkZXB0aCQiLCIkaW5kZXgkIiwibm9kZVZhbHVlIiwib3JnTG9jTm9kZXMiLCJwYXJzZVByb3BlcnR5VmFsdWUiLCJwcm9wVmFsdWUiLCJwcm9wVHlwZSIsInByb3BCb29sZWFuIiwicHJvcE51bWJlciIsInBhcnNlRmxvYXQiLCJwcm9wU3RyaW5nIiwiZ2V0VmFsdWUiLCJzZXRWYWx1ZSIsIm5ld1ZhbCIsIm9sZFZhbCIsIiRtZW1iZXJzJCIsIndhdGNoQ2FsbGJhY2siLCIkd2F0Y2hlcnMkIiwid2F0Y2hNZXRob2RzIiwid2F0Y2hNZXRob2ROYW1lIiwiY21wU2hvdWxkVXBkYXRlIiwiY29tcG9uZW50U2hvdWxkVXBkYXRlIiwicHJveHlDb21wb25lbnQiLCJDc3RyIiwibWVtYmVyIiwid2F0Y2hlcnMiLCJtZW1iZXJzIiwiZW50cmllcyIsInByb3RvdHlwZSIsIm1lbWJlckZsYWdzIiwic3RhdGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiYXJncyIsIm9ic2VydmVBdHRyaWJ1dGUiLCJhdHRyTmFtZVRvUHJvcE5hbWUiLCJhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2siLCJhdHRyTmFtZSIsIl9vbGRWYWx1ZSIsIm9ic2VydmVkQXR0cmlidXRlcyIsIl8iLCJpbml0aWFsaXplQ29tcG9uZW50IiwiaG1yVmVyc2lvbklkIiwibG9hZE1vZHVsZSIsImVuZExvYWQiLCJpc1Byb3hpZWQiLCJlbmROZXdJbnN0YW5jZSIsImZpcmVDb25uZWN0ZWRDYWxsYmFjayIsImNvbnN0cnVjdG9yIiwiZW5kUmVnaXN0ZXJTdHlsZXMiLCJzY29wZUNzcyIsInNjaGVkdWxlIiwiZW5kQ29ubmVjdGVkIiwiJGxpc3RlbmVycyQiLCJzZXRDb250ZW50UmVmZXJlbmNlIiwiaGFzQXR0cmlidXRlIiwiaGFzT3duUHJvcGVydHkiLCJpbml0aWFsaXplTmV4dFRpY2siLCJjb250ZW50UmVmRWxtIiwiZmlyc3RDaGlsZCIsImRpc2Nvbm5lY3RlZENhbGxiYWNrIiwicm1MaXN0ZW5lciIsInJlbW92ZUhvc3QiLCJjbXBEaWRVbmxvYWQiLCJkZWZpbmVDdXN0b21FbGVtZW50IiwiY29tcGFjdE1ldGEiLCJjdXN0b21FbGVtZW50cyIsImRlZmluZSIsInByb3h5Q3VzdG9tRWxlbWVudCIsIm9yaWdpbmFsQ29ubmVjdGVkQ2FsbGJhY2siLCJvcmlnaW5hbERpc2Nvbm5lY3RlZENhbGxiYWNrIiwiX19yZWdpc3Rlckhvc3QiLCJyZWdpc3Rlckhvc3QiLCJjYWxsIiwiaXMiLCJmb3JjZU1vZGVVcGRhdGUiLCJvbGRTY29wZUlkIiwiaG1yU3RhcnQiLCJwYXRjaENsb25lTm9kZSIsIkhvc3RFbGVtZW50UHJvdG90eXBlIiwib3JnQ2xvbmVOb2RlIiwiY2xvbmVOb2RlIiwiZGVlcCIsInNyY05vZGUiLCJpc1NoYWRvd0RvbSIsImNsb25lZE5vZGUiLCJzbG90dGVkIiwibm9uU3RlbmNpbE5vZGUiLCJzdGVuY2lsUHJpdmF0ZXMiLCJldmVyeSIsInByaXZhdGVGaWVsZCIsImFwcGVuZENoaWxkU2xvdEZpeCIsIl9fYXBwZW5kQ2hpbGQiLCJwYXRjaFNsb3RBcHBlbmRDaGlsZCIsIm5ld0NoaWxkIiwiZ2V0U2xvdE5hbWUiLCJzbG90Tm9kZSIsImdldEhvc3RTbG90Tm9kZSIsInNsb3RDaGlsZE5vZGVzIiwiZ2V0SG9zdFNsb3RDaGlsZE5vZGVzIiwiYXBwZW5kQWZ0ZXIiLCJwYXRjaENoaWxkU2xvdE5vZGVzIiwiRmFrZU5vZGVMaXN0IiwiaXRlbSIsImNoaWxkTm9kZXNGbiIsIl9fbG9va3VwR2V0dGVyX18iLCJmcm9tIiwiYm9vdHN0cmFwTGF6eSIsImxhenlCdW5kbGVzIiwib3B0aW9ucyIsImVuZEJvb3RzdHJhcCIsImNtcFRhZ3MiLCJleGNsdWRlIiwibWV0YUNoYXJzZXQiLCJ2aXNpYmlsaXR5U3R5bGUiLCJkZWZlcnJlZENvbm5lY3RlZENhbGxiYWNrcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJhcHBMb2FkRmFsbGJhY2siLCJpc0Jvb3RzdHJhcHBpbmciLCJVUkwiLCJyZXNvdXJjZXNVcmwiLCJiYXNlVVJJIiwiaHJlZiIsInN5bmNRdWV1ZSIsImxhenlCdW5kbGUiLCJ0cmFuc2Zvcm1UYWdOYW1lIiwiSG9zdEVsZW1lbnQiLCJzZWxmIiwic2hhZG93RGVsZWdhdGVzRm9jdXMiLCJkZWxlZ2F0ZXNGb2N1cyIsInNsb3RDaGlsZE5vZGVzRml4IiwiY2xlYXJUaW1lb3V0IiwiY29tcG9uZW50T25SZWFkeSIsImNsb25lTm9kZUZpeCIsIiRsYXp5QnVuZGxlSWQkIiwic2V0VGltZW91dCIsImdldEFzc2V0UGF0aCIsInBhdGgiLCJhc3NldFVybCIsIm9yaWdpbiIsImxvY2F0aW9uIiwicGF0aG5hbWUiLCJzZXRBc3NldFBhdGgiLCJnZXRDb25uZWN0IiwiX3JlZiIsImNyZWF0ZSIsImdldENvbnRleHQiLCJfZWxtIiwiY29udGV4dCIsIndyaXRlIiwicmVhZCIsInJlYWRUYXNrIiwidGljayIsImluc2VydFZkb21Bbm5vdGF0aW9ucyIsInN0YXRpY0NvbXBvbmVudHMiLCJkb2NEYXRhIiwiaG9zdElkcyIsInJvb3RMZXZlbElkcyIsIm9yZ0xvY2F0aW9uTm9kZXMiLCJwYXJzZVZOb2RlQW5ub3RhdGlvbnMiLCJub2RlUmVmIiwibm9kZUlkIiwiY2hpbGRJZCIsImNvbW1lbnRCZWZvcmVUZXh0Tm9kZSIsIm9yZ0xvY2F0aW9uTm9kZUlkIiwib3JnTG9jYXRpb25QYXJlbnROb2RlIiwiY21wRGF0YSIsIm5vZGVJZHMiLCJpbnNlcnRWTm9kZUFubm90YXRpb25zIiwiZGVwdGgiLCJ2bm9kZUNoaWxkIiwiaW5kZXgiLCJpbnNlcnRDaGlsZFZOb2RlQW5ub3RhdGlvbnMiLCJwYXJlbnQiLCJwYXJlbnRDaGlsZE5vZGVzIiwiY29tbWVudCIsInRleHROb2RlSWQiLCJzbG90Tm9kZUlkIiwiY2hpbGREZXB0aCIsInNldFBsYXRmb3JtT3B0aW9ucyIsIkZyYWdtZW50IiwiaG9zdFJlZnMiLCJyZWdpc3Rlckluc3RhbmNlIiwiY29uc29sZSIsImVycm9yIiwiU1RFTkNJTF9ERVZfTU9ERSIsImlzVGVzdGluZyIsIndhcm4iLCJjb25zb2xlRGV2SW5mbyIsImluZm8iLCJzZXRFcnJvckhhbmRsZXIiLCJjbXBNb2R1bGVzIiwiZXhwb3J0TmFtZSIsImJ1bmRsZUlkIiwibW9kdWxlIiwiaW1wb3J0ZWRNb2R1bGUiLCJxdWV1ZURvbVJlYWRzIiwicXVldWVEb21Xcml0ZXMiLCJxdWV1ZURvbVdyaXRlc0xvdyIsInF1ZXVlVGFzayIsInF1ZXVlIiwiZmx1c2giLCJjb25zdW1lIiwibm93IiwiY29uc3VtZVRpbWVvdXQiLCJ0aW1lb3V0IiwidHMiLCJzcGxpY2UiLCJNYXRoIiwiY2VpbCIsIkluZmluaXR5IiwiQnVpbGQiLCJpc0Jyb3dzZXIiLCJpc1NlcnZlciIsIkVudiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@stencil+core@2.5.2/node_modules/@stencil/core/internal/client/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@stencil+core@2.5.2/node_modules/@stencil/core/internal/client/shadow-css.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@stencil+core@2.5.2/node_modules/@stencil/core/internal/client/shadow-css.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scopeCss: () => (/* binding */ scopeCss)\n/* harmony export */ });\n/*\n Stencil Client Platform v2.5.2 | MIT Licensed | https://stenciljs.com\n */ /**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n *\n * This file is a port of shadowCSS from webcomponents.js to TypeScript.\n * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js\n * https://github.com/angular/angular/blob/master/packages/compiler/src/shadow_css.ts\n */ const safeSelector = (selector)=>{\n    const placeholders = [];\n    let index = 0;\n    let content;\n    // Replaces attribute selectors with placeholders.\n    // The WS in [attr=\"va lue\"] would otherwise be interpreted as a selector separator.\n    selector = selector.replace(/(\\[[^\\]]*\\])/g, (_, keep)=>{\n        const replaceBy = `__ph-${index}__`;\n        placeholders.push(keep);\n        index++;\n        return replaceBy;\n    });\n    // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.\n    // WS and \"+\" would otherwise be interpreted as selector separators.\n    content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, (_, pseudo, exp)=>{\n        const replaceBy = `__ph-${index}__`;\n        placeholders.push(exp);\n        index++;\n        return pseudo + replaceBy;\n    });\n    const ss = {\n        content,\n        placeholders\n    };\n    return ss;\n};\nconst restoreSafeSelector = (placeholders, content)=>{\n    return content.replace(/__ph-(\\d+)__/g, (_, index)=>placeholders[+index]);\n};\nconst _polyfillHost = \"-shadowcsshost\";\nconst _polyfillSlotted = \"-shadowcssslotted\";\n// note: :host-context pre-processed to -shadowcsshostcontext.\nconst _polyfillHostContext = \"-shadowcsscontext\";\nconst _parenSuffix = \")(?:\\\\((\" + \"(?:\\\\([^)(]*\\\\)|[^)(]*)+?\" + \")\\\\))?([^,{]*)\";\nconst _cssColonHostRe = new RegExp(\"(\" + _polyfillHost + _parenSuffix, \"gim\");\nconst _cssColonHostContextRe = new RegExp(\"(\" + _polyfillHostContext + _parenSuffix, \"gim\");\nconst _cssColonSlottedRe = new RegExp(\"(\" + _polyfillSlotted + _parenSuffix, \"gim\");\nconst _polyfillHostNoCombinator = _polyfillHost + \"-no-combinator\";\nconst _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\nconst _shadowDOMSelectorsRe = [\n    /::shadow/g,\n    /::content/g\n];\nconst _selectorReSuffix = \"([>\\\\s~+[.,{:][\\\\s\\\\S]*)?$\";\nconst _polyfillHostRe = /-shadowcsshost/gim;\nconst _colonHostRe = /:host/gim;\nconst _colonSlottedRe = /::slotted/gim;\nconst _colonHostContextRe = /:host-context/gim;\nconst _commentRe = /\\/\\*\\s*[\\s\\S]*?\\*\\//g;\nconst stripComments = (input)=>{\n    return input.replace(_commentRe, \"\");\n};\nconst _commentWithHashRe = /\\/\\*\\s*#\\s*source(Mapping)?URL=[\\s\\S]+?\\*\\//g;\nconst extractCommentsWithHash = (input)=>{\n    return input.match(_commentWithHashRe) || [];\n};\nconst _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\nconst _curlyRe = /([{}])/g;\nconst OPEN_CURLY = \"{\";\nconst CLOSE_CURLY = \"}\";\nconst BLOCK_PLACEHOLDER = \"%BLOCK%\";\nconst processRules = (input, ruleCallback)=>{\n    const inputWithEscapedBlocks = escapeBlocks(input);\n    let nextBlockIndex = 0;\n    return inputWithEscapedBlocks.escapedString.replace(_ruleRe, (...m)=>{\n        const selector = m[2];\n        let content = \"\";\n        let suffix = m[4];\n        let contentPrefix = \"\";\n        if (suffix && suffix.startsWith(\"{\" + BLOCK_PLACEHOLDER)) {\n            content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n            suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n            contentPrefix = \"{\";\n        }\n        const cssRule = {\n            selector,\n            content\n        };\n        const rule = ruleCallback(cssRule);\n        return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;\n    });\n};\nconst escapeBlocks = (input)=>{\n    const inputParts = input.split(_curlyRe);\n    const resultParts = [];\n    const escapedBlocks = [];\n    let bracketCount = 0;\n    let currentBlockParts = [];\n    for(let partIndex = 0; partIndex < inputParts.length; partIndex++){\n        const part = inputParts[partIndex];\n        if (part === CLOSE_CURLY) {\n            bracketCount--;\n        }\n        if (bracketCount > 0) {\n            currentBlockParts.push(part);\n        } else {\n            if (currentBlockParts.length > 0) {\n                escapedBlocks.push(currentBlockParts.join(\"\"));\n                resultParts.push(BLOCK_PLACEHOLDER);\n                currentBlockParts = [];\n            }\n            resultParts.push(part);\n        }\n        if (part === OPEN_CURLY) {\n            bracketCount++;\n        }\n    }\n    if (currentBlockParts.length > 0) {\n        escapedBlocks.push(currentBlockParts.join(\"\"));\n        resultParts.push(BLOCK_PLACEHOLDER);\n    }\n    const strEscapedBlocks = {\n        escapedString: resultParts.join(\"\"),\n        blocks: escapedBlocks\n    };\n    return strEscapedBlocks;\n};\nconst insertPolyfillHostInCssText = (selector)=>{\n    selector = selector.replace(_colonHostContextRe, _polyfillHostContext).replace(_colonHostRe, _polyfillHost).replace(_colonSlottedRe, _polyfillSlotted);\n    return selector;\n};\nconst convertColonRule = (cssText, regExp, partReplacer)=>{\n    // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule\n    return cssText.replace(regExp, (...m)=>{\n        if (m[2]) {\n            const parts = m[2].split(\",\");\n            const r = [];\n            for(let i = 0; i < parts.length; i++){\n                const p = parts[i].trim();\n                if (!p) break;\n                r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));\n            }\n            return r.join(\",\");\n        } else {\n            return _polyfillHostNoCombinator + m[3];\n        }\n    });\n};\nconst colonHostPartReplacer = (host, part, suffix)=>{\n    return host + part.replace(_polyfillHost, \"\") + suffix;\n};\nconst convertColonHost = (cssText)=>{\n    return convertColonRule(cssText, _cssColonHostRe, colonHostPartReplacer);\n};\nconst colonHostContextPartReplacer = (host, part, suffix)=>{\n    if (part.indexOf(_polyfillHost) > -1) {\n        return colonHostPartReplacer(host, part, suffix);\n    } else {\n        return host + part + suffix + \", \" + part + \" \" + host + suffix;\n    }\n};\nconst convertColonSlotted = (cssText, slotScopeId)=>{\n    const slotClass = \".\" + slotScopeId + \" > \";\n    const selectors = [];\n    cssText = cssText.replace(_cssColonSlottedRe, (...m)=>{\n        if (m[2]) {\n            const compound = m[2].trim();\n            const suffix = m[3];\n            const slottedSelector = slotClass + compound + suffix;\n            let prefixSelector = \"\";\n            for(let i = m[4] - 1; i >= 0; i--){\n                const char = m[5][i];\n                if (char === \"}\" || char === \",\") {\n                    break;\n                }\n                prefixSelector = char + prefixSelector;\n            }\n            const orgSelector = prefixSelector + slottedSelector;\n            const addedSelector = `${prefixSelector.trimRight()}${slottedSelector.trim()}`;\n            if (orgSelector.trim() !== addedSelector.trim()) {\n                const updatedSelector = `${addedSelector}, ${orgSelector}`;\n                selectors.push({\n                    orgSelector,\n                    updatedSelector\n                });\n            }\n            return slottedSelector;\n        } else {\n            return _polyfillHostNoCombinator + m[3];\n        }\n    });\n    return {\n        selectors,\n        cssText\n    };\n};\nconst convertColonHostContext = (cssText)=>{\n    return convertColonRule(cssText, _cssColonHostContextRe, colonHostContextPartReplacer);\n};\nconst convertShadowDOMSelectors = (cssText)=>{\n    return _shadowDOMSelectorsRe.reduce((result, pattern)=>result.replace(pattern, \" \"), cssText);\n};\nconst makeScopeMatcher = (scopeSelector)=>{\n    const lre = /\\[/g;\n    const rre = /\\]/g;\n    scopeSelector = scopeSelector.replace(lre, \"\\\\[\").replace(rre, \"\\\\]\");\n    return new RegExp(\"^(\" + scopeSelector + \")\" + _selectorReSuffix, \"m\");\n};\nconst selectorNeedsScoping = (selector, scopeSelector)=>{\n    const re = makeScopeMatcher(scopeSelector);\n    return !re.test(selector);\n};\nconst applySimpleSelectorScope = (selector, scopeSelector, hostSelector)=>{\n    // In Android browser, the lastIndex is not reset when the regex is used in String.replace()\n    _polyfillHostRe.lastIndex = 0;\n    if (_polyfillHostRe.test(selector)) {\n        const replaceBy = `.${hostSelector}`;\n        return selector.replace(_polyfillHostNoCombinatorRe, (_, selector)=>{\n            return selector.replace(/([^:]*)(:*)(.*)/, (_, before, colon, after)=>{\n                return before + replaceBy + colon + after;\n            });\n        }).replace(_polyfillHostRe, replaceBy + \" \");\n    }\n    return scopeSelector + \" \" + selector;\n};\nconst applyStrictSelectorScope = (selector, scopeSelector, hostSelector)=>{\n    const isRe = /\\[is=([^\\]]*)\\]/g;\n    scopeSelector = scopeSelector.replace(isRe, (_, ...parts)=>parts[0]);\n    const className = \".\" + scopeSelector;\n    const _scopeSelectorPart = (p)=>{\n        let scopedP = p.trim();\n        if (!scopedP) {\n            return \"\";\n        }\n        if (p.indexOf(_polyfillHostNoCombinator) > -1) {\n            scopedP = applySimpleSelectorScope(p, scopeSelector, hostSelector);\n        } else {\n            // remove :host since it should be unnecessary\n            const t = p.replace(_polyfillHostRe, \"\");\n            if (t.length > 0) {\n                const matches = t.match(/([^:]*)(:*)(.*)/);\n                if (matches) {\n                    scopedP = matches[1] + className + matches[2] + matches[3];\n                }\n            }\n        }\n        return scopedP;\n    };\n    const safeContent = safeSelector(selector);\n    selector = safeContent.content;\n    let scopedSelector = \"\";\n    let startIndex = 0;\n    let res;\n    const sep = /( |>|\\+|~(?!=))\\s*/g;\n    // If a selector appears before :host it should not be shimmed as it\n    // matches on ancestor elements and not on elements in the host's shadow\n    // `:host-context(div)` is transformed to\n    // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`\n    // the `div` is not part of the component in the 2nd selectors and should not be scoped.\n    // Historically `component-tag:host` was matching the component so we also want to preserve\n    // this behavior to avoid breaking legacy apps (it should not match).\n    // The behavior should be:\n    // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)\n    // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a\n    //   `:host-context(tag)`)\n    const hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;\n    // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present\n    let shouldScope = !hasHost;\n    while((res = sep.exec(selector)) !== null){\n        const separator = res[1];\n        const part = selector.slice(startIndex, res.index).trim();\n        shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n        const scopedPart = shouldScope ? _scopeSelectorPart(part) : part;\n        scopedSelector += `${scopedPart} ${separator} `;\n        startIndex = sep.lastIndex;\n    }\n    const part = selector.substring(startIndex);\n    shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n    scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;\n    // replace the placeholders with their original values\n    return restoreSafeSelector(safeContent.placeholders, scopedSelector);\n};\nconst scopeSelector = (selector, scopeSelectorText, hostSelector, slotSelector)=>{\n    return selector.split(\",\").map((shallowPart)=>{\n        if (slotSelector && shallowPart.indexOf(\".\" + slotSelector) > -1) {\n            return shallowPart.trim();\n        }\n        if (selectorNeedsScoping(shallowPart, scopeSelectorText)) {\n            return applyStrictSelectorScope(shallowPart, scopeSelectorText, hostSelector).trim();\n        } else {\n            return shallowPart.trim();\n        }\n    }).join(\", \");\n};\nconst scopeSelectors = (cssText, scopeSelectorText, hostSelector, slotSelector, commentOriginalSelector)=>{\n    return processRules(cssText, (rule)=>{\n        let selector = rule.selector;\n        let content = rule.content;\n        if (rule.selector[0] !== \"@\") {\n            selector = scopeSelector(rule.selector, scopeSelectorText, hostSelector, slotSelector);\n        } else if (rule.selector.startsWith(\"@media\") || rule.selector.startsWith(\"@supports\") || rule.selector.startsWith(\"@page\") || rule.selector.startsWith(\"@document\")) {\n            content = scopeSelectors(rule.content, scopeSelectorText, hostSelector, slotSelector);\n        }\n        const cssRule = {\n            selector: selector.replace(/\\s{2,}/g, \" \").trim(),\n            content\n        };\n        return cssRule;\n    });\n};\nconst scopeCssText = (cssText, scopeId, hostScopeId, slotScopeId, commentOriginalSelector)=>{\n    cssText = insertPolyfillHostInCssText(cssText);\n    cssText = convertColonHost(cssText);\n    cssText = convertColonHostContext(cssText);\n    const slotted = convertColonSlotted(cssText, slotScopeId);\n    cssText = slotted.cssText;\n    cssText = convertShadowDOMSelectors(cssText);\n    if (scopeId) {\n        cssText = scopeSelectors(cssText, scopeId, hostScopeId, slotScopeId);\n    }\n    cssText = cssText.replace(/-shadowcsshost-no-combinator/g, `.${hostScopeId}`);\n    cssText = cssText.replace(/>\\s*\\*\\s+([^{, ]+)/gm, \" $1 \");\n    return {\n        cssText: cssText.trim(),\n        slottedSelectors: slotted.selectors\n    };\n};\nconst scopeCss = (cssText, scopeId, commentOriginalSelector)=>{\n    const hostScopeId = scopeId + \"-h\";\n    const slotScopeId = scopeId + \"-s\";\n    const commentsWithHash = extractCommentsWithHash(cssText);\n    cssText = stripComments(cssText);\n    const orgSelectors = [];\n    if (commentOriginalSelector) {\n        const processCommentedSelector = (rule)=>{\n            const placeholder = `/*!@___${orgSelectors.length}___*/`;\n            const comment = `/*!@${rule.selector}*/`;\n            orgSelectors.push({\n                placeholder,\n                comment\n            });\n            rule.selector = placeholder + rule.selector;\n            return rule;\n        };\n        cssText = processRules(cssText, (rule)=>{\n            if (rule.selector[0] !== \"@\") {\n                return processCommentedSelector(rule);\n            } else if (rule.selector.startsWith(\"@media\") || rule.selector.startsWith(\"@supports\") || rule.selector.startsWith(\"@page\") || rule.selector.startsWith(\"@document\")) {\n                rule.content = processRules(rule.content, processCommentedSelector);\n                return rule;\n            }\n            return rule;\n        });\n    }\n    const scoped = scopeCssText(cssText, scopeId, hostScopeId, slotScopeId);\n    cssText = [\n        scoped.cssText,\n        ...commentsWithHash\n    ].join(\"\\n\");\n    if (commentOriginalSelector) {\n        orgSelectors.forEach(({ placeholder, comment })=>{\n            cssText = cssText.replace(placeholder, comment);\n        });\n    }\n    scoped.slottedSelectors.forEach((slottedSelector)=>{\n        cssText = cssText.replace(slottedSelector.orgSelector, slottedSelector.updatedSelector);\n    });\n    return cssText;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHN0ZW5jaWwrY29yZUAyLjUuMi9ub2RlX21vZHVsZXMvQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQvc2hhZG93LWNzcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0NBRUMsR0FDRDs7Ozs7Ozs7OztDQVVDLEdBQ0QsTUFBTUEsZUFBZSxDQUFDQztJQUNsQixNQUFNQyxlQUFlLEVBQUU7SUFDdkIsSUFBSUMsUUFBUTtJQUNaLElBQUlDO0lBQ0osa0RBQWtEO0lBQ2xELG9GQUFvRjtJQUNwRkgsV0FBV0EsU0FBU0ksT0FBTyxDQUFDLGlCQUFpQixDQUFDQyxHQUFHQztRQUM3QyxNQUFNQyxZQUFZLENBQUMsS0FBSyxFQUFFTCxNQUFNLEVBQUUsQ0FBQztRQUNuQ0QsYUFBYU8sSUFBSSxDQUFDRjtRQUNsQko7UUFDQSxPQUFPSztJQUNYO0lBQ0Esc0VBQXNFO0lBQ3RFLG9FQUFvRTtJQUNwRUosVUFBVUgsU0FBU0ksT0FBTyxDQUFDLDZCQUE2QixDQUFDQyxHQUFHSSxRQUFRQztRQUNoRSxNQUFNSCxZQUFZLENBQUMsS0FBSyxFQUFFTCxNQUFNLEVBQUUsQ0FBQztRQUNuQ0QsYUFBYU8sSUFBSSxDQUFDRTtRQUNsQlI7UUFDQSxPQUFPTyxTQUFTRjtJQUNwQjtJQUNBLE1BQU1JLEtBQUs7UUFDUFI7UUFDQUY7SUFDSjtJQUNBLE9BQU9VO0FBQ1g7QUFDQSxNQUFNQyxzQkFBc0IsQ0FBQ1gsY0FBY0U7SUFDdkMsT0FBT0EsUUFBUUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDQyxHQUFHSCxRQUFVRCxZQUFZLENBQUMsQ0FBQ0MsTUFBTTtBQUM5RTtBQUNBLE1BQU1XLGdCQUFnQjtBQUN0QixNQUFNQyxtQkFBbUI7QUFDekIsOERBQThEO0FBQzlELE1BQU1DLHVCQUF1QjtBQUM3QixNQUFNQyxlQUFlLGFBQWEsOEJBQThCO0FBQ2hFLE1BQU1DLGtCQUFrQixJQUFJQyxPQUFPLE1BQU1MLGdCQUFnQkcsY0FBYztB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O2dCQUMxQyxPQUFPeEY7WUFDWDtZQUNBLE9BQU9BO1FBQ1g7SUFDSjtJQUNBLE1BQU0yRixTQUFTWCxhQUFhbkUsU0FBU29FLFNBQVNDLGFBQWF2RDtJQUMzRGQsVUFBVTtRQUFDOEUsT0FBTzlFLE9BQU87V0FBS3lFO0tBQWlCLENBQUM3RSxJQUFJLENBQUM7SUFDckQsSUFBSXNFLHlCQUF5QjtRQUN6QlEsYUFBYUssT0FBTyxDQUFDLENBQUMsRUFBRUgsV0FBVyxFQUFFQyxPQUFPLEVBQUU7WUFDMUM3RSxVQUFVQSxRQUFRL0QsT0FBTyxDQUFDMkksYUFBYUM7UUFDM0M7SUFDSjtJQUNBQyxPQUFPUCxnQkFBZ0IsQ0FBQ1EsT0FBTyxDQUFDN0QsQ0FBQUE7UUFDNUJsQixVQUFVQSxRQUFRL0QsT0FBTyxDQUFDaUYsZ0JBQWdCRyxXQUFXLEVBQUVILGdCQUFnQk0sZUFBZTtJQUMxRjtJQUNBLE9BQU94QjtBQUNYO0FBRW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2hhdGV2ZXIvLi9ub2RlX21vZHVsZXMvLnBucG0vQHN0ZW5jaWwrY29yZUAyLjUuMi9ub2RlX21vZHVsZXMvQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQvc2hhZG93LWNzcy5qcz9mZWM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gU3RlbmNpbCBDbGllbnQgUGxhdGZvcm0gdjIuNS4yIHwgTUlUIExpY2Vuc2VkIHwgaHR0cHM6Ly9zdGVuY2lsanMuY29tXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKlxuICogVGhpcyBmaWxlIGlzIGEgcG9ydCBvZiBzaGFkb3dDU1MgZnJvbSB3ZWJjb21wb25lbnRzLmpzIHRvIFR5cGVTY3JpcHQuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vd2ViY29tcG9uZW50cy93ZWJjb21wb25lbnRzanMvYmxvYi80ZWZlY2Q3ZTBlL3NyYy9TaGFkb3dDU1MvU2hhZG93Q1NTLmpzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL2NvbXBpbGVyL3NyYy9zaGFkb3dfY3NzLnRzXG4gKi9cbmNvbnN0IHNhZmVTZWxlY3RvciA9IChzZWxlY3RvcikgPT4ge1xuICAgIGNvbnN0IHBsYWNlaG9sZGVycyA9IFtdO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgbGV0IGNvbnRlbnQ7XG4gICAgLy8gUmVwbGFjZXMgYXR0cmlidXRlIHNlbGVjdG9ycyB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAvLyBUaGUgV1MgaW4gW2F0dHI9XCJ2YSBsdWVcIl0gd291bGQgb3RoZXJ3aXNlIGJlIGludGVycHJldGVkIGFzIGEgc2VsZWN0b3Igc2VwYXJhdG9yLlxuICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSgvKFxcW1teXFxdXSpcXF0pL2csIChfLCBrZWVwKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcGxhY2VCeSA9IGBfX3BoLSR7aW5kZXh9X19gO1xuICAgICAgICBwbGFjZWhvbGRlcnMucHVzaChrZWVwKTtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VCeTtcbiAgICB9KTtcbiAgICAvLyBSZXBsYWNlcyB0aGUgZXhwcmVzc2lvbiBpbiBgOm50aC1jaGlsZCgybiArIDEpYCB3aXRoIGEgcGxhY2Vob2xkZXIuXG4gICAgLy8gV1MgYW5kIFwiK1wiIHdvdWxkIG90aGVyd2lzZSBiZSBpbnRlcnByZXRlZCBhcyBzZWxlY3RvciBzZXBhcmF0b3JzLlxuICAgIGNvbnRlbnQgPSBzZWxlY3Rvci5yZXBsYWNlKC8oOm50aC1bLVxcd10rKShcXChbXildK1xcKSkvZywgKF8sIHBzZXVkbywgZXhwKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcGxhY2VCeSA9IGBfX3BoLSR7aW5kZXh9X19gO1xuICAgICAgICBwbGFjZWhvbGRlcnMucHVzaChleHApO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICByZXR1cm4gcHNldWRvICsgcmVwbGFjZUJ5O1xuICAgIH0pO1xuICAgIGNvbnN0IHNzID0ge1xuICAgICAgICBjb250ZW50LFxuICAgICAgICBwbGFjZWhvbGRlcnMsXG4gICAgfTtcbiAgICByZXR1cm4gc3M7XG59O1xuY29uc3QgcmVzdG9yZVNhZmVTZWxlY3RvciA9IChwbGFjZWhvbGRlcnMsIGNvbnRlbnQpID0+IHtcbiAgICByZXR1cm4gY29udGVudC5yZXBsYWNlKC9fX3BoLShcXGQrKV9fL2csIChfLCBpbmRleCkgPT4gcGxhY2Vob2xkZXJzWytpbmRleF0pO1xufTtcbmNvbnN0IF9wb2x5ZmlsbEhvc3QgPSAnLXNoYWRvd2Nzc2hvc3QnO1xuY29uc3QgX3BvbHlmaWxsU2xvdHRlZCA9ICctc2hhZG93Y3Nzc2xvdHRlZCc7XG4vLyBub3RlOiA6aG9zdC1jb250ZXh0IHByZS1wcm9jZXNzZWQgdG8gLXNoYWRvd2Nzc2hvc3Rjb250ZXh0LlxuY29uc3QgX3BvbHlmaWxsSG9zdENvbnRleHQgPSAnLXNoYWRvd2Nzc2NvbnRleHQnO1xuY29uc3QgX3BhcmVuU3VmZml4ID0gJykoPzpcXFxcKCgnICsgJyg/OlxcXFwoW14pKF0qXFxcXCl8W14pKF0qKSs/JyArICcpXFxcXCkpPyhbXix7XSopJztcbmNvbnN0IF9jc3NDb2xvbkhvc3RSZSA9IG5ldyBSZWdFeHAoJygnICsgX3BvbHlmaWxsSG9zdCArIF9wYXJlblN1ZmZpeCwgJ2dpbScpO1xuY29uc3QgX2Nzc0NvbG9uSG9zdENvbnRleHRSZSA9IG5ldyBSZWdFeHAoJygnICsgX3BvbHlmaWxsSG9zdENvbnRleHQgKyBfcGFyZW5TdWZmaXgsICdnaW0nKTtcbmNvbnN0IF9jc3NDb2xvblNsb3R0ZWRSZSA9IG5ldyBSZWdFeHAoJygnICsgX3BvbHlmaWxsU2xvdHRlZCArIF9wYXJlblN1ZmZpeCwgJ2dpbScpO1xuY29uc3QgX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvciA9IF9wb2x5ZmlsbEhvc3QgKyAnLW5vLWNvbWJpbmF0b3InO1xuY29uc3QgX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvclJlID0gLy1zaGFkb3djc3Nob3N0LW5vLWNvbWJpbmF0b3IoW15cXHNdKikvO1xuY29uc3QgX3NoYWRvd0RPTVNlbGVjdG9yc1JlID0gWy86OnNoYWRvdy9nLCAvOjpjb250ZW50L2ddO1xuY29uc3QgX3NlbGVjdG9yUmVTdWZmaXggPSAnKFs+XFxcXHN+K1suLHs6XVtcXFxcc1xcXFxTXSopPyQnO1xuY29uc3QgX3BvbHlmaWxsSG9zdFJlID0gLy1zaGFkb3djc3Nob3N0L2dpbTtcbmNvbnN0IF9jb2xvbkhvc3RSZSA9IC86aG9zdC9naW07XG5jb25zdCBfY29sb25TbG90dGVkUmUgPSAvOjpzbG90dGVkL2dpbTtcbmNvbnN0IF9jb2xvbkhvc3RDb250ZXh0UmUgPSAvOmhvc3QtY29udGV4dC9naW07XG5jb25zdCBfY29tbWVudFJlID0gL1xcL1xcKlxccypbXFxzXFxTXSo/XFwqXFwvL2c7XG5jb25zdCBzdHJpcENvbW1lbnRzID0gKGlucHV0KSA9PiB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoX2NvbW1lbnRSZSwgJycpO1xufTtcbmNvbnN0IF9jb21tZW50V2l0aEhhc2hSZSA9IC9cXC9cXCpcXHMqI1xccypzb3VyY2UoTWFwcGluZyk/VVJMPVtcXHNcXFNdKz9cXCpcXC8vZztcbmNvbnN0IGV4dHJhY3RDb21tZW50c1dpdGhIYXNoID0gKGlucHV0KSA9PiB7XG4gICAgcmV0dXJuIGlucHV0Lm1hdGNoKF9jb21tZW50V2l0aEhhc2hSZSkgfHwgW107XG59O1xuY29uc3QgX3J1bGVSZSA9IC8oXFxzKikoW147XFx7XFx9XSs/KShcXHMqKSgoPzp7JUJMT0NLJX0/XFxzKjs/KXwoPzpcXHMqOykpL2c7XG5jb25zdCBfY3VybHlSZSA9IC8oW3t9XSkvZztcbmNvbnN0IE9QRU5fQ1VSTFkgPSAneyc7XG5jb25zdCBDTE9TRV9DVVJMWSA9ICd9JztcbmNvbnN0IEJMT0NLX1BMQUNFSE9MREVSID0gJyVCTE9DSyUnO1xuY29uc3QgcHJvY2Vzc1J1bGVzID0gKGlucHV0LCBydWxlQ2FsbGJhY2spID0+IHtcbiAgICBjb25zdCBpbnB1dFdpdGhFc2NhcGVkQmxvY2tzID0gZXNjYXBlQmxvY2tzKGlucHV0KTtcbiAgICBsZXQgbmV4dEJsb2NrSW5kZXggPSAwO1xuICAgIHJldHVybiBpbnB1dFdpdGhFc2NhcGVkQmxvY2tzLmVzY2FwZWRTdHJpbmcucmVwbGFjZShfcnVsZVJlLCAoLi4ubSkgPT4ge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9IG1bMl07XG4gICAgICAgIGxldCBjb250ZW50ID0gJyc7XG4gICAgICAgIGxldCBzdWZmaXggPSBtWzRdO1xuICAgICAgICBsZXQgY29udGVudFByZWZpeCA9ICcnO1xuICAgICAgICBpZiAoc3VmZml4ICYmIHN1ZmZpeC5zdGFydHNXaXRoKCd7JyArIEJMT0NLX1BMQUNFSE9MREVSKSkge1xuICAgICAgICAgICAgY29udGVudCA9IGlucHV0V2l0aEVzY2FwZWRCbG9ja3MuYmxvY2tzW25leHRCbG9ja0luZGV4KytdO1xuICAgICAgICAgICAgc3VmZml4ID0gc3VmZml4LnN1YnN0cmluZyhCTE9DS19QTEFDRUhPTERFUi5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgIGNvbnRlbnRQcmVmaXggPSAneyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3NzUnVsZSA9IHtcbiAgICAgICAgICAgIHNlbGVjdG9yLFxuICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcnVsZSA9IHJ1bGVDYWxsYmFjayhjc3NSdWxlKTtcbiAgICAgICAgcmV0dXJuIGAke21bMV19JHtydWxlLnNlbGVjdG9yfSR7bVszXX0ke2NvbnRlbnRQcmVmaXh9JHtydWxlLmNvbnRlbnR9JHtzdWZmaXh9YDtcbiAgICB9KTtcbn07XG5jb25zdCBlc2NhcGVCbG9ja3MgPSAoaW5wdXQpID0+IHtcbiAgICBjb25zdCBpbnB1dFBhcnRzID0gaW5wdXQuc3BsaXQoX2N1cmx5UmUpO1xuICAgIGNvbnN0IHJlc3VsdFBhcnRzID0gW107XG4gICAgY29uc3QgZXNjYXBlZEJsb2NrcyA9IFtdO1xuICAgIGxldCBicmFja2V0Q291bnQgPSAwO1xuICAgIGxldCBjdXJyZW50QmxvY2tQYXJ0cyA9IFtdO1xuICAgIGZvciAobGV0IHBhcnRJbmRleCA9IDA7IHBhcnRJbmRleCA8IGlucHV0UGFydHMubGVuZ3RoOyBwYXJ0SW5kZXgrKykge1xuICAgICAgICBjb25zdCBwYXJ0ID0gaW5wdXRQYXJ0c1twYXJ0SW5kZXhdO1xuICAgICAgICBpZiAocGFydCA9PT0gQ0xPU0VfQ1VSTFkpIHtcbiAgICAgICAgICAgIGJyYWNrZXRDb3VudC0tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChicmFja2V0Q291bnQgPiAwKSB7XG4gICAgICAgICAgICBjdXJyZW50QmxvY2tQYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRCbG9ja1BhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBlc2NhcGVkQmxvY2tzLnB1c2goY3VycmVudEJsb2NrUGFydHMuam9pbignJykpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFBhcnRzLnB1c2goQkxPQ0tfUExBQ0VIT0xERVIpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCbG9ja1BhcnRzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRQYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0ID09PSBPUEVOX0NVUkxZKSB7XG4gICAgICAgICAgICBicmFja2V0Q291bnQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3VycmVudEJsb2NrUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICBlc2NhcGVkQmxvY2tzLnB1c2goY3VycmVudEJsb2NrUGFydHMuam9pbignJykpO1xuICAgICAgICByZXN1bHRQYXJ0cy5wdXNoKEJMT0NLX1BMQUNFSE9MREVSKTtcbiAgICB9XG4gICAgY29uc3Qgc3RyRXNjYXBlZEJsb2NrcyA9IHtcbiAgICAgICAgZXNjYXBlZFN0cmluZzogcmVzdWx0UGFydHMuam9pbignJyksXG4gICAgICAgIGJsb2NrczogZXNjYXBlZEJsb2NrcyxcbiAgICB9O1xuICAgIHJldHVybiBzdHJFc2NhcGVkQmxvY2tzO1xufTtcbmNvbnN0IGluc2VydFBvbHlmaWxsSG9zdEluQ3NzVGV4dCA9IChzZWxlY3RvcikgPT4ge1xuICAgIHNlbGVjdG9yID0gc2VsZWN0b3JcbiAgICAgICAgLnJlcGxhY2UoX2NvbG9uSG9zdENvbnRleHRSZSwgX3BvbHlmaWxsSG9zdENvbnRleHQpXG4gICAgICAgIC5yZXBsYWNlKF9jb2xvbkhvc3RSZSwgX3BvbHlmaWxsSG9zdClcbiAgICAgICAgLnJlcGxhY2UoX2NvbG9uU2xvdHRlZFJlLCBfcG9seWZpbGxTbG90dGVkKTtcbiAgICByZXR1cm4gc2VsZWN0b3I7XG59O1xuY29uc3QgY29udmVydENvbG9uUnVsZSA9IChjc3NUZXh0LCByZWdFeHAsIHBhcnRSZXBsYWNlcikgPT4ge1xuICAgIC8vIG1bMV0gPSA6aG9zdCgtY29udGV4dCksIG1bMl0gPSBjb250ZW50cyBvZiAoKSwgbVszXSByZXN0IG9mIHJ1bGVcbiAgICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKHJlZ0V4cCwgKC4uLm0pID0+IHtcbiAgICAgICAgaWYgKG1bMl0pIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gbVsyXS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgY29uc3QgciA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwYXJ0c1tpXS50cmltKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICByLnB1c2gocGFydFJlcGxhY2VyKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IsIHAsIG1bM10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByLmpvaW4oJywnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yICsgbVszXTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmNvbnN0IGNvbG9uSG9zdFBhcnRSZXBsYWNlciA9IChob3N0LCBwYXJ0LCBzdWZmaXgpID0+IHtcbiAgICByZXR1cm4gaG9zdCArIHBhcnQucmVwbGFjZShfcG9seWZpbGxIb3N0LCAnJykgKyBzdWZmaXg7XG59O1xuY29uc3QgY29udmVydENvbG9uSG9zdCA9IChjc3NUZXh0KSA9PiB7XG4gICAgcmV0dXJuIGNvbnZlcnRDb2xvblJ1bGUoY3NzVGV4dCwgX2Nzc0NvbG9uSG9zdFJlLCBjb2xvbkhvc3RQYXJ0UmVwbGFjZXIpO1xufTtcbmNvbnN0IGNvbG9uSG9zdENvbnRleHRQYXJ0UmVwbGFjZXIgPSAoaG9zdCwgcGFydCwgc3VmZml4KSA9PiB7XG4gICAgaWYgKHBhcnQuaW5kZXhPZihfcG9seWZpbGxIb3N0KSA+IC0xKSB7XG4gICAgICAgIHJldHVybiBjb2xvbkhvc3RQYXJ0UmVwbGFjZXIoaG9zdCwgcGFydCwgc3VmZml4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBob3N0ICsgcGFydCArIHN1ZmZpeCArICcsICcgKyBwYXJ0ICsgJyAnICsgaG9zdCArIHN1ZmZpeDtcbiAgICB9XG59O1xuY29uc3QgY29udmVydENvbG9uU2xvdHRlZCA9IChjc3NUZXh0LCBzbG90U2NvcGVJZCkgPT4ge1xuICAgIGNvbnN0IHNsb3RDbGFzcyA9ICcuJyArIHNsb3RTY29wZUlkICsgJyA+ICc7XG4gICAgY29uc3Qgc2VsZWN0b3JzID0gW107XG4gICAgY3NzVGV4dCA9IGNzc1RleHQucmVwbGFjZShfY3NzQ29sb25TbG90dGVkUmUsICguLi5tKSA9PiB7XG4gICAgICAgIGlmIChtWzJdKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb3VuZCA9IG1bMl0udHJpbSgpO1xuICAgICAgICAgICAgY29uc3Qgc3VmZml4ID0gbVszXTtcbiAgICAgICAgICAgIGNvbnN0IHNsb3R0ZWRTZWxlY3RvciA9IHNsb3RDbGFzcyArIGNvbXBvdW5kICsgc3VmZml4O1xuICAgICAgICAgICAgbGV0IHByZWZpeFNlbGVjdG9yID0gJyc7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbVs0XSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhciA9IG1bNV1baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09ICd9JyB8fCBjaGFyID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZWZpeFNlbGVjdG9yID0gY2hhciArIHByZWZpeFNlbGVjdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3JnU2VsZWN0b3IgPSBwcmVmaXhTZWxlY3RvciArIHNsb3R0ZWRTZWxlY3RvcjtcbiAgICAgICAgICAgIGNvbnN0IGFkZGVkU2VsZWN0b3IgPSBgJHtwcmVmaXhTZWxlY3Rvci50cmltUmlnaHQoKX0ke3Nsb3R0ZWRTZWxlY3Rvci50cmltKCl9YDtcbiAgICAgICAgICAgIGlmIChvcmdTZWxlY3Rvci50cmltKCkgIT09IGFkZGVkU2VsZWN0b3IudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFNlbGVjdG9yID0gYCR7YWRkZWRTZWxlY3Rvcn0sICR7b3JnU2VsZWN0b3J9YDtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG9yZ1NlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkU2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2xvdHRlZFNlbGVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IgKyBtWzNdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0b3JzLFxuICAgICAgICBjc3NUZXh0LFxuICAgIH07XG59O1xuY29uc3QgY29udmVydENvbG9uSG9zdENvbnRleHQgPSAoY3NzVGV4dCkgPT4ge1xuICAgIHJldHVybiBjb252ZXJ0Q29sb25SdWxlKGNzc1RleHQsIF9jc3NDb2xvbkhvc3RDb250ZXh0UmUsIGNvbG9uSG9zdENvbnRleHRQYXJ0UmVwbGFjZXIpO1xufTtcbmNvbnN0IGNvbnZlcnRTaGFkb3dET01TZWxlY3RvcnMgPSAoY3NzVGV4dCkgPT4ge1xuICAgIHJldHVybiBfc2hhZG93RE9NU2VsZWN0b3JzUmUucmVkdWNlKChyZXN1bHQsIHBhdHRlcm4pID0+IHJlc3VsdC5yZXBsYWNlKHBhdHRlcm4sICcgJyksIGNzc1RleHQpO1xufTtcbmNvbnN0IG1ha2VTY29wZU1hdGNoZXIgPSAoc2NvcGVTZWxlY3RvcikgPT4ge1xuICAgIGNvbnN0IGxyZSA9IC9cXFsvZztcbiAgICBjb25zdCBycmUgPSAvXFxdL2c7XG4gICAgc2NvcGVTZWxlY3RvciA9IHNjb3BlU2VsZWN0b3IucmVwbGFjZShscmUsICdcXFxcWycpLnJlcGxhY2UocnJlLCAnXFxcXF0nKTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXignICsgc2NvcGVTZWxlY3RvciArICcpJyArIF9zZWxlY3RvclJlU3VmZml4LCAnbScpO1xufTtcbmNvbnN0IHNlbGVjdG9yTmVlZHNTY29waW5nID0gKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yKSA9PiB7XG4gICAgY29uc3QgcmUgPSBtYWtlU2NvcGVNYXRjaGVyKHNjb3BlU2VsZWN0b3IpO1xuICAgIHJldHVybiAhcmUudGVzdChzZWxlY3Rvcik7XG59O1xuY29uc3QgYXBwbHlTaW1wbGVTZWxlY3RvclNjb3BlID0gKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpID0+IHtcbiAgICAvLyBJbiBBbmRyb2lkIGJyb3dzZXIsIHRoZSBsYXN0SW5kZXggaXMgbm90IHJlc2V0IHdoZW4gdGhlIHJlZ2V4IGlzIHVzZWQgaW4gU3RyaW5nLnJlcGxhY2UoKVxuICAgIF9wb2x5ZmlsbEhvc3RSZS5sYXN0SW5kZXggPSAwO1xuICAgIGlmIChfcG9seWZpbGxIb3N0UmUudGVzdChzZWxlY3RvcikpIHtcbiAgICAgICAgY29uc3QgcmVwbGFjZUJ5ID0gYC4ke2hvc3RTZWxlY3Rvcn1gO1xuICAgICAgICByZXR1cm4gc2VsZWN0b3JcbiAgICAgICAgICAgIC5yZXBsYWNlKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3JSZSwgKF8sIHNlbGVjdG9yKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0b3IucmVwbGFjZSgvKFteOl0qKSg6KikoLiopLywgKF8sIGJlZm9yZSwgY29sb24sIGFmdGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlZm9yZSArIHJlcGxhY2VCeSArIGNvbG9uICsgYWZ0ZXI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKF9wb2x5ZmlsbEhvc3RSZSwgcmVwbGFjZUJ5ICsgJyAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlU2VsZWN0b3IgKyAnICcgKyBzZWxlY3Rvcjtcbn07XG5jb25zdCBhcHBseVN0cmljdFNlbGVjdG9yU2NvcGUgPSAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3RvcikgPT4ge1xuICAgIGNvbnN0IGlzUmUgPSAvXFxbaXM9KFteXFxdXSopXFxdL2c7XG4gICAgc2NvcGVTZWxlY3RvciA9IHNjb3BlU2VsZWN0b3IucmVwbGFjZShpc1JlLCAoXywgLi4ucGFydHMpID0+IHBhcnRzWzBdKTtcbiAgICBjb25zdCBjbGFzc05hbWUgPSAnLicgKyBzY29wZVNlbGVjdG9yO1xuICAgIGNvbnN0IF9zY29wZVNlbGVjdG9yUGFydCA9IChwKSA9PiB7XG4gICAgICAgIGxldCBzY29wZWRQID0gcC50cmltKCk7XG4gICAgICAgIGlmICghc2NvcGVkUCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwLmluZGV4T2YoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvcikgPiAtMSkge1xuICAgICAgICAgICAgc2NvcGVkUCA9IGFwcGx5U2ltcGxlU2VsZWN0b3JTY29wZShwLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIDpob3N0IHNpbmNlIGl0IHNob3VsZCBiZSB1bm5lY2Vzc2FyeVxuICAgICAgICAgICAgY29uc3QgdCA9IHAucmVwbGFjZShfcG9seWZpbGxIb3N0UmUsICcnKTtcbiAgICAgICAgICAgIGlmICh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gdC5tYXRjaCgvKFteOl0qKSg6KikoLiopLyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVkUCA9IG1hdGNoZXNbMV0gKyBjbGFzc05hbWUgKyBtYXRjaGVzWzJdICsgbWF0Y2hlc1szXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjb3BlZFA7XG4gICAgfTtcbiAgICBjb25zdCBzYWZlQ29udGVudCA9IHNhZmVTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgc2VsZWN0b3IgPSBzYWZlQ29udGVudC5jb250ZW50O1xuICAgIGxldCBzY29wZWRTZWxlY3RvciA9ICcnO1xuICAgIGxldCBzdGFydEluZGV4ID0gMDtcbiAgICBsZXQgcmVzO1xuICAgIGNvbnN0IHNlcCA9IC8oIHw+fFxcK3x+KD8hPSkpXFxzKi9nO1xuICAgIC8vIElmIGEgc2VsZWN0b3IgYXBwZWFycyBiZWZvcmUgOmhvc3QgaXQgc2hvdWxkIG5vdCBiZSBzaGltbWVkIGFzIGl0XG4gICAgLy8gbWF0Y2hlcyBvbiBhbmNlc3RvciBlbGVtZW50cyBhbmQgbm90IG9uIGVsZW1lbnRzIGluIHRoZSBob3N0J3Mgc2hhZG93XG4gICAgLy8gYDpob3N0LWNvbnRleHQoZGl2KWAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgICAvLyBgLXNoYWRvd2Nzc2hvc3Qtbm8tY29tYmluYXRvcmRpdiwgZGl2IC1zaGFkb3djc3Nob3N0LW5vLWNvbWJpbmF0b3JgXG4gICAgLy8gdGhlIGBkaXZgIGlzIG5vdCBwYXJ0IG9mIHRoZSBjb21wb25lbnQgaW4gdGhlIDJuZCBzZWxlY3RvcnMgYW5kIHNob3VsZCBub3QgYmUgc2NvcGVkLlxuICAgIC8vIEhpc3RvcmljYWxseSBgY29tcG9uZW50LXRhZzpob3N0YCB3YXMgbWF0Y2hpbmcgdGhlIGNvbXBvbmVudCBzbyB3ZSBhbHNvIHdhbnQgdG8gcHJlc2VydmVcbiAgICAvLyB0aGlzIGJlaGF2aW9yIHRvIGF2b2lkIGJyZWFraW5nIGxlZ2FjeSBhcHBzIChpdCBzaG91bGQgbm90IG1hdGNoKS5cbiAgICAvLyBUaGUgYmVoYXZpb3Igc2hvdWxkIGJlOlxuICAgIC8vIC0gYHRhZzpob3N0YCAtPiBgdGFnW2hdYCAodGhpcyBpcyB0byBhdm9pZCBicmVha2luZyBsZWdhY3kgYXBwcywgc2hvdWxkIG5vdCBtYXRjaCBhbnl0aGluZylcbiAgICAvLyAtIGB0YWcgOmhvc3RgIC0+IGB0YWcgW2hdYCAoYHRhZ2AgaXMgbm90IHNjb3BlZCBiZWNhdXNlIGl0J3MgY29uc2lkZXJlZCBwYXJ0IG9mIGFcbiAgICAvLyAgIGA6aG9zdC1jb250ZXh0KHRhZylgKVxuICAgIGNvbnN0IGhhc0hvc3QgPSBzZWxlY3Rvci5pbmRleE9mKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IpID4gLTE7XG4gICAgLy8gT25seSBzY29wZSBwYXJ0cyBhZnRlciB0aGUgZmlyc3QgYC1zaGFkb3djc3Nob3N0LW5vLWNvbWJpbmF0b3JgIHdoZW4gaXQgaXMgcHJlc2VudFxuICAgIGxldCBzaG91bGRTY29wZSA9ICFoYXNIb3N0O1xuICAgIHdoaWxlICgocmVzID0gc2VwLmV4ZWMoc2VsZWN0b3IpKSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBzZXBhcmF0b3IgPSByZXNbMV07XG4gICAgICAgIGNvbnN0IHBhcnQgPSBzZWxlY3Rvci5zbGljZShzdGFydEluZGV4LCByZXMuaW5kZXgpLnRyaW0oKTtcbiAgICAgICAgc2hvdWxkU2NvcGUgPSBzaG91bGRTY29wZSB8fCBwYXJ0LmluZGV4T2YoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvcikgPiAtMTtcbiAgICAgICAgY29uc3Qgc2NvcGVkUGFydCA9IHNob3VsZFNjb3BlID8gX3Njb3BlU2VsZWN0b3JQYXJ0KHBhcnQpIDogcGFydDtcbiAgICAgICAgc2NvcGVkU2VsZWN0b3IgKz0gYCR7c2NvcGVkUGFydH0gJHtzZXBhcmF0b3J9IGA7XG4gICAgICAgIHN0YXJ0SW5kZXggPSBzZXAubGFzdEluZGV4O1xuICAgIH1cbiAgICBjb25zdCBwYXJ0ID0gc2VsZWN0b3Iuc3Vic3RyaW5nKHN0YXJ0SW5kZXgpO1xuICAgIHNob3VsZFNjb3BlID0gc2hvdWxkU2NvcGUgfHwgcGFydC5pbmRleE9mKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IpID4gLTE7XG4gICAgc2NvcGVkU2VsZWN0b3IgKz0gc2hvdWxkU2NvcGUgPyBfc2NvcGVTZWxlY3RvclBhcnQocGFydCkgOiBwYXJ0O1xuICAgIC8vIHJlcGxhY2UgdGhlIHBsYWNlaG9sZGVycyB3aXRoIHRoZWlyIG9yaWdpbmFsIHZhbHVlc1xuICAgIHJldHVybiByZXN0b3JlU2FmZVNlbGVjdG9yKHNhZmVDb250ZW50LnBsYWNlaG9sZGVycywgc2NvcGVkU2VsZWN0b3IpO1xufTtcbmNvbnN0IHNjb3BlU2VsZWN0b3IgPSAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3JUZXh0LCBob3N0U2VsZWN0b3IsIHNsb3RTZWxlY3RvcikgPT4ge1xuICAgIHJldHVybiBzZWxlY3RvclxuICAgICAgICAuc3BsaXQoJywnKVxuICAgICAgICAubWFwKHNoYWxsb3dQYXJ0ID0+IHtcbiAgICAgICAgaWYgKHNsb3RTZWxlY3RvciAmJiBzaGFsbG93UGFydC5pbmRleE9mKCcuJyArIHNsb3RTZWxlY3RvcikgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHNoYWxsb3dQYXJ0LnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZWN0b3JOZWVkc1Njb3Bpbmcoc2hhbGxvd1BhcnQsIHNjb3BlU2VsZWN0b3JUZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5U3RyaWN0U2VsZWN0b3JTY29wZShzaGFsbG93UGFydCwgc2NvcGVTZWxlY3RvclRleHQsIGhvc3RTZWxlY3RvcikudHJpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNoYWxsb3dQYXJ0LnRyaW0oKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgICAgIC5qb2luKCcsICcpO1xufTtcbmNvbnN0IHNjb3BlU2VsZWN0b3JzID0gKGNzc1RleHQsIHNjb3BlU2VsZWN0b3JUZXh0LCBob3N0U2VsZWN0b3IsIHNsb3RTZWxlY3RvciwgY29tbWVudE9yaWdpbmFsU2VsZWN0b3IpID0+IHtcbiAgICByZXR1cm4gcHJvY2Vzc1J1bGVzKGNzc1RleHQsIChydWxlKSA9PiB7XG4gICAgICAgIGxldCBzZWxlY3RvciA9IHJ1bGUuc2VsZWN0b3I7XG4gICAgICAgIGxldCBjb250ZW50ID0gcnVsZS5jb250ZW50O1xuICAgICAgICBpZiAocnVsZS5zZWxlY3RvclswXSAhPT0gJ0AnKSB7XG4gICAgICAgICAgICBzZWxlY3RvciA9IHNjb3BlU2VsZWN0b3IocnVsZS5zZWxlY3Rvciwgc2NvcGVTZWxlY3RvclRleHQsIGhvc3RTZWxlY3Rvciwgc2xvdFNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0BtZWRpYScpIHx8IHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQHN1cHBvcnRzJykgfHwgcnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKCdAcGFnZScpIHx8IHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQGRvY3VtZW50JykpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBzY29wZVNlbGVjdG9ycyhydWxlLmNvbnRlbnQsIHNjb3BlU2VsZWN0b3JUZXh0LCBob3N0U2VsZWN0b3IsIHNsb3RTZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3NzUnVsZSA9IHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3Rvci5yZXBsYWNlKC9cXHN7Mix9L2csICcgJykudHJpbSgpLFxuICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNzc1J1bGU7XG4gICAgfSk7XG59O1xuY29uc3Qgc2NvcGVDc3NUZXh0ID0gKGNzc1RleHQsIHNjb3BlSWQsIGhvc3RTY29wZUlkLCBzbG90U2NvcGVJZCwgY29tbWVudE9yaWdpbmFsU2VsZWN0b3IpID0+IHtcbiAgICBjc3NUZXh0ID0gaW5zZXJ0UG9seWZpbGxIb3N0SW5Dc3NUZXh0KGNzc1RleHQpO1xuICAgIGNzc1RleHQgPSBjb252ZXJ0Q29sb25Ib3N0KGNzc1RleHQpO1xuICAgIGNzc1RleHQgPSBjb252ZXJ0Q29sb25Ib3N0Q29udGV4dChjc3NUZXh0KTtcbiAgICBjb25zdCBzbG90dGVkID0gY29udmVydENvbG9uU2xvdHRlZChjc3NUZXh0LCBzbG90U2NvcGVJZCk7XG4gICAgY3NzVGV4dCA9IHNsb3R0ZWQuY3NzVGV4dDtcbiAgICBjc3NUZXh0ID0gY29udmVydFNoYWRvd0RPTVNlbGVjdG9ycyhjc3NUZXh0KTtcbiAgICBpZiAoc2NvcGVJZCkge1xuICAgICAgICBjc3NUZXh0ID0gc2NvcGVTZWxlY3RvcnMoY3NzVGV4dCwgc2NvcGVJZCwgaG9zdFNjb3BlSWQsIHNsb3RTY29wZUlkKTtcbiAgICB9XG4gICAgY3NzVGV4dCA9IGNzc1RleHQucmVwbGFjZSgvLXNoYWRvd2Nzc2hvc3Qtbm8tY29tYmluYXRvci9nLCBgLiR7aG9zdFNjb3BlSWR9YCk7XG4gICAgY3NzVGV4dCA9IGNzc1RleHQucmVwbGFjZSgvPlxccypcXCpcXHMrKFteeywgXSspL2dtLCAnICQxICcpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNzc1RleHQ6IGNzc1RleHQudHJpbSgpLFxuICAgICAgICBzbG90dGVkU2VsZWN0b3JzOiBzbG90dGVkLnNlbGVjdG9ycyxcbiAgICB9O1xufTtcbmNvbnN0IHNjb3BlQ3NzID0gKGNzc1RleHQsIHNjb3BlSWQsIGNvbW1lbnRPcmlnaW5hbFNlbGVjdG9yKSA9PiB7XG4gICAgY29uc3QgaG9zdFNjb3BlSWQgPSBzY29wZUlkICsgJy1oJztcbiAgICBjb25zdCBzbG90U2NvcGVJZCA9IHNjb3BlSWQgKyAnLXMnO1xuICAgIGNvbnN0IGNvbW1lbnRzV2l0aEhhc2ggPSBleHRyYWN0Q29tbWVudHNXaXRoSGFzaChjc3NUZXh0KTtcbiAgICBjc3NUZXh0ID0gc3RyaXBDb21tZW50cyhjc3NUZXh0KTtcbiAgICBjb25zdCBvcmdTZWxlY3RvcnMgPSBbXTtcbiAgICBpZiAoY29tbWVudE9yaWdpbmFsU2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgcHJvY2Vzc0NvbW1lbnRlZFNlbGVjdG9yID0gKHJ1bGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gYC8qIUBfX18ke29yZ1NlbGVjdG9ycy5sZW5ndGh9X19fKi9gO1xuICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IGAvKiFAJHtydWxlLnNlbGVjdG9yfSovYDtcbiAgICAgICAgICAgIG9yZ1NlbGVjdG9ycy5wdXNoKHsgcGxhY2Vob2xkZXIsIGNvbW1lbnQgfSk7XG4gICAgICAgICAgICBydWxlLnNlbGVjdG9yID0gcGxhY2Vob2xkZXIgKyBydWxlLnNlbGVjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgICAgIH07XG4gICAgICAgIGNzc1RleHQgPSBwcm9jZXNzUnVsZXMoY3NzVGV4dCwgcnVsZSA9PiB7XG4gICAgICAgICAgICBpZiAocnVsZS5zZWxlY3RvclswXSAhPT0gJ0AnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NDb21tZW50ZWRTZWxlY3RvcihydWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQG1lZGlhJykgfHwgcnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKCdAc3VwcG9ydHMnKSB8fCBydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0BwYWdlJykgfHwgcnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKCdAZG9jdW1lbnQnKSkge1xuICAgICAgICAgICAgICAgIHJ1bGUuY29udGVudCA9IHByb2Nlc3NSdWxlcyhydWxlLmNvbnRlbnQsIHByb2Nlc3NDb21tZW50ZWRTZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHNjb3BlZCA9IHNjb3BlQ3NzVGV4dChjc3NUZXh0LCBzY29wZUlkLCBob3N0U2NvcGVJZCwgc2xvdFNjb3BlSWQpO1xuICAgIGNzc1RleHQgPSBbc2NvcGVkLmNzc1RleHQsIC4uLmNvbW1lbnRzV2l0aEhhc2hdLmpvaW4oJ1xcbicpO1xuICAgIGlmIChjb21tZW50T3JpZ2luYWxTZWxlY3Rvcikge1xuICAgICAgICBvcmdTZWxlY3RvcnMuZm9yRWFjaCgoeyBwbGFjZWhvbGRlciwgY29tbWVudCB9KSA9PiB7XG4gICAgICAgICAgICBjc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKHBsYWNlaG9sZGVyLCBjb21tZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNjb3BlZC5zbG90dGVkU2VsZWN0b3JzLmZvckVhY2goc2xvdHRlZFNlbGVjdG9yID0+IHtcbiAgICAgICAgY3NzVGV4dCA9IGNzc1RleHQucmVwbGFjZShzbG90dGVkU2VsZWN0b3Iub3JnU2VsZWN0b3IsIHNsb3R0ZWRTZWxlY3Rvci51cGRhdGVkU2VsZWN0b3IpO1xuICAgIH0pO1xuICAgIHJldHVybiBjc3NUZXh0O1xufTtcblxuZXhwb3J0IHsgc2NvcGVDc3MgfTtcbiJdLCJuYW1lcyI6WyJzYWZlU2VsZWN0b3IiLCJzZWxlY3RvciIsInBsYWNlaG9sZGVycyIsImluZGV4IiwiY29udGVudCIsInJlcGxhY2UiLCJfIiwia2VlcCIsInJlcGxhY2VCeSIsInB1c2giLCJwc2V1ZG8iLCJleHAiLCJzcyIsInJlc3RvcmVTYWZlU2VsZWN0b3IiLCJfcG9seWZpbGxIb3N0IiwiX3BvbHlmaWxsU2xvdHRlZCIsIl9wb2x5ZmlsbEhvc3RDb250ZXh0IiwiX3BhcmVuU3VmZml4IiwiX2Nzc0NvbG9uSG9zdFJlIiwiUmVnRXhwIiwiX2Nzc0NvbG9uSG9zdENvbnRleHRSZSIsIl9jc3NDb2xvblNsb3R0ZWRSZSIsIl9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IiLCJfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yUmUiLCJfc2hhZG93RE9NU2VsZWN0b3JzUmUiLCJfc2VsZWN0b3JSZVN1ZmZpeCIsIl9wb2x5ZmlsbEhvc3RSZSIsIl9jb2xvbkhvc3RSZSIsIl9jb2xvblNsb3R0ZWRSZSIsIl9jb2xvbkhvc3RDb250ZXh0UmUiLCJfY29tbWVudFJlIiwic3RyaXBDb21tZW50cyIsImlucHV0IiwiX2NvbW1lbnRXaXRoSGFzaFJlIiwiZXh0cmFjdENvbW1lbnRzV2l0aEhhc2giLCJtYXRjaCIsIl9ydWxlUmUiLCJfY3VybHlSZSIsIk9QRU5fQ1VSTFkiLCJDTE9TRV9DVVJMWSIsIkJMT0NLX1BMQUNFSE9MREVSIiwicHJvY2Vzc1J1bGVzIiwicnVsZUNhbGxiYWNrIiwiaW5wdXRXaXRoRXNjYXBlZEJsb2NrcyIsImVzY2FwZUJsb2NrcyIsIm5leHRCbG9ja0luZGV4IiwiZXNjYXBlZFN0cmluZyIsIm0iLCJzdWZmaXgiLCJjb250ZW50UHJlZml4Iiwic3RhcnRzV2l0aCIsImJsb2NrcyIsInN1YnN0cmluZyIsImxlbmd0aCIsImNzc1J1bGUiLCJydWxlIiwiaW5wdXRQYXJ0cyIsInNwbGl0IiwicmVzdWx0UGFydHMiLCJlc2NhcGVkQmxvY2tzIiwiYnJhY2tldENvdW50IiwiY3VycmVudEJsb2NrUGFydHMiLCJwYXJ0SW5kZXgiLCJwYXJ0Iiwiam9pbiIsInN0ckVzY2FwZWRCbG9ja3MiLCJpbnNlcnRQb2x5ZmlsbEhvc3RJbkNzc1RleHQiLCJjb252ZXJ0Q29sb25SdWxlIiwiY3NzVGV4dCIsInJlZ0V4cCIsInBhcnRSZXBsYWNlciIsInBhcnRzIiwiciIsImkiLCJwIiwidHJpbSIsImNvbG9uSG9zdFBhcnRSZXBsYWNlciIsImhvc3QiLCJjb252ZXJ0Q29sb25Ib3N0IiwiY29sb25Ib3N0Q29udGV4dFBhcnRSZXBsYWNlciIsImluZGV4T2YiLCJjb252ZXJ0Q29sb25TbG90dGVkIiwic2xvdFNjb3BlSWQiLCJzbG90Q2xhc3MiLCJzZWxlY3RvcnMiLCJjb21wb3VuZCIsInNsb3R0ZWRTZWxlY3RvciIsInByZWZpeFNlbGVjdG9yIiwiY2hhciIsIm9yZ1NlbGVjdG9yIiwiYWRkZWRTZWxlY3RvciIsInRyaW1SaWdodCIsInVwZGF0ZWRTZWxlY3RvciIsImNvbnZlcnRDb2xvbkhvc3RDb250ZXh0IiwiY29udmVydFNoYWRvd0RPTVNlbGVjdG9ycyIsInJlZHVjZSIsInJlc3VsdCIsInBhdHRlcm4iLCJtYWtlU2NvcGVNYXRjaGVyIiwic2NvcGVTZWxlY3RvciIsImxyZSIsInJyZSIsInNlbGVjdG9yTmVlZHNTY29waW5nIiwicmUiLCJ0ZXN0IiwiYXBwbHlTaW1wbGVTZWxlY3RvclNjb3BlIiwiaG9zdFNlbGVjdG9yIiwibGFzdEluZGV4IiwiYmVmb3JlIiwiY29sb24iLCJhZnRlciIsImFwcGx5U3RyaWN0U2VsZWN0b3JTY29wZSIsImlzUmUiLCJjbGFzc05hbWUiLCJfc2NvcGVTZWxlY3RvclBhcnQiLCJzY29wZWRQIiwidCIsIm1hdGNoZXMiLCJzYWZlQ29udGVudCIsInNjb3BlZFNlbGVjdG9yIiwic3RhcnRJbmRleCIsInJlcyIsInNlcCIsImhhc0hvc3QiLCJzaG91bGRTY29wZSIsImV4ZWMiLCJzZXBhcmF0b3IiLCJzbGljZSIsInNjb3BlZFBhcnQiLCJzY29wZVNlbGVjdG9yVGV4dCIsInNsb3RTZWxlY3RvciIsIm1hcCIsInNoYWxsb3dQYXJ0Iiwic2NvcGVTZWxlY3RvcnMiLCJjb21tZW50T3JpZ2luYWxTZWxlY3RvciIsInNjb3BlQ3NzVGV4dCIsInNjb3BlSWQiLCJob3N0U2NvcGVJZCIsInNsb3R0ZWQiLCJzbG90dGVkU2VsZWN0b3JzIiwic2NvcGVDc3MiLCJjb21tZW50c1dpdGhIYXNoIiwib3JnU2VsZWN0b3JzIiwicHJvY2Vzc0NvbW1lbnRlZFNlbGVjdG9yIiwicGxhY2Vob2xkZXIiLCJjb21tZW50Iiwic2NvcGVkIiwiZm9yRWFjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@stencil+core@2.5.2/node_modules/@stencil/core/internal/client/shadow-css.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@stencil+core@2.5.2/node_modules/@stencil/core/internal/app-data/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@stencil+core@2.5.2/node_modules/@stencil/core/internal/app-data/index.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BUILD: () => (/* binding */ BUILD),\n/* harmony export */   Env: () => (/* binding */ Env),\n/* harmony export */   NAMESPACE: () => (/* binding */ NAMESPACE)\n/* harmony export */ });\nconst BUILD = {\n    allRenderFn: false,\n    cmpDidLoad: true,\n    cmpDidUnload: false,\n    cmpDidUpdate: true,\n    cmpDidRender: true,\n    cmpWillLoad: true,\n    cmpWillUpdate: true,\n    cmpWillRender: true,\n    connectedCallback: true,\n    disconnectedCallback: true,\n    element: true,\n    event: true,\n    hasRenderFn: true,\n    lifecycle: true,\n    hostListener: true,\n    hostListenerTargetWindow: true,\n    hostListenerTargetDocument: true,\n    hostListenerTargetBody: true,\n    hostListenerTargetParent: false,\n    hostListenerTarget: true,\n    member: true,\n    method: true,\n    mode: true,\n    observeAttribute: true,\n    prop: true,\n    propMutable: true,\n    reflect: true,\n    scoped: true,\n    shadowDom: true,\n    slot: true,\n    cssAnnotations: true,\n    state: true,\n    style: true,\n    svg: true,\n    updatable: true,\n    vdomAttribute: true,\n    vdomXlink: true,\n    vdomClass: true,\n    vdomFunctional: true,\n    vdomKey: true,\n    vdomListener: true,\n    vdomRef: true,\n    vdomPropOrAttr: true,\n    vdomRender: true,\n    vdomStyle: true,\n    vdomText: true,\n    watchCallback: true,\n    taskQueue: true,\n    hotModuleReplacement: false,\n    isDebug: false,\n    isDev: false,\n    isTesting: false,\n    hydrateServerSide: false,\n    hydrateClientSide: false,\n    lifecycleDOMEvents: false,\n    lazyLoad: false,\n    profile: false,\n    slotRelocation: true,\n    appendChildSlotFix: false,\n    cloneNodeFix: false,\n    hydratedAttribute: false,\n    hydratedClass: true,\n    safari10: false,\n    scriptDataOpts: false,\n    shadowDomShim: false,\n    slotChildNodesFix: false,\n    propBoolean: true,\n    propNumber: true,\n    propString: true,\n    cssVarShim: false,\n    constructableCSS: true,\n    cmpShouldUpdate: true,\n    devTools: false,\n    dynamicImportShim: false,\n    shadowDelegatesFocus: true,\n    initializeNextTick: false,\n    asyncLoading: false,\n    asyncQueue: false,\n    transformTagName: false,\n    attachStyles: true\n};\nconst Env = {};\nconst NAMESPACE = /* default */ \"app\";\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHN0ZW5jaWwrY29yZUAyLjUuMi9ub2RlX21vZHVsZXMvQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9hcHAtZGF0YS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxNQUFNQSxRQUFRO0lBQ1ZDLGFBQWE7SUFDYkMsWUFBWTtJQUNaQyxjQUFjO0lBQ2RDLGNBQWM7SUFDZEMsY0FBYztJQUNkQyxhQUFhO0lBQ2JDLGVBQWU7SUFDZkMsZUFBZTtJQUNmQyxtQkFBbUI7SUFDbkJDLHNCQUFzQjtJQUN0QkMsU0FBUztJQUNUQyxPQUFPO0lBQ1BDLGFBQWE7SUFDYkMsV0FBVztJQUNYQyxjQUFjO0lBQ2RDLDBCQUEwQjtJQUMxQkMsNEJBQTRCO0lBQzVCQyx3QkFBd0I7SUFDeEJDLDBCQUEwQjtJQUMxQkMsb0JBQW9CO0lBQ3BCQyxRQUFRO0lBQ1JDLFFBQVE7SUFDUkMsTUFBTTtJQUNOQyxrQkFBa0I7SUFDbEJDLE1BQU07SUFDTkMsYUFBYTtJQUNiQyxTQUFTO0lBQ1RDLFFBQVE7SUFDUkMsV0FBVztJQUNYQyxNQUFNO0lBQ05DLGdCQUFnQjtJQUNoQkMsT0FBTztJQUNQQyxPQUFPO0lBQ1BDLEtBQUs7SUFDTEMsV0FBVztJQUNYQyxlQUFlO0lBQ2ZDLFdBQVc7SUFDWEMsV0FBVztJQUNYQyxnQkFBZ0I7SUFDaEJDLFNBQVM7SUFDVEMsY0FBYztJQUNkQyxTQUFTO0lBQ1RDLGdCQUFnQjtJQUNoQkMsWUFBWTtJQUNaQyxXQUFXO0lBQ1hDLFVBQVU7SUFDVkMsZUFBZTtJQUNmQyxXQUFXO0lBQ1hDLHNCQUFzQjtJQUN0QkMsU0FBUztJQUNUQyxPQUFPO0lBQ1BDLFdBQVc7SUFDWEMsbUJBQW1CO0lBQ25CQyxtQkFBbUI7SUFDbkJDLG9CQUFvQjtJQUNwQkMsVUFBVTtJQUNWQyxTQUFTO0lBQ1RDLGdCQUFnQjtJQUNoQkMsb0JBQW9CO0lBQ3BCQyxjQUFjO0lBQ2RDLG1CQUFtQjtJQUNuQkMsZUFBZTtJQUNmQyxVQUFVO0lBQ1ZDLGdCQUFnQjtJQUNoQkMsZUFBZTtJQUNmQyxtQkFBbUI7SUFDbkJDLGFBQWE7SUFDYkMsWUFBWTtJQUNaQyxZQUFZO0lBQ1pDLFlBQVk7SUFDWkMsa0JBQWtCO0lBQ2xCQyxpQkFBaUI7SUFDakJDLFVBQVU7SUFDVkMsbUJBQW1CO0lBQ25CQyxzQkFBc0I7SUFDdEJDLG9CQUFvQjtJQUNwQkMsY0FBYztJQUNkQyxZQUFZO0lBQ1pDLGtCQUFrQjtJQUNsQkMsY0FBYztBQUNsQjtBQUNBLE1BQU1DLE1BQU0sQ0FBQztBQUNiLE1BQU1DLFlBQVksV0FBVyxHQUFHO0FBRUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aGF0ZXZlci8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac3RlbmNpbCtjb3JlQDIuNS4yL25vZGVfbW9kdWxlcy9Ac3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhL2luZGV4LmpzP2EyNTUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQlVJTEQgPSB7XG4gICAgYWxsUmVuZGVyRm46IGZhbHNlLFxuICAgIGNtcERpZExvYWQ6IHRydWUsXG4gICAgY21wRGlkVW5sb2FkOiBmYWxzZSxcbiAgICBjbXBEaWRVcGRhdGU6IHRydWUsXG4gICAgY21wRGlkUmVuZGVyOiB0cnVlLFxuICAgIGNtcFdpbGxMb2FkOiB0cnVlLFxuICAgIGNtcFdpbGxVcGRhdGU6IHRydWUsXG4gICAgY21wV2lsbFJlbmRlcjogdHJ1ZSxcbiAgICBjb25uZWN0ZWRDYWxsYmFjazogdHJ1ZSxcbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjazogdHJ1ZSxcbiAgICBlbGVtZW50OiB0cnVlLFxuICAgIGV2ZW50OiB0cnVlLFxuICAgIGhhc1JlbmRlckZuOiB0cnVlLFxuICAgIGxpZmVjeWNsZTogdHJ1ZSxcbiAgICBob3N0TGlzdGVuZXI6IHRydWUsXG4gICAgaG9zdExpc3RlbmVyVGFyZ2V0V2luZG93OiB0cnVlLFxuICAgIGhvc3RMaXN0ZW5lclRhcmdldERvY3VtZW50OiB0cnVlLFxuICAgIGhvc3RMaXN0ZW5lclRhcmdldEJvZHk6IHRydWUsXG4gICAgaG9zdExpc3RlbmVyVGFyZ2V0UGFyZW50OiBmYWxzZSxcbiAgICBob3N0TGlzdGVuZXJUYXJnZXQ6IHRydWUsXG4gICAgbWVtYmVyOiB0cnVlLFxuICAgIG1ldGhvZDogdHJ1ZSxcbiAgICBtb2RlOiB0cnVlLFxuICAgIG9ic2VydmVBdHRyaWJ1dGU6IHRydWUsXG4gICAgcHJvcDogdHJ1ZSxcbiAgICBwcm9wTXV0YWJsZTogdHJ1ZSxcbiAgICByZWZsZWN0OiB0cnVlLFxuICAgIHNjb3BlZDogdHJ1ZSxcbiAgICBzaGFkb3dEb206IHRydWUsXG4gICAgc2xvdDogdHJ1ZSxcbiAgICBjc3NBbm5vdGF0aW9uczogdHJ1ZSxcbiAgICBzdGF0ZTogdHJ1ZSxcbiAgICBzdHlsZTogdHJ1ZSxcbiAgICBzdmc6IHRydWUsXG4gICAgdXBkYXRhYmxlOiB0cnVlLFxuICAgIHZkb21BdHRyaWJ1dGU6IHRydWUsXG4gICAgdmRvbVhsaW5rOiB0cnVlLFxuICAgIHZkb21DbGFzczogdHJ1ZSxcbiAgICB2ZG9tRnVuY3Rpb25hbDogdHJ1ZSxcbiAgICB2ZG9tS2V5OiB0cnVlLFxuICAgIHZkb21MaXN0ZW5lcjogdHJ1ZSxcbiAgICB2ZG9tUmVmOiB0cnVlLFxuICAgIHZkb21Qcm9wT3JBdHRyOiB0cnVlLFxuICAgIHZkb21SZW5kZXI6IHRydWUsXG4gICAgdmRvbVN0eWxlOiB0cnVlLFxuICAgIHZkb21UZXh0OiB0cnVlLFxuICAgIHdhdGNoQ2FsbGJhY2s6IHRydWUsXG4gICAgdGFza1F1ZXVlOiB0cnVlLFxuICAgIGhvdE1vZHVsZVJlcGxhY2VtZW50OiBmYWxzZSxcbiAgICBpc0RlYnVnOiBmYWxzZSxcbiAgICBpc0RldjogZmFsc2UsXG4gICAgaXNUZXN0aW5nOiBmYWxzZSxcbiAgICBoeWRyYXRlU2VydmVyU2lkZTogZmFsc2UsXG4gICAgaHlkcmF0ZUNsaWVudFNpZGU6IGZhbHNlLFxuICAgIGxpZmVjeWNsZURPTUV2ZW50czogZmFsc2UsXG4gICAgbGF6eUxvYWQ6IGZhbHNlLFxuICAgIHByb2ZpbGU6IGZhbHNlLFxuICAgIHNsb3RSZWxvY2F0aW9uOiB0cnVlLFxuICAgIGFwcGVuZENoaWxkU2xvdEZpeDogZmFsc2UsXG4gICAgY2xvbmVOb2RlRml4OiBmYWxzZSxcbiAgICBoeWRyYXRlZEF0dHJpYnV0ZTogZmFsc2UsXG4gICAgaHlkcmF0ZWRDbGFzczogdHJ1ZSxcbiAgICBzYWZhcmkxMDogZmFsc2UsXG4gICAgc2NyaXB0RGF0YU9wdHM6IGZhbHNlLFxuICAgIHNoYWRvd0RvbVNoaW06IGZhbHNlLFxuICAgIHNsb3RDaGlsZE5vZGVzRml4OiBmYWxzZSxcbiAgICBwcm9wQm9vbGVhbjogdHJ1ZSxcbiAgICBwcm9wTnVtYmVyOiB0cnVlLFxuICAgIHByb3BTdHJpbmc6IHRydWUsXG4gICAgY3NzVmFyU2hpbTogZmFsc2UsXG4gICAgY29uc3RydWN0YWJsZUNTUzogdHJ1ZSxcbiAgICBjbXBTaG91bGRVcGRhdGU6IHRydWUsXG4gICAgZGV2VG9vbHM6IGZhbHNlLFxuICAgIGR5bmFtaWNJbXBvcnRTaGltOiBmYWxzZSxcbiAgICBzaGFkb3dEZWxlZ2F0ZXNGb2N1czogdHJ1ZSxcbiAgICBpbml0aWFsaXplTmV4dFRpY2s6IGZhbHNlLFxuICAgIGFzeW5jTG9hZGluZzogZmFsc2UsXG4gICAgYXN5bmNRdWV1ZTogZmFsc2UsXG4gICAgdHJhbnNmb3JtVGFnTmFtZTogZmFsc2UsXG4gICAgYXR0YWNoU3R5bGVzOiB0cnVlLFxufTtcbmNvbnN0IEVudiA9IHt9O1xuY29uc3QgTkFNRVNQQUNFID0gLyogZGVmYXVsdCAqLyAnYXBwJztcblxuZXhwb3J0IHsgQlVJTEQsIEVudiwgTkFNRVNQQUNFIH07XG4iXSwibmFtZXMiOlsiQlVJTEQiLCJhbGxSZW5kZXJGbiIsImNtcERpZExvYWQiLCJjbXBEaWRVbmxvYWQiLCJjbXBEaWRVcGRhdGUiLCJjbXBEaWRSZW5kZXIiLCJjbXBXaWxsTG9hZCIsImNtcFdpbGxVcGRhdGUiLCJjbXBXaWxsUmVuZGVyIiwiY29ubmVjdGVkQ2FsbGJhY2siLCJkaXNjb25uZWN0ZWRDYWxsYmFjayIsImVsZW1lbnQiLCJldmVudCIsImhhc1JlbmRlckZuIiwibGlmZWN5Y2xlIiwiaG9zdExpc3RlbmVyIiwiaG9zdExpc3RlbmVyVGFyZ2V0V2luZG93IiwiaG9zdExpc3RlbmVyVGFyZ2V0RG9jdW1lbnQiLCJob3N0TGlzdGVuZXJUYXJnZXRCb2R5IiwiaG9zdExpc3RlbmVyVGFyZ2V0UGFyZW50IiwiaG9zdExpc3RlbmVyVGFyZ2V0IiwibWVtYmVyIiwibWV0aG9kIiwibW9kZSIsIm9ic2VydmVBdHRyaWJ1dGUiLCJwcm9wIiwicHJvcE11dGFibGUiLCJyZWZsZWN0Iiwic2NvcGVkIiwic2hhZG93RG9tIiwic2xvdCIsImNzc0Fubm90YXRpb25zIiwic3RhdGUiLCJzdHlsZSIsInN2ZyIsInVwZGF0YWJsZSIsInZkb21BdHRyaWJ1dGUiLCJ2ZG9tWGxpbmsiLCJ2ZG9tQ2xhc3MiLCJ2ZG9tRnVuY3Rpb25hbCIsInZkb21LZXkiLCJ2ZG9tTGlzdGVuZXIiLCJ2ZG9tUmVmIiwidmRvbVByb3BPckF0dHIiLCJ2ZG9tUmVuZGVyIiwidmRvbVN0eWxlIiwidmRvbVRleHQiLCJ3YXRjaENhbGxiYWNrIiwidGFza1F1ZXVlIiwiaG90TW9kdWxlUmVwbGFjZW1lbnQiLCJpc0RlYnVnIiwiaXNEZXYiLCJpc1Rlc3RpbmciLCJoeWRyYXRlU2VydmVyU2lkZSIsImh5ZHJhdGVDbGllbnRTaWRlIiwibGlmZWN5Y2xlRE9NRXZlbnRzIiwibGF6eUxvYWQiLCJwcm9maWxlIiwic2xvdFJlbG9jYXRpb24iLCJhcHBlbmRDaGlsZFNsb3RGaXgiLCJjbG9uZU5vZGVGaXgiLCJoeWRyYXRlZEF0dHJpYnV0ZSIsImh5ZHJhdGVkQ2xhc3MiLCJzYWZhcmkxMCIsInNjcmlwdERhdGFPcHRzIiwic2hhZG93RG9tU2hpbSIsInNsb3RDaGlsZE5vZGVzRml4IiwicHJvcEJvb2xlYW4iLCJwcm9wTnVtYmVyIiwicHJvcFN0cmluZyIsImNzc1ZhclNoaW0iLCJjb25zdHJ1Y3RhYmxlQ1NTIiwiY21wU2hvdWxkVXBkYXRlIiwiZGV2VG9vbHMiLCJkeW5hbWljSW1wb3J0U2hpbSIsInNoYWRvd0RlbGVnYXRlc0ZvY3VzIiwiaW5pdGlhbGl6ZU5leHRUaWNrIiwiYXN5bmNMb2FkaW5nIiwiYXN5bmNRdWV1ZSIsInRyYW5zZm9ybVRhZ05hbWUiLCJhdHRhY2hTdHlsZXMiLCJFbnYiLCJOQU1FU1BBQ0UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@stencil+core@2.5.2/node_modules/@stencil/core/internal/app-data/index.js\n");

/***/ })

};
;